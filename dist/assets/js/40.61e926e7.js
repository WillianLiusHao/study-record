(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{221:function(v,e,_){"use strict";_.r(e);var t=_(6),s=Object(t.a)({},(function(){var v=this,e=v._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"mini-vite"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mini-vite"}},[v._v("#")]),v._v(" mini-vite")]),v._v(" "),e("p",[v._v("学习 vite 的运行机制，核心原理")]),v._v(" "),e("h2",{attrs:{id:"运行部分-serve"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#运行部分-serve"}},[v._v("#")]),v._v(" 运行部分 serve")]),v._v(" "),e("blockquote",[e("p",[v._v("变化 v1.0 => v2.0")])]),v._v(" "),e("ul",[e("li",[v._v("koa => http + connect")]),v._v(" "),e("li",[v._v("rollup 的 commonjs 插件 => esbuild")])]),v._v(" "),e("h3",{attrs:{id:"一、预构建-强缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、预构建-强缓存"}},[v._v("#")]),v._v(" 一、预构建（强缓存）")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("目的："),e("code",[v._v("兼容性")]),v._v("、"),e("code",[v._v("性能")]),v._v("、"),e("code",[v._v("缓存")])])]),v._v(" "),e("li",[e("p",[v._v("做了啥事：")]),v._v(" "),e("ul",[e("li",[v._v("将非 "),e("code",[v._v("esm")]),v._v(" 规范的代码转换成 符合 "),e("code",[v._v("esm")]),v._v(" 规范的代码")]),v._v(" "),e("li",[v._v("将第三方依赖包内部的多个文件合并成一个，减少 "),e("code",[v._v("http")]),v._v(" 请求数量")])])]),v._v(" "),e("li",[e("p",[v._v("主要流程：")])])]),v._v(" "),e("ol",[e("li",[v._v("在server启动成功之前进行依赖预构建。")]),v._v(" "),e("li",[v._v("读取用户的package-lock.json，yarn.lock，pnpm-lock.yaml，生成depHash。")]),v._v(" "),e("li",[v._v("读取上次文件缓存的预构建文件信息，如果有，则将获取到的hash和上一步的depHash进行比较，一样则返回，否则重新构建。没有缓存或设置force参数，则重新构建。")]),v._v(" "),e("li",[v._v("利用esbuild，对项目文件进行扫描，获取到项目依赖。")]),v._v(" "),e("li",[v._v("利用esbuild，将项目依赖的模块化方式转化成es module方式。")]),v._v(" "),e("li",[v._v("将转换的模块存入cacheDir（默认是node_module/.vite)。")]),v._v(" "),e("li",[v._v("前端请求资源时，判断请求资源是否为依赖（即bare import），如果是则替换为缓存文件路径，加载相应文件。")]),v._v(" "),e("li",[v._v("启动服务后，每当引入新的依赖，则重新进行依赖构建。执行2，3，4，5过程。")])]),v._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[v._v("  启动服务，改写http linten 方法\n            ↓    \n  optimizeDeps：预构建入口函数\n            ↓\n  "),e("span",{pre:!0,attrs:{class:"token function"}},[v._v("cachedMetadata：判断缓存是否过期或更新了")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("未过期直接返回使用"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\n            ↓\n  discoverProjectDependencies：寻找项目依赖\n      → "),e("span",{pre:!0,attrs:{class:"token function"}},[v._v("scanImport")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("构建依赖项，返回deps和missing"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\n          → "),e("span",{pre:!0,attrs:{class:"token function"}},[v._v("esbuildScanPlugin")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("！esbuild插件，通过对不同类型的文件进行处理，最后得出需构建的依赖项"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\n            ↓\n  runOptimizeDeps：打包依赖项，输出缓存文件\n      → "),e("span",{pre:!0,attrs:{class:"token function"}},[v._v("getProcessingDepsCacheDir")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("初始化依赖缓存文件夹"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\n      → "),e("span",{pre:!0,attrs:{class:"token function"}},[v._v("depsInfo")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("遍历 depsInfo 依赖信息，进行打包"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\n")])])]),e("ul",[e("li",[v._v("重难点：\n"),e("ul",[e("li",[v._v("核心打包插件: "),e("code",[v._v("esbuildDepPlugin")])]),v._v(" "),e("li",[v._v("插件管理容器："),e("code",[v._v("PluginContainer")])]),v._v(" "),e("li",[v._v("模块图：ModuleGraph")])])])]),v._v(" "),e("h3",{attrs:{id:"二、请求拦截和改写-依赖解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、请求拦截和改写-依赖解析"}},[v._v("#")]),v._v(" 二、请求拦截和改写（依赖解析）")]),v._v(" "),e("ul",[e("li",[v._v("js\n"),e("ul",[e("li",[v._v("裸模块处理\n"),e("ul",[e("li",[v._v("改写模块名,如 "),e("code",[v._v("vue => /@module/vue")])]),v._v(" "),e("li",[v._v("然后发起 "),e("code",[v._v("/@module/vue")]),v._v(" 请求后就会去 "),e("code",[v._v("node_module")]),v._v(" 中找相应模块")]),v._v(" "),e("li",[v._v("找模块下 "),e("code",[v._v("package.json")]),v._v(" 的 "),e("code",[v._v("module")]),v._v(" 字段得到真正源文件地址，引入")])])]),v._v(" "),e("li",[v._v("相对路径：统一改为相对项目根路径的地址")])])]),v._v(" "),e("li",[v._v("vue(文件改写)\n"),e("ul",[e("li",[v._v("template：生成render函数")]),v._v(" "),e("li",[v._v("script")]),v._v(" "),e("li",[v._v("style")])])]),v._v(" "),e("li",[v._v("css")])]),v._v(" "),e("h3",{attrs:{id:"三、热更新"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、热更新"}},[v._v("#")]),v._v(" 三、热更新")]),v._v(" "),e("ul",[e("li",[v._v("服务端\n"),e("ul",[e("li",[v._v("建立 "),e("code",[v._v("ws")]),v._v(" 连接，利用 "),e("code",[v._v("chokidar")]),v._v(" 监听文件变化")]),v._v(" "),e("li",[v._v("利用 vue-sfc 对文件生成 ast 树，如有缓存，对比前后的 ast 树")]),v._v(" "),e("li",[v._v("对变化进行分类，并推送消息给客户端\n"),e("ul",[e("li",[v._v("reload："),e("code",[v._v("script")]),v._v(" 变化，即 "),e("code",[v._v("setup")]),v._v(" 函数变化，需重新加载组件")]),v._v(" "),e("li",[v._v("rerender："),e("code",[v._v("template")]),v._v(" 变化，即 "),e("code",[v._v("render")]),v._v(" 函数变化，需重新渲染")]),v._v(" "),e("li",[v._v("full-reload：非 vue 文件变化，如js资源文件变化,则刷新页面")])])])])]),v._v(" "),e("li",[v._v("客户端（"),e("strong",[v._v("客户端的逻辑代码是在解析.vue 文件的时候，注入一段请求js文件的代码，通过客户端发起请求后得到")]),v._v("）\n"),e("ul",[e("li",[v._v("建立连接")]),v._v(" "),e("li",[v._v("收到消息，确定变化类型，做出相应变化(利用vue 挂到全局的 "),e("code",[v._v("__VUE_HMR_RUNTIME__")]),v._v(" 方法，可以reload 或者 rerender 组件)")])])])]),v._v(" "),e("h2",{attrs:{id:"打包部分-build"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#打包部分-build"}},[v._v("#")]),v._v(" 打包部分 build")])])}),[],!1,null,null,null);e.default=s.exports}}]);