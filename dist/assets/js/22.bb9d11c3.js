(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{203:function(t,e,v){"use strict";v.r(e);var _=v(6),s=Object(_.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"事件循环"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件循环"}},[t._v("#")]),t._v(" 事件循环")]),t._v(" "),e("h3",{attrs:{id:"任务分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#任务分类"}},[t._v("#")]),t._v(" 任务分类")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("宏任务")]),t._v(" "),e("ul",[e("li",[t._v("setTimeout")]),t._v(" "),e("li",[t._v("setInterval")]),t._v(" "),e("li",[t._v("setImmediate(node)")]),t._v(" "),e("li",[t._v("I/O")]),t._v(" "),e("li",[t._v("UI rendering")])])]),t._v(" "),e("li",[e("p",[t._v("微任务")]),t._v(" "),e("ul",[e("li",[t._v("process.nextTick")]),t._v(" "),e("li",[t._v("promises")]),t._v(" "),e("li",[t._v("Object.observe")]),t._v(" "),e("li",[t._v("MutationObserver")])])])]),t._v(" "),e("h3",{attrs:{id:"浏览器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器"}},[t._v("#")]),t._v(" 浏览器")]),t._v(" "),e("blockquote",[e("p",[t._v("event loop 过程：")])]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("eventloop start")]),t._v("：从宏任务队列中，按照入队顺序，找到第一个执行的宏任务，放入调用栈，开始执行；")]),t._v(" "),e("li",[e("strong",[t._v("macro task")]),t._v("：执行完该宏任务下所有同步任务后，即调用栈清空后，该宏任务被推出宏任务队列；")]),t._v(" "),e("li",[e("strong",[t._v("micro task")]),t._v("：然后微任务队列开始按照入队顺序，依次执行其中的微任务，直至微任务队列清空为止；")]),t._v(" "),e("li",[e("strong",[t._v("once loop end")]),t._v("：当微任务队列清空后，一个事件循环结束 => "),e("code",[t._v("渲染页面")])]),t._v(" "),e("li",[t._v("接着从宏任务队列中，找到下一个执行的宏任务，开始第二个事件循环，直至宏任务队列清空为止。")])]),t._v(" "),e("blockquote",[e("p",[t._v("这里有几个重点：")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("当我们第一次执行的时候，解释器会将整体代码script放入宏任务队列中，因此事件循环是从"),e("code",[t._v("第一个宏任务script")]),t._v("开始的；")])]),t._v(" "),e("li",[e("p",[t._v("如果在执行微任务的过程中，产生新的微任务添加到微任务队列中，也需要一起清空；微任务队列没清空之前，是不会执行下一个宏任务的。")])])]),t._v(" "),e("h3",{attrs:{id:"node"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node"}},[t._v("#")]),t._v(" Node")]),t._v(" "),e("p",[t._v("一次循环要经过六个阶段：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("timers：计时器（setTimeout、setInterval等的回调函数存放在里边)")])]),t._v(" "),e("li",[t._v("pending")]),t._v(" "),e("li",[t._v("callbackidle prepare")]),t._v(" "),e("li",[e("strong",[t._v("poll：轮询队列（除timers、check之外的回调存放在这里)")])]),t._v(" "),e("li",[e("strong",[t._v("check：检查阶段（使用 setImmediate 的回调会直接进入这个队列)")])]),t._v(" "),e("li",[t._v("close callbacks")])]),t._v(" "),e("h4",{attrs:{id:"settimeout-和-setimmediate-顺序-宏任务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#settimeout-和-setimmediate-顺序-宏任务"}},[t._v("#")]),t._v(" setTimeout 和 setImmediate 顺序（宏任务）")]),t._v(" "),e("h4",{attrs:{id:"nexttick-与-promise-微任务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nexttick-与-promise-微任务"}},[t._v("#")]),t._v(" nextTick 与 Promise（微任务）")]),t._v(" "),e("ul",[e("li",[t._v("两者都不是node时间循环的一部分，所以不会开启额外的线程去处理")]),t._v(" "),e("li",[t._v("优先级: nextTick > Promise")])])])}),[],!1,null,null,null);e.default=s.exports}}]);