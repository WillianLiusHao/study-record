<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端随笔 WillianLiusHao</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="勤学如春起之苗，不见其增，日有所长">
    
    <link rel="preload" href="/study-record/assets/css/0.styles.ee9d39b9.css" as="style"><link rel="preload" href="/study-record/assets/js/app.17aac99d.js" as="script"><link rel="preload" href="/study-record/assets/js/2.016b014c.js" as="script"><link rel="preload" href="/study-record/assets/js/1.4d9187d3.js" as="script"><link rel="preload" href="/study-record/assets/js/82.d198b1a8.js" as="script"><link rel="prefetch" href="/study-record/assets/js/10.36503388.js"><link rel="prefetch" href="/study-record/assets/js/11.fa712348.js"><link rel="prefetch" href="/study-record/assets/js/12.276efbb7.js"><link rel="prefetch" href="/study-record/assets/js/13.d963e8a7.js"><link rel="prefetch" href="/study-record/assets/js/14.d7577f19.js"><link rel="prefetch" href="/study-record/assets/js/15.cc1f798a.js"><link rel="prefetch" href="/study-record/assets/js/16.0291a868.js"><link rel="prefetch" href="/study-record/assets/js/17.0a30da7e.js"><link rel="prefetch" href="/study-record/assets/js/18.0cfbb48c.js"><link rel="prefetch" href="/study-record/assets/js/19.0e21e7df.js"><link rel="prefetch" href="/study-record/assets/js/20.03daea74.js"><link rel="prefetch" href="/study-record/assets/js/21.3b8bed13.js"><link rel="prefetch" href="/study-record/assets/js/22.044c0ee0.js"><link rel="prefetch" href="/study-record/assets/js/23.2e58d861.js"><link rel="prefetch" href="/study-record/assets/js/24.5d91c0ed.js"><link rel="prefetch" href="/study-record/assets/js/25.ecbc19e1.js"><link rel="prefetch" href="/study-record/assets/js/26.ea32b772.js"><link rel="prefetch" href="/study-record/assets/js/27.7994195c.js"><link rel="prefetch" href="/study-record/assets/js/28.1d2d8781.js"><link rel="prefetch" href="/study-record/assets/js/29.29644b5e.js"><link rel="prefetch" href="/study-record/assets/js/3.babd7043.js"><link rel="prefetch" href="/study-record/assets/js/30.c1b69b54.js"><link rel="prefetch" href="/study-record/assets/js/31.b8531d02.js"><link rel="prefetch" href="/study-record/assets/js/32.1a3d2119.js"><link rel="prefetch" href="/study-record/assets/js/33.4073fb14.js"><link rel="prefetch" href="/study-record/assets/js/34.5873267c.js"><link rel="prefetch" href="/study-record/assets/js/35.22f30e0a.js"><link rel="prefetch" href="/study-record/assets/js/36.9acadcf0.js"><link rel="prefetch" href="/study-record/assets/js/37.514fb866.js"><link rel="prefetch" href="/study-record/assets/js/38.cfd8eaf8.js"><link rel="prefetch" href="/study-record/assets/js/39.b18930b7.js"><link rel="prefetch" href="/study-record/assets/js/4.fa802c58.js"><link rel="prefetch" href="/study-record/assets/js/40.ce709979.js"><link rel="prefetch" href="/study-record/assets/js/41.2042214a.js"><link rel="prefetch" href="/study-record/assets/js/42.87b852a8.js"><link rel="prefetch" href="/study-record/assets/js/43.b4287906.js"><link rel="prefetch" href="/study-record/assets/js/44.6bf10f9a.js"><link rel="prefetch" href="/study-record/assets/js/45.25eeefa0.js"><link rel="prefetch" href="/study-record/assets/js/46.0f8cb01f.js"><link rel="prefetch" href="/study-record/assets/js/47.288a54bb.js"><link rel="prefetch" href="/study-record/assets/js/48.b613c839.js"><link rel="prefetch" href="/study-record/assets/js/49.d18be6a8.js"><link rel="prefetch" href="/study-record/assets/js/5.87700c1c.js"><link rel="prefetch" href="/study-record/assets/js/50.400520f0.js"><link rel="prefetch" href="/study-record/assets/js/51.7eab7fad.js"><link rel="prefetch" href="/study-record/assets/js/52.caaed993.js"><link rel="prefetch" href="/study-record/assets/js/53.55fabd90.js"><link rel="prefetch" href="/study-record/assets/js/54.1a826e47.js"><link rel="prefetch" href="/study-record/assets/js/55.e0c40590.js"><link rel="prefetch" href="/study-record/assets/js/56.42f5fc5f.js"><link rel="prefetch" href="/study-record/assets/js/57.8f30f2af.js"><link rel="prefetch" href="/study-record/assets/js/58.63b92872.js"><link rel="prefetch" href="/study-record/assets/js/59.bd09ccb3.js"><link rel="prefetch" href="/study-record/assets/js/6.9086b17c.js"><link rel="prefetch" href="/study-record/assets/js/60.e7406693.js"><link rel="prefetch" href="/study-record/assets/js/61.f2e5a88e.js"><link rel="prefetch" href="/study-record/assets/js/62.0b65291e.js"><link rel="prefetch" href="/study-record/assets/js/63.8de3fdca.js"><link rel="prefetch" href="/study-record/assets/js/64.4e11deef.js"><link rel="prefetch" href="/study-record/assets/js/65.54d039db.js"><link rel="prefetch" href="/study-record/assets/js/66.84db7a63.js"><link rel="prefetch" href="/study-record/assets/js/67.1c39ed43.js"><link rel="prefetch" href="/study-record/assets/js/68.c06e0761.js"><link rel="prefetch" href="/study-record/assets/js/69.ab2a8f77.js"><link rel="prefetch" href="/study-record/assets/js/7.8ac123f2.js"><link rel="prefetch" href="/study-record/assets/js/70.4ac2a1eb.js"><link rel="prefetch" href="/study-record/assets/js/71.a10a64a1.js"><link rel="prefetch" href="/study-record/assets/js/72.f5ee9344.js"><link rel="prefetch" href="/study-record/assets/js/73.ce032dd2.js"><link rel="prefetch" href="/study-record/assets/js/74.0867294f.js"><link rel="prefetch" href="/study-record/assets/js/75.a2ebcace.js"><link rel="prefetch" href="/study-record/assets/js/76.c3eb5991.js"><link rel="prefetch" href="/study-record/assets/js/77.06a7f50c.js"><link rel="prefetch" href="/study-record/assets/js/78.5fb20fe2.js"><link rel="prefetch" href="/study-record/assets/js/79.f6266092.js"><link rel="prefetch" href="/study-record/assets/js/80.d3237485.js"><link rel="prefetch" href="/study-record/assets/js/81.59c4725f.js"><link rel="prefetch" href="/study-record/assets/js/83.88fb1a26.js"><link rel="prefetch" href="/study-record/assets/js/84.43f20fa1.js"><link rel="prefetch" href="/study-record/assets/js/85.2ea9262b.js"><link rel="prefetch" href="/study-record/assets/js/86.d3f5931d.js"><link rel="prefetch" href="/study-record/assets/js/87.b1833438.js"><link rel="prefetch" href="/study-record/assets/js/88.4359c8a8.js"><link rel="prefetch" href="/study-record/assets/js/89.2c40610e.js"><link rel="prefetch" href="/study-record/assets/js/90.5546c4ab.js"><link rel="prefetch" href="/study-record/assets/js/91.22180d3b.js"><link rel="prefetch" href="/study-record/assets/js/92.15962496.js"><link rel="prefetch" href="/study-record/assets/js/vendors~docsearch.32379f2b.js">
    <link rel="stylesheet" href="/study-record/assets/css/0.styles.ee9d39b9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/study-record/" class="home-link router-link-active"><!----> <span class="site-name">前端随笔 WillianLiusHao</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/WillianLiusHao" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/WillianLiusHao" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>1.基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>2.项目</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>3.算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>4.日常</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>20251101</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/" aria-current="page" class="sidebar-link">index</a></li><li><section class="sidebar-group collapsable is-sub-group depth-2"><p class="sidebar-heading"><span>plan</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-2"><p class="sidebar-heading open"><span>框架</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/study-record/4.日常/20251101/框架/源码理解.html" class="sidebar-link">源码理解</a></li><li><a href="/study-record/4.日常/20251101/框架/高频.html" class="active sidebar-link">高频</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li><li><a href="/study-record/4.日常/20251101/面试相关.html" class="sidebar-link">面试相关</a></li><li><section class="sidebar-group collapsable is-sub-group depth-2"><p class="sidebar-heading"><span>项目</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><a href="/study-record/4.日常/forCVTE.html" class="sidebar-link">forCVTE</a></li><li><a href="/study-record/4.日常/inter-records.html" class="sidebar-link">inter-records</a></li><li><a href="/study-record/4.日常/notes.html" class="sidebar-link">notes</a></li><li><a href="/study-record/4.日常/plan.html" class="sidebar-link">plan</a></li><li><a href="/study-record/4.日常/ts-question.html" class="sidebar-link">ts-question</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>5.脑图</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/study-record/" aria-current="page" class="sidebar-link">index</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>Vue 作为前端主流框架，面试 / 笔试中的高频考点集中在<strong>核心原理、组件化、响应式、生命周期、性能优化、Vue2/Vue3 差异</strong>等方向，以下按「基础必问」「原理深挖」「实战应用」「Vue3 新特性」四大维度梳理高频考点，附核心答案和考察思路：</p> <h3 id="一、基础必问考点-入门级-必考"><a href="#一、基础必问考点-入门级-必考" class="header-anchor">#</a> 一、基础必问考点（入门级，必考）</h3> <h4 id="_1-vue-核心特性"><a href="#_1-vue-核心特性" class="header-anchor">#</a> 1. Vue 核心特性</h4> <ul><li><p><strong>考察问题</strong>：Vue 的核心特性有哪些？</p></li> <li><p>核心答案：</p> <ul><li>数据驱动（MVVM 思想，数据变化自动更新视图）；</li> <li>组件化（独立可复用的 UI 单元，单文件组件 SFC）；</li> <li>双向绑定（v-model 语法糖，Vue2 <code>Object.defineProperty</code>/Vue3 <code>Proxy</code>）；</li> <li>指令系统（v-if/v-for/v-bind/v-on 等，简化 DOM 操作）；</li> <li>生命周期（组件从创建到销毁的完整流程）；</li> <li>混入（Mixin）/ 插件（Plugin）（逻辑复用）。</li></ul></li></ul> <h4 id="_2-生命周期-vue2-vue3-对比"><a href="#_2-生命周期-vue2-vue3-对比" class="header-anchor">#</a> 2. 生命周期（Vue2/Vue3 对比）</h4> <ul><li><p>考察问题：</p> <ul><li>Vue2 生命周期钩子有哪些？执行顺序？</li> <li>created 和 mounted 的区别？</li> <li>Vue3 组合式 API 中生命周期如何变化？</li></ul></li></ul> <h4 id="_3-v-if-vs-v-show"><a href="#_3-v-if-vs-v-show" class="header-anchor">#</a> 3. v-if vs v-show</h4> <ul><li><p><strong>考察问题</strong>：v-if 和 v-show 的区别？使用场景？</p></li> <li><p>核心答案</p> <ul><li>底层逻辑：v-if 是<strong>条件渲染</strong>（满足条件才创建 DOM，不满足则销毁）；v-show 是<strong>样式切换</strong>（始终创建 DOM，通过 <code>display: none</code> 控制显示 / 隐藏）。</li> <li>性能消耗：v-if 切换有<strong>编译 / 挂载 / 销毁开销</strong>，初始渲染开销低；v-show 初始渲染开销高，切换开销低。</li> <li>使用场景：v-if 适用于<strong>低频切换</strong>（如权限控制）；v-show 适用于<strong>高频切换</strong>（如 Tab 切换）。</li> <li>额外：v-if 可以和 v-else/v-else-if 配合，v-show 不支持；v-if 优先级高于 v-for（Vue2 中不建议同用，Vue3 修复了优先级问题）。</li></ul></li></ul> <h4 id="_4-v-for-关键问题"><a href="#_4-v-for-关键问题" class="header-anchor">#</a> 4. v-for 关键问题</h4> <ul><li><p>考察问题</p> <ul><li>v-for 为什么要加 key？key 的作用？</li> <li>v-for 和 v-if 同用的问题？</li></ul></li> <li><p>核心答案</p> <ul><li>key 的作用：作为 DOM 节点的唯一标识，Vue 基于 key 做<strong>diff 算法优化</strong>，避免错误的 DOM 复用（如列表乱序、数据更新异常）；key 推荐用唯一 id，而非 index（index 会随列表变化，失去唯一标识意义）。</li></ul></li> <li><p>v-for 与 v-if 同用（Vue2）：v-for 优先级更高，会先遍历所有元素再判断 v-if，导致<strong>性能浪费</strong>；解决方案：外层套 template 用 v-if，或用 computed 过滤列表。</p></li></ul> <h4 id="_5-双向绑定原理-vue2-vue3"><a href="#_5-双向绑定原理-vue2-vue3" class="header-anchor">#</a> 5. 双向绑定原理（Vue2/Vue3）</h4> <ul><li><p><strong>考察问题</strong>：Vue 的双向绑定原理？Vue2 和 Vue3 的区别？</p></li> <li><p>核心答案</p> <ul><li>核心思想：<strong>数据劫持 + 发布 - 订阅模式</strong>。</li> <li>Vue2 实现：
<ol><li>用 <code>Object.defineProperty</code> 劫持 data 中所有属性的 getter/setter；</li> <li>模板编译时，解析指令 / 插值表达式，为每个依赖创建 Watcher；</li> <li>getter 中收集依赖（Watcher 加入 Dep），setter 中触发 Dep 通知所有 Watcher 更新视图。</li></ol></li> <li>Vue3 实现：
<ol><li>用 <code>Proxy</code> 代理整个响应式对象（而非单个属性），支持数组 / 新增属性的劫持；</li> <li>结合 <code>Reflect</code> 实现属性操作的拦截，解决 <code>Object.defineProperty</code> 的局限性；</li> <li>引入 Reactive Effect 替代 Watcher，基于副作用函数实现依赖收集。</li></ol></li> <li>局限性对比：Vue2 无法监听数组下标修改 / 对象新增属性（需用 Vue.set）；Vue3 Proxy 天然支持。</li></ul></li></ul> <h3 id="二、原理深挖考点-中高级-区分度高"><a href="#二、原理深挖考点-中高级-区分度高" class="header-anchor">#</a> 二、原理深挖考点（中高级，区分度高）</h3> <h4 id="_1-vue-响应式原理深度拆解"><a href="#_1-vue-响应式原理深度拆解" class="header-anchor">#</a> 1. Vue 响应式原理深度拆解</h4> <ul><li><p>考察问题</p> <ul><li>为什么 Vue2 无法监听数组的 push/pop 等方法？如何解决？</li> <li>Dep 和 Watcher 的关系？</li> <li>Vue3 的响应式系统（Reactive/Ref/Effect）原理？</li></ul></li> <li><p>核心答案</p> <ul><li>Vue2 数组问题：<code>Object.defineProperty</code> 只能劫持对象属性，无法劫持数组下标；Vue2 对数组的 7 个变异方法（push/pop/shift/unshift/splice/sort/reverse）做了重写，触发视图更新；但直接修改下标（如 arr [0] = 1）仍无法监听，需用 <code>Vue.set(arr, 0, 1)</code>。</li> <li>Dep &amp; Watcher：Dep（依赖管理器）对应单个响应式属性，Watcher 对应单个视图依赖；一个 Dep 可包含多个 Watcher（一对多），一个 Watcher 可依赖多个 Dep（多对一）；数据更新时，Dep 遍历所有 Watcher 执行 update。</li> <li>Vue3 响应式：
<ul><li>Reactive：针对对象，返回 Proxy 代理对象；</li> <li>Ref：针对基本类型，包装为 {value: xxx} 的对象，通过 getter/setter 劫持；</li> <li>Effect：副作用函数，执行时收集依赖（track），依赖变化时重新执行（trigger）。</li></ul></li></ul></li></ul> <h4 id="_2-vue-虚拟-dom-diff-算法"><a href="#_2-vue-虚拟-dom-diff-算法" class="header-anchor">#</a> 2. Vue 虚拟 DOM &amp; Diff 算法</h4> <ul><li><p>考察问题</p> <ul><li>为什么需要虚拟 DOM？</li> <li>Vue 的 Diff 算法核心逻辑？</li> <li>Key 在 Diff 中的作用？</li></ul></li> <li><p>核心答案</p> <ul><li>虚拟 DOM 意义：用 JS 对象描述 DOM 结构，避免直接操作真实 DOM（开销大）；跨平台（可渲染到小程序 / Canvas 等）；批量更新，减少 DOM 操作次数。</li> <li>Vue Diff 核心（同级比较，非跨层级）：
<ol><li>先判断节点类型，类型不同直接销毁旧节点创建新节点；</li> <li>类型相同则对比属性（props/class/style），更新差异；</li> <li>列表对比（v-for）：用 key 建立新旧节点的映射，采用<strong>双指针法</strong>（头头 / 尾尾 / 头尾 / 尾头）快速匹配，减少移动 / 删除操作；</li> <li>无法匹配时，用 key 生成的映射表查找，找不到则创建新节点，最后处理剩余节点。</li></ol></li> <li>Key 的作用：让 Diff 算法快速定位相同节点，避免不必要的 DOM 移动 / 重建，提升列表更新性能。</li></ul></li></ul> <h4 id="_3-组件通信方式-全场景"><a href="#_3-组件通信方式-全场景" class="header-anchor">#</a> 3. 组件通信方式（全场景）</h4> <ul><li><p><strong>考察问题</strong>：Vue 有哪些组件通信方式？适用场景？</p></li> <li><p>核心答案</p> <table><thead><tr><th>通信方式</th> <th>适用场景</th> <th>核心用法</th></tr></thead> <tbody><tr><td>props/$emit</td> <td>父子组件</td> <td>父传子用 props，子传父用 $emit</td></tr> <tr><td><em>p<strong>a</strong>re<strong>n</strong>t</em>/children</td> <td>父子组件（直接访问）</td> <td>子组件 this.$parent 访问父实例</td></tr> <tr><td>$refs</td> <td>父访问子组件（DOM / 实例）</td> <td>父组件 ref=&quot;xxx&quot; → this.$refs.xxx</td></tr> <tr><td>provide/inject</td> <td>跨层级组件（祖孙）</td> <td>父 provide 提供数据，子 inject 注入</td></tr> <tr><td>Vuex/Pinia</td> <td>全局状态管理（任意组件）</td> <td>集中式存储，响应式共享</td></tr> <tr><td>EventBus</td> <td>任意组件（小型项目）</td> <td>新建 Vue 实例作为事件中心</td></tr> <tr><td><em>a<strong>tt</strong>rs</em>/listeners</td> <td>跨层级透传（祖孙）</td> <td>父传子未声明的 props 存入 $attrs</td></tr></tbody></table> <ul><li>补充：Vue3 中 $attrs 包含 class/style，Vue2 不包含；Pinia 替代 Vuex 成为官方推荐，更轻量、支持 TypeScript。</li></ul></li></ul> <h4 id="_4-mixin-原理-优缺点-延伸到-composition-api"><a href="#_4-mixin-原理-优缺点-延伸到-composition-api" class="header-anchor">#</a> 4. Mixin 原理 &amp; 优缺点（延伸到 Composition API）</h4> <ul><li><p>考察问题</p> <ul><li>Mixin 的合并规则？</li> <li>Mixin 的缺点？为什么 Vue3 推荐 Composition API？</li></ul></li> <li><p>核心答案</p> <p>（结合前文原理）：</p> <ul><li>合并规则：生命周期钩子数组合并（混入先执行），data / 方法同名覆盖（组件 &gt; 混入），watch 数组合并（混入先执行）；</li> <li>Mixin 缺点：命名冲突、逻辑来源模糊、不支持参数；</li> <li>Composition API 优势：函数式组合，逻辑来源清晰；支持参数传递；无命名冲突；更好的 TypeScript 支持。</li></ul></li></ul> <h4 id="_5-异步更新队列-nexttick-原理"><a href="#_5-异步更新队列-nexttick-原理" class="header-anchor">#</a> 5. 异步更新队列（$nextTick 原理）</h4> <ul><li><p>考察问题</p> <ul><li>Vue 的异步更新原理？为什么需要 $nextTick？</li> <li>$nextTick 的实现方式？</li></ul></li> <li><p>核心答案</p> <ul><li>异步更新原因：Vue 为提升性能，将数据更新的视图更新操作<strong>批量延迟执行</strong>，而非同步更新；数据变化时，Watcher 标记为脏，放入异步队列，等待下一个事件循环执行更新。</li> <li>$nextTick 作用：等待异步更新队列执行完成后执行回调，保证获取到更新后的 DOM。</li> <li>实现方式：优先使用微任务（Promise.then &gt; MutationObserver），降级到宏任务（setTimeout）；Vue3 中统一使用 Promise。</li></ul></li></ul> <h3 id="三、实战应用考点-工程化-性能-问题排查"><a href="#三、实战应用考点-工程化-性能-问题排查" class="header-anchor">#</a> 三、实战应用考点（工程化 / 性能 / 问题排查）</h3> <h4 id="_1-vue-性能优化手段"><a href="#_1-vue-性能优化手段" class="header-anchor">#</a> 1. Vue 性能优化手段</h4> <ul><li><p><strong>考察问题</strong>：Vue 项目有哪些性能优化方式？</p></li> <li><p>核心答案</p> <ul><li>代码层面：
<ol><li>合理使用 v-if/v-show，避免 v-for 与 v-if 同用；</li> <li>列表优化：key 用唯一 id，大数据列表用虚拟列表（vue-virtual-scroller）；</li> <li>响应式优化：非响应式数据不放入 data（用 Object.freeze 冻结）；</li> <li>计算属性缓存：用 computed 替代方法（避免重复执行）；</li> <li>异步组件：路由 / 组件按需加载（const Comp = () =&gt; import ('./Comp.vue')）。</li></ol></li> <li>工程化层面：
<ol><li>打包优化：Tree-Shaking、CDN 引入第三方库、压缩代码；</li> <li>懒加载：路由懒加载、图片懒加载（v-lazy）；</li> <li>缓存优化：keep-alive 缓存组件（避免重复渲染）；</li> <li>服务端优化：SSR（Nuxt.js）提升首屏加载速度。</li></ol></li> <li>进阶优化：
<ol><li>自定义指令封装高频 DOM 操作；</li> <li>避免过度响应式：Vue3 中用 shallowReactive/shallowRef；</li> <li>事件解绑：组件销毁前解绑自定义事件，避免内存泄漏。</li></ol></li></ul></li></ul> <h4 id="_2-keep-alive-原理-应用"><a href="#_2-keep-alive-原理-应用" class="header-anchor">#</a> 2. keep-alive 原理 &amp; 应用</h4> <ul><li><p><strong>考察问题</strong>：keep-alive 的作用？原理？激活 / 失活钩子？</p></li> <li><p>核心答案</p> <ul><li>作用：缓存组件实例，避免重复创建 / 销毁，提升切换性能（如 Tab 切换）。</li> <li>原理：
<ol><li>keep-alive 是抽象组件（不渲染真实 DOM），内部维护一个缓存对象（cache），存储组件实例；</li> <li>组件首次渲染时存入 cache，再次渲染时直接从 cache 取出，不执行 created/mounted 钩子；</li> <li>可通过 include/exclude 属性指定缓存 / 排除的组件，max 属性限制缓存数量（LRU 策略）。</li></ol></li> <li>钩子：缓存组件激活时触发 <code>activated</code>，失活时触发 <code>deactivated</code>（Vue3 中对应 onActivated/onDeactivated）。</li></ul></li></ul> <h4 id="_3-路由相关-vue-router"><a href="#_3-路由相关-vue-router" class="header-anchor">#</a> 3. 路由相关（Vue Router）</h4> <ul><li><p>考察问题</p> <ul><li>路由守卫有哪些？执行顺序？</li> <li>路由懒加载如何实现？</li> <li>hash 模式 vs history 模式的区别？</li></ul></li> <li><p>核心答案</p> <ul><li>路由守卫分类：
<ol><li>全局守卫：beforeEach（前置）、beforeResolve（解析前）、afterEach（后置）；</li> <li>路由独享守卫：beforeEnter；</li> <li>组件内守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave；</li></ol></li> <li>执行顺序：全局 beforeEach → 路由 beforeEnter → 组件 beforeRouteEnter → 全局 beforeResolve → 全局 afterEach。</li> <li>路由懒加载：结合 import () 动态导入，如 <code>{ path: '/home', component: () =&gt; import('./Home.vue') }</code>，打包时拆分 chunk，减小首屏体积。</li> <li>模式区别：
<ul><li>hash 模式：基于 URL hash（#），兼容性好，无需后端配置；</li> <li>history 模式：基于 HTML5 History API，URL 无 #，需后端配置（nginx 重定向到 index.html），避免刷新 404。</li></ul></li></ul></li></ul> <h4 id="_4-常见问题排查"><a href="#_4-常见问题排查" class="header-anchor">#</a> 4. 常见问题排查</h4> <ul><li><p>考察问题</p> <ul><li>为什么 data 必须是函数？</li> <li>组件中修改 props 会报错？如何解决？</li> <li>子组件无法更新父组件数据？</li></ul></li> <li><p>核心答案</p> <ul><li>data 是函数：组件复用时，函数返回新的对象，避免多个实例共享同一数据（如果是对象，所有实例会修改同一个对象）；</li> <li>修改 props 报错：props 是单向数据流（父传子），子组件不能直接修改；解决方案：子组件通过 $emit 通知父组件修改，或在子组件中定义 data 接收 props 作为初始值；</li> <li>子组件更新父组件数据：通过 $emit 触发父组件方法，由父组件修改数据（单向数据流原则）。</li></ul></li></ul> <h3 id="四、vue3-核心新特性-高频新增考点"><a href="#四、vue3-核心新特性-高频新增考点" class="header-anchor">#</a> 四、Vue3 核心新特性（高频新增考点）</h3> <h4 id="_1-composition-api-核心"><a href="#_1-composition-api-核心" class="header-anchor">#</a> 1. Composition API 核心</h4> <ul><li><p>考察问题</p> <ul><li>setup 函数的作用？执行时机？</li> <li>Reactive vs Ref 的区别？使用场景？</li> <li>Computed &amp; Watch 的用法变化？</li></ul></li> <li><p>核心答案</p> <ul><li>setup：组件的入口，替代选项式 API（data/methods 等）；执行时机在 beforeCreate 之前，this 为 undefined；返回对象 / 函数（渲染函数）。</li> <li>Reactive vs Ref：
<ul><li>Reactive：代理对象，仅支持对象 / 数组，不能代理基本类型；</li> <li>Ref：包装基本类型为 {value: xxx}，对象类型内部会调用 reactive；模板中访问 ref 无需 .value（自动解包），js 中需 .value。</li></ul></li> <li>Computed/Watch：
<ul><li>Computed：支持传入 getter/setter，返回 ref 对象；</li> <li>Watch：支持监听多个源，支持深度监听（deep）、立即执行（immediate），返回停止监听的函数。</li></ul></li></ul></li></ul> <h4 id="_2-vue3-架构变化"><a href="#_2-vue3-架构变化" class="header-anchor">#</a> 2. Vue3 架构变化</h4> <ul><li><p><strong>考察问题</strong>：Vue3 为什么用 TS 重构？架构上的优化？</p></li> <li><p>核心答案</p> <ul><li>TS 重构：提升类型安全，支持更好的 TypeScript 集成，降低维护成本；</li> <li>架构优化：
<ol><li>模块化拆分（如 reactivity 模块可独立使用）；</li> <li>编译优化（PatchFlags 标记动态节点，减少 Diff 范围）；</li> <li>体积优化（Tree-Shaking 支持，按需引入功能）。</li></ol></li></ul></li></ul> <h4 id="_3-teleport-瞬移组件"><a href="#_3-teleport-瞬移组件" class="header-anchor">#</a> 3. Teleport（瞬移组件）</h4> <ul><li><p><strong>考察问题</strong>：Teleport 的作用？使用场景？</p></li> <li><p>核心答案</p> <ul><li>作用：将组件的 DOM 结构渲染到指定的 DOM 节点下（如 body），但组件的逻辑仍属于当前组件；</li></ul></li> <li><p>场景：弹窗 / 模态框（避免父组件样式溢出 / 层级问题）。</p></li></ul> <h4 id="_4-suspense-组件"><a href="#_4-suspense-组件" class="header-anchor">#</a> 4. Suspense 组件</h4> <ul><li><p><strong>考察问题</strong>：Suspense 的作用？如何使用？</p></li> <li><p>核心答案</p> <ul><li>作用：等待异步组件加载完成前显示 fallback 内容（如加载中），提升用户体验；</li></ul></li> <li><p>使用：包裹异步组件，通过 default 插槽放异步组件，fallback 插槽放加载提示。</p></li></ul> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>Vue 高频考点可归纳为：</p> <ol><li><strong>基础概念</strong>：生命周期、指令、双向绑定；</li> <li><strong>核心原理</strong>：响应式、虚拟 DOM/Diff、异步更新、Mixin；</li> <li><strong>实战应用</strong>：组件通信、性能优化、路由、工程化；</li> <li><strong>Vue3 升级</strong>：Composition API、架构优化、新组件（Teleport/Suspense）。</li></ol> <p>备考时需结合「原理理解 + 代码实践」，不仅要记结论，还要理解底层逻辑（如 Diff 算法、响应式劫持），并能结合实际项目场景分析问题（如性能优化、通信方式选型）。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/study-record/4.日常/20251101/框架/源码理解.html" class="prev">
        源码理解
      </a></span> <span class="next"><a href="/study-record/4.日常/20251101/面试相关.html">
        面试相关
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/study-record/assets/js/app.17aac99d.js" defer></script><script src="/study-record/assets/js/2.016b014c.js" defer></script><script src="/study-record/assets/js/1.4d9187d3.js" defer></script><script src="/study-record/assets/js/82.d198b1a8.js" defer></script>
  </body>
</html>
