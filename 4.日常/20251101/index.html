<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>重拾前端 | 前端随笔 WillianLiusHao</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="勤学如春起之苗，不见其增，日有所长">
    
    <link rel="preload" href="/study-record/assets/css/0.styles.ee9d39b9.css" as="style"><link rel="preload" href="/study-record/assets/js/app.17aac99d.js" as="script"><link rel="preload" href="/study-record/assets/js/2.016b014c.js" as="script"><link rel="preload" href="/study-record/assets/js/1.4d9187d3.js" as="script"><link rel="preload" href="/study-record/assets/js/77.06a7f50c.js" as="script"><link rel="prefetch" href="/study-record/assets/js/10.36503388.js"><link rel="prefetch" href="/study-record/assets/js/11.fa712348.js"><link rel="prefetch" href="/study-record/assets/js/12.276efbb7.js"><link rel="prefetch" href="/study-record/assets/js/13.d963e8a7.js"><link rel="prefetch" href="/study-record/assets/js/14.d7577f19.js"><link rel="prefetch" href="/study-record/assets/js/15.cc1f798a.js"><link rel="prefetch" href="/study-record/assets/js/16.0291a868.js"><link rel="prefetch" href="/study-record/assets/js/17.0a30da7e.js"><link rel="prefetch" href="/study-record/assets/js/18.0cfbb48c.js"><link rel="prefetch" href="/study-record/assets/js/19.0e21e7df.js"><link rel="prefetch" href="/study-record/assets/js/20.03daea74.js"><link rel="prefetch" href="/study-record/assets/js/21.3b8bed13.js"><link rel="prefetch" href="/study-record/assets/js/22.044c0ee0.js"><link rel="prefetch" href="/study-record/assets/js/23.2e58d861.js"><link rel="prefetch" href="/study-record/assets/js/24.5d91c0ed.js"><link rel="prefetch" href="/study-record/assets/js/25.ecbc19e1.js"><link rel="prefetch" href="/study-record/assets/js/26.ea32b772.js"><link rel="prefetch" href="/study-record/assets/js/27.7994195c.js"><link rel="prefetch" href="/study-record/assets/js/28.1d2d8781.js"><link rel="prefetch" href="/study-record/assets/js/29.29644b5e.js"><link rel="prefetch" href="/study-record/assets/js/3.babd7043.js"><link rel="prefetch" href="/study-record/assets/js/30.c1b69b54.js"><link rel="prefetch" href="/study-record/assets/js/31.b8531d02.js"><link rel="prefetch" href="/study-record/assets/js/32.1a3d2119.js"><link rel="prefetch" href="/study-record/assets/js/33.4073fb14.js"><link rel="prefetch" href="/study-record/assets/js/34.5873267c.js"><link rel="prefetch" href="/study-record/assets/js/35.22f30e0a.js"><link rel="prefetch" href="/study-record/assets/js/36.9acadcf0.js"><link rel="prefetch" href="/study-record/assets/js/37.514fb866.js"><link rel="prefetch" href="/study-record/assets/js/38.cfd8eaf8.js"><link rel="prefetch" href="/study-record/assets/js/39.b18930b7.js"><link rel="prefetch" href="/study-record/assets/js/4.fa802c58.js"><link rel="prefetch" href="/study-record/assets/js/40.ce709979.js"><link rel="prefetch" href="/study-record/assets/js/41.2042214a.js"><link rel="prefetch" href="/study-record/assets/js/42.87b852a8.js"><link rel="prefetch" href="/study-record/assets/js/43.b4287906.js"><link rel="prefetch" href="/study-record/assets/js/44.6bf10f9a.js"><link rel="prefetch" href="/study-record/assets/js/45.25eeefa0.js"><link rel="prefetch" href="/study-record/assets/js/46.0f8cb01f.js"><link rel="prefetch" href="/study-record/assets/js/47.288a54bb.js"><link rel="prefetch" href="/study-record/assets/js/48.b613c839.js"><link rel="prefetch" href="/study-record/assets/js/49.d18be6a8.js"><link rel="prefetch" href="/study-record/assets/js/5.87700c1c.js"><link rel="prefetch" href="/study-record/assets/js/50.400520f0.js"><link rel="prefetch" href="/study-record/assets/js/51.7eab7fad.js"><link rel="prefetch" href="/study-record/assets/js/52.caaed993.js"><link rel="prefetch" href="/study-record/assets/js/53.55fabd90.js"><link rel="prefetch" href="/study-record/assets/js/54.1a826e47.js"><link rel="prefetch" href="/study-record/assets/js/55.e0c40590.js"><link rel="prefetch" href="/study-record/assets/js/56.42f5fc5f.js"><link rel="prefetch" href="/study-record/assets/js/57.8f30f2af.js"><link rel="prefetch" href="/study-record/assets/js/58.63b92872.js"><link rel="prefetch" href="/study-record/assets/js/59.bd09ccb3.js"><link rel="prefetch" href="/study-record/assets/js/6.9086b17c.js"><link rel="prefetch" href="/study-record/assets/js/60.e7406693.js"><link rel="prefetch" href="/study-record/assets/js/61.f2e5a88e.js"><link rel="prefetch" href="/study-record/assets/js/62.0b65291e.js"><link rel="prefetch" href="/study-record/assets/js/63.8de3fdca.js"><link rel="prefetch" href="/study-record/assets/js/64.4e11deef.js"><link rel="prefetch" href="/study-record/assets/js/65.54d039db.js"><link rel="prefetch" href="/study-record/assets/js/66.84db7a63.js"><link rel="prefetch" href="/study-record/assets/js/67.1c39ed43.js"><link rel="prefetch" href="/study-record/assets/js/68.c06e0761.js"><link rel="prefetch" href="/study-record/assets/js/69.ab2a8f77.js"><link rel="prefetch" href="/study-record/assets/js/7.8ac123f2.js"><link rel="prefetch" href="/study-record/assets/js/70.4ac2a1eb.js"><link rel="prefetch" href="/study-record/assets/js/71.a10a64a1.js"><link rel="prefetch" href="/study-record/assets/js/72.f5ee9344.js"><link rel="prefetch" href="/study-record/assets/js/73.ce032dd2.js"><link rel="prefetch" href="/study-record/assets/js/74.0867294f.js"><link rel="prefetch" href="/study-record/assets/js/75.a2ebcace.js"><link rel="prefetch" href="/study-record/assets/js/76.c3eb5991.js"><link rel="prefetch" href="/study-record/assets/js/78.5fb20fe2.js"><link rel="prefetch" href="/study-record/assets/js/79.f6266092.js"><link rel="prefetch" href="/study-record/assets/js/80.d3237485.js"><link rel="prefetch" href="/study-record/assets/js/81.59c4725f.js"><link rel="prefetch" href="/study-record/assets/js/82.d198b1a8.js"><link rel="prefetch" href="/study-record/assets/js/83.88fb1a26.js"><link rel="prefetch" href="/study-record/assets/js/84.43f20fa1.js"><link rel="prefetch" href="/study-record/assets/js/85.2ea9262b.js"><link rel="prefetch" href="/study-record/assets/js/86.d3f5931d.js"><link rel="prefetch" href="/study-record/assets/js/87.b1833438.js"><link rel="prefetch" href="/study-record/assets/js/88.4359c8a8.js"><link rel="prefetch" href="/study-record/assets/js/89.2c40610e.js"><link rel="prefetch" href="/study-record/assets/js/90.5546c4ab.js"><link rel="prefetch" href="/study-record/assets/js/91.22180d3b.js"><link rel="prefetch" href="/study-record/assets/js/92.15962496.js"><link rel="prefetch" href="/study-record/assets/js/vendors~docsearch.32379f2b.js">
    <link rel="stylesheet" href="/study-record/assets/css/0.styles.ee9d39b9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/study-record/" class="home-link router-link-active"><!----> <span class="site-name">前端随笔 WillianLiusHao</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/WillianLiusHao" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/WillianLiusHao" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>1.基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>2.项目</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>3.算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>4.日常</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>20251101</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/" aria-current="page" class="active sidebar-link">index</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#一、html-css" class="sidebar-link">一、html,css</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#二、js" class="sidebar-link">二、js</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#_1-闭包" class="sidebar-link">1. 闭包</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#_2-var-let-const" class="sidebar-link">2. var,let,const</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#_3-类型转换" class="sidebar-link">3. 类型转换</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#_4-深浅拷贝" class="sidebar-link">4. 深浅拷贝</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#_5-原型链☆" class="sidebar-link">5. 原型链☆</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#_6-this-指向-call-apply-bind" class="sidebar-link">6. this 指向，call，apply，bind</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#_7-localstorage-sessionstorage-cookie" class="sidebar-link">7. localStorage，sessionStorage，Cookie</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#_8-amd、commonjs、es-module" class="sidebar-link">8. AMD、CommonJS、ES Module</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#_9-new-原理" class="sidebar-link">9. new 原理</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#_10-for-in-和-for-of" class="sidebar-link">10. for ... in 和 for ... of</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#_11-事件循环☆☆" class="sidebar-link">11. 事件循环☆☆</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#_12-设计模式" class="sidebar-link">12. 设计模式</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#一些手写题" class="sidebar-link">一些手写题</a></li></ul></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#三、框架" class="sidebar-link">三、框架</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#一、基础" class="sidebar-link">一、基础</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#二、原理相关" class="sidebar-link">二、原理相关</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#三、性能" class="sidebar-link">三、性能</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#vue3响应式原理" class="sidebar-link">Vue3响应式原理</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#编译器实现" class="sidebar-link">编译器实现</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#宏定义原理" class="sidebar-link">宏定义原理</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#运行时" class="sidebar-link">运行时</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#原理-按三部分" class="sidebar-link">原理（按三部分）</a></li></ul></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#四、浏览器、webpack-和-性能优化" class="sidebar-link">四、浏览器、webpack 和 性能优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#_1-内存泄漏" class="sidebar-link">1. 内存泄漏</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#_2-垃圾回收" class="sidebar-link">2. 垃圾回收</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#_3-回流重绘" class="sidebar-link">3. 回流重绘</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#_4-浏览器缓存" class="sidebar-link">4. 浏览器缓存</a></li></ul></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#五、node-和-ts" class="sidebar-link">五、node 和 ts</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#六、http-和-网络" class="sidebar-link">六、http 和 网络</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#_1-http" class="sidebar-link">1. HTTP</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#_2-https" class="sidebar-link">2. HTTPS</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#_3-tcp-udp" class="sidebar-link">3. TCP&amp;UDP</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#_4-dns" class="sidebar-link">4. DNS</a></li></ul></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#七、项目" class="sidebar-link">七、项目</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#场景题" class="sidebar-link">场景题</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#举例" class="sidebar-link">举例</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#_1-微前端" class="sidebar-link">1. 微前端</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#_2-监控sdk" class="sidebar-link">2. 监控sdk</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#_3-低代码" class="sidebar-link">3. 低代码</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#_4-即时通讯" class="sidebar-link">4. 即时通讯</a></li><li class="sidebar-sub-header"><a href="/study-record/4.%E6%97%A5%E5%B8%B8/20251101/#_5-ai" class="sidebar-link">5. AI</a></li></ul></li></ul></li><li><section class="sidebar-group collapsable is-sub-group depth-2"><p class="sidebar-heading"><span>plan</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-2"><p class="sidebar-heading"><span>框架</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/study-record/4.日常/20251101/面试相关.html" class="sidebar-link">面试相关</a></li><li><section class="sidebar-group collapsable is-sub-group depth-2"><p class="sidebar-heading"><span>项目</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><a href="/study-record/4.日常/forCVTE.html" class="sidebar-link">forCVTE</a></li><li><a href="/study-record/4.日常/inter-records.html" class="sidebar-link">inter-records</a></li><li><a href="/study-record/4.日常/notes.html" class="sidebar-link">notes</a></li><li><a href="/study-record/4.日常/plan.html" class="sidebar-link">plan</a></li><li><a href="/study-record/4.日常/ts-question.html" class="sidebar-link">ts-question</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>5.脑图</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/study-record/" aria-current="page" class="sidebar-link">index</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="重拾前端"><a href="#重拾前端" class="header-anchor">#</a> 重拾前端</h1> <p>重点关注的复习资料</p> <ol><li><p>B站视频</p> <ul><li><p><a href="https://www.bilibili.com/video/BV18haoz3EQ8/?spm_id_from=333.788.player.switch&amp;vd_source=78ce2f86d349eed99a5692610cd061b1&amp;p=1" target="_blank" rel="noopener noreferrer">vue 面试题<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p><a href="https://www.bilibili.com/video/BV1tssDzvEoV?spm_id_from=333.788.player.switch&amp;vd_source=78ce2f86d349eed99a5692610cd061b1" target="_blank" rel="noopener noreferrer">系列课<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li></ul></li> <li><p>掘金面经</p> <ul><li><a href="https://juejin.cn/post/7330065707358208010" target="_blank" rel="noopener noreferrer">js高频面试题<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li> <li><p>重点项目的亮点难点和技术点</p></li></ol> <h2 id="一、html-css"><a href="#一、html-css" class="header-anchor">#</a> 一、html,css</h2> <h2 id="二、js"><a href="#二、js" class="header-anchor">#</a> 二、js</h2> <h3 id="_1-闭包"><a href="#_1-闭包" class="header-anchor">#</a> 1. 闭包</h3> <p>什么是闭包？可能导致哪些问题？如何避免内存泄漏？</p> <p>定义：一个函数可以”记住”并访问它被创建时所处的外部作用域，即使它在那个作用域外执行，这种现象就叫闭包</p> <p>功能：<strong>实现变量私有化，⭐函数柯里化⭐ 等</strong></p> <p>案例：<strong>计数器</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">craeteCounter</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 给外部放出一个访问期</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		count<span class="token operator">++</span>
        <span class="token keyword">return</span> count
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> addCount <span class="token operator">=</span> <span class="token function">craeteCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> CountNum1 <span class="token operator">=</span> <span class="token function">addCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>CountNum1<span class="token punctuation">)</span> <span class="token comment">//1</span>
<span class="token keyword">const</span> CountNum2 <span class="token operator">=</span> <span class="token function">addCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>CountNum2<span class="token punctuation">)</span> <span class="token comment">//2</span>

</code></pre></div><p>避免：不需要时手动接触引用（=null），以及及时移除事件监听器</p> <blockquote><p>拓展：函数柯里化</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">curried</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span>length <span class="token operator">&gt;=</span> fn<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment">// 参数够了</span>
      <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                                 <span class="token comment">// 参数不够，继续返回新函数</span>
      <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">curried</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 用法</span>
<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> curriedAdd <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">curriedAdd</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">curriedAdd</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">curriedAdd</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6</span>
</code></pre></div><h3 id="_2-var-let-const"><a href="#_2-var-let-const" class="header-anchor">#</a> 2. var,let,const</h3> <table><thead><tr><th style="text-align:left;">特性</th> <th style="text-align:left;">var</th> <th style="text-align:left;">let</th> <th>const</th></tr></thead> <tbody><tr><td style="text-align:left;"><strong>作用域</strong></td> <td style="text-align:left;">函数作用域</td> <td style="text-align:left;">块级作用域</td> <td>块级作用域</td></tr> <tr><td style="text-align:left;"><strong>变量提升</strong></td> <td style="text-align:left;">声明提升，初始化为 undefined</td> <td style="text-align:left;">声明提升，不初始化</td> <td>声明提升，不初始化</td></tr> <tr><td style="text-align:left;"><strong>暂时性死区</strong></td> <td style="text-align:left;">无</td> <td style="text-align:left;">有</td> <td>有</td></tr> <tr><td style="text-align:left;"><strong>重复声明</strong></td> <td style="text-align:left;">可以</td> <td style="text-align:left;">不可以</td> <td>不可以</td></tr> <tr><td style="text-align:left;"><strong>修改值</strong></td> <td style="text-align:left;">可以</td> <td style="text-align:left;">可以</td> <td>不可以</td></tr> <tr><td style="text-align:left;"><strong>全局对象属性</strong></td> <td style="text-align:left;">顶层作用域会成为window的属性</td> <td style="text-align:left;">不会</td> <td>不会</td></tr></tbody></table> <h3 id="_3-类型转换"><a href="#_3-类型转换" class="header-anchor">#</a> 3. 类型转换</h3> <ol><li><p>隐式转换是调用了 valueOf() 方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">2</span><span class="token operator">-</span><span class="token string">'1'</span>  <span class="token comment">// 1</span>
<span class="token comment">// 其实是 2 - '1'.valueOf()</span>
</code></pre></div></li> <li><p>== 不判断类型，=== 要判断类型</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">!</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">//true</span>

<span class="token comment">// 1. [] == false</span>
<span class="token comment">// 2. [] == 0</span>
<span class="token comment">// 3. '' == 0</span>
</code></pre></div></li></ol> <h3 id="_4-深浅拷贝"><a href="#_4-深浅拷贝" class="header-anchor">#</a> 4. 深浅拷贝</h3> <ol><li>JSON.parse(JSON.stringify)</li></ol> <ul><li>局限性：undefined,Symbol,函数，正则，日期</li></ul> <ol start="2"><li><p>手动实现深拷贝</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">deepClone</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 过滤基础数据类型和 null</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">||</span> obj <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token comment">// 复杂数据类型：特殊处理 RegExp Date Array</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token string">'Date'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token string">'RegExp'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
  <span class="token keyword">let</span> ret <span class="token operator">=</span> obj <span class="token keyword">instanceof</span> <span class="token class-name">Array</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      ret<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">?</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:</span> obj<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ol> <h3 id="_5-原型链☆"><a href="#_5-原型链☆" class="header-anchor">#</a> 5. 原型链☆</h3> <ol><li>引用类型，都具有对象特性，即可自由扩展属性。</li> <li>引用类型，都有一个隐式原型 <code>__proto__</code> 属性，属性值是一个普通的对象。</li> <li>引用类型，隐式原型 <code>__proto__</code> 的属性值指向它的构造函数的显式原型 <code>prototype</code> 属性值。</li> <li>当你试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么它会去它的隐式原型 <code>__proto__</code>（也就是它的构造函数的显式原型 <code>prototype</code>）中寻找。</li></ol> <h3 id="_6-this-指向-call-apply-bind"><a href="#_6-this-指向-call-apply-bind" class="header-anchor">#</a> 6. this 指向，call，apply，bind</h3> <ol><li>普通函数：window 或 global</li> <li>对象方法：调用该方法的对象</li> <li>构造函数：新创建的对象</li> <li>箭头函数：函数定义式所在的词法作用域</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">,</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token comment">// 立即调用，多个参数</span>
        
<span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> <span class="token punctuation">[</span>argsArray<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">// 立即调用，数组参数</span>

<span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>thisARG<span class="token punctuation">,</span> arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span> <span class="token comment">// 返回新函数</span>
</code></pre></div><h3 id="_7-localstorage-sessionstorage-cookie"><a href="#_7-localstorage-sessionstorage-cookie" class="header-anchor">#</a> 7. localStorage，sessionStorage，Cookie</h3> <table><thead><tr><th>特性</th> <th>Cookie</th> <th>localStorage</th> <th>sessionStorage</th></tr></thead> <tbody><tr><td>生命周期</td> <td>可设置过期时间。若不设置，则随浏览器会话结束而关闭（会话性 Cookie）</td> <td>永久性存储。除非用户手动清除或代码主动删除，否则数据永远不会过期</td> <td>会话级存储。数据仅在当前浏览器标签页的会话期间有效，关闭标签页或浏览器后数据被清除</td></tr> <tr><td>存储容量</td> <td>非常小，通常只有～4 KB</td> <td>较大，通常为 5 MB–10 MB（因浏览器而异）</td> <td>与 localStorage 相同，通常为 5 MB–10 MB</td></tr> <tr><td>与服务器通信</td> <td>会自动发送。每次向同源服务器发送 HTTP 请求时，浏览器都会自动将 Cookie 附加在请求头中发送过去</td> <td>纯客户端存储。数据仅存在于本地，不会自动发送到服务器</td> <td>与 localStorage 相同，不会自动发送到服务器</td></tr> <tr><td>作用域</td> <td>同源下所有标签页和窗口共享</td> <td>同源下所有标签页和窗口共享</td> <td>同源下，但仅限当前标签页。在不同标签页中打开同源页面，sessionStorage 互不相通</td></tr> <tr><td>API 易用性</td> <td>原生 API 较为复杂，需要手动封装和解析（document.cookie）</td> <td>API 简洁易用（setItem、getItem、removeItem、clear）</td> <td>与 localStorage 的 API 完全相同</td></tr></tbody></table> <h3 id="_8-amd、commonjs、es-module"><a href="#_8-amd、commonjs、es-module" class="header-anchor">#</a> 8. AMD、CommonJS、ES Module</h3> <table><thead><tr><th>维度</th> <th>CommonJS</th> <th>AMD</th> <th>ES Module</th></tr></thead> <tbody><tr><td>环境</td> <td>Node.js 为主</td> <td>浏览器端</td> <td>浏览器 + Node.js（现代）</td></tr> <tr><td>加载方式</td> <td>同步（运行时）</td> <td>异步（运行时）</td> <td>静态（编译时）+ 动态</td></tr> <tr><td>输出类型</td> <td>值的拷贝</td> <td>值的拷贝</td> <td>值的引用（动态绑定）</td></tr> <tr><td>语法</td> <td><code>require</code>/<code>module.exports</code></td> <td><code>define</code>/<code>require</code></td> <td><code>import</code>/<code>export</code></td></tr> <tr><td>典型工具</td> <td>Node.js 原生</td> <td>RequireJS</td> <td>现代浏览器、Webpack 等</td></tr></tbody></table> <p>目前，ES Module 已成为浏览器和服务器端通用的标准模块规范，CommonJS 仍广泛用于 Node.js 生态，AMD 因历史原因逐渐被淘汰。</p> <h3 id="_9-new-原理"><a href="#_9-new-原理" class="header-anchor">#</a> 9. new 原理</h3> <ol><li>创建空对象</li> <li>对象的 <code>__proto__</code> 指向函数的 prototype</li> <li>执行函数，绑定this</li> <li>判断是否有返回值，有则返回，没有则返回对象</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function">myNew</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> fn <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
    <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> fn<span class="token punctuation">.</span>prototype
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
    <span class="token keyword">return</span> res <span class="token operator">?</span> res <span class="token operator">:</span> obj
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_10-for-in-和-for-of"><a href="#_10-for-in-和-for-of" class="header-anchor">#</a> 10. for ... in 和 for ... of</h3> <table><thead><tr><th>遍历目标</th> <th>需求</th> <th>选哪个？</th></tr></thead> <tbody><tr><td>数组、字符串等可迭代对象</td> <td>取元素值、操作元素</td> <td><code>for...of</code></td></tr> <tr><td>普通对象</td> <td>取属性名、操作键值对</td> <td><code>for...in</code>（加过滤）</td></tr></tbody></table> <p>记住：<code>for...of</code> 关注 “值”，<code>for...in</code> 关注 “键”，按目标和需求选，基本不会错～</p> <h3 id="_11-事件循环☆☆"><a href="#_11-事件循环☆☆" class="header-anchor">#</a> 11. 事件循环☆☆</h3> <h3 id="_12-设计模式"><a href="#_12-设计模式" class="header-anchor">#</a> 12. 设计模式</h3> <p>C5 S7 B11（Creational、Structural、Behavioral）</p> <ol><li><p>创建型模式（5种）：<strong>工厂方法模式</strong>、抽象工厂模式、<strong>单例模式</strong>、建造者模式、<strong>原型模式</strong></p></li> <li><p>结构型模式（7种）：<strong>适配器模式</strong>、<strong>装饰器模式</strong>、<strong>代理模式</strong>、外观模式、桥接模式、组合模式、享元模式。</p></li> <li><p>行为型模式（11种）：策略模式、模板方法模式、<strong>观察者模式/发布订阅模式</strong>、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p></li></ol> <h3 id="一些手写题"><a href="#一些手写题" class="header-anchor">#</a> 一些手写题</h3> <h4 id="_1-实现链式调用"><a href="#_1-实现链式调用" class="header-anchor">#</a> 1. 实现链式调用</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 实现一个类，其实例可以链式调用，它有一个 sleep 方法，可以 sleep 一段时间后再后续调用</span>

<span class="token keyword">const</span> boy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PlayBoy</span><span class="token punctuation">(</span><span class="token string">'Tom'</span><span class="token punctuation">)</span> 
boy<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token string">'王者'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token string">'跳一跳'</span><span class="token punctuation">)</span> 

<span class="token comment">// 大家好我是Tom </span>
<span class="token comment">// 1s 之后 </span>
<span class="token comment">// 我在玩王者 </span>
<span class="token comment">// 2s 之后 </span>
<span class="token comment">// 我在玩跳一跳</span>
</code></pre></div><p>核心思路是：<strong>通过 Promise 链式传递实例，将异步操作（sleep）和同步操作（sayHi、play）统一封装为 Promise 任务</strong>，确保后续调用等待前一个任务（尤其是延迟任务）完成后再执行。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">PlayBoy</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
        <span class="token comment">// 维护一个 Promise 链，初始为已 resolved 状态，确保首次调用可直接执行</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>promiseCahin <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 同步方法：直接执行并返回实例（维持链式调用）</span>
    <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 将同步操作封装到 Promise 链中，确保与异步操作顺序一致</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>promiseCahin <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>promiseCahin<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">大家好，我是</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span> <span class="token comment">// 链式调用关键：返回实例本身</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 异步方法：延迟指定时间后执行后续操作</span>
    <span class="token function">sleep</span> <span class="token punctuation">(</span><span class="token parameter">time</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>promiseCahin <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>promiseCahin<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token comment">// 返回新 Promise，让后续任务等待延迟完成</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">}</span><span class="token punctuation">,</span> time<span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 同步方法：与 sayHi 逻辑一致，执行具体业务并维持链式</span>
    <span class="token function">play</span> <span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>promiseCahin <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>promiseCahin<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">我在玩</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>str<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="三、框架"><a href="#三、框架" class="header-anchor">#</a> 三、框架</h2> <ul><li><p><a href="https://juejin.cn/post/7166446028266733581" target="_blank" rel="noopener noreferrer">「2022」寒冬下我的面试知识点复盘【Vue3、Vue2、Vite】篇<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> ☆☆☆☆☆</p></li> <li><p><a href="https://juejin.cn/post/6919373017218809864" target="_blank" rel="noopener noreferrer">「2021」高频前端面试题汇总之Vue篇 （上）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p><a href="https://www.bilibili.com/video/BV1KnqUY5EwJ?spm_id_from=333.788.videopod.episodes&amp;vd_source=78ce2f86d349eed99a5692610cd061b1" target="_blank" rel="noopener noreferrer">B站视频<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li></ul> <h3 id="一、基础"><a href="#一、基础" class="header-anchor">#</a> 一、基础</h3> <h4 id="_1-computed-和-watch-的理解"><a href="#_1-computed-和-watch-的理解" class="header-anchor">#</a> 1. computed 和 watch 的理解</h4> <ul><li>用法：watch 是基于已有的响应式数据变动时候执行的回调函数，computed 是依赖于已有的数据生成新的响应式数据</li> <li>特点：watch 可执行异步函数，没有缓存；computed 有缓存，主要用于频繁变动的数据</li> <li>原理：watch 相当于被检测数据的 setter 回调函数；computed 相当于新响应式数据的 getter 函数</li></ul> <h4 id="_2-组件通讯"><a href="#_2-组件通讯" class="header-anchor">#</a> 2. 组件通讯</h4> <ul><li>父子：props/$emit、$children/$parent、$refs</li> <li>爷孙：provide/inject、$attrs/$listeners、</li> <li>全局：vuex、eventBus（手写eventBus的实现）</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Bus</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 存放事假名称</span>
  <span class="token punctuation">}</span>

  <span class="token function">$on</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">$emit</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>callbacks<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">cb</span> <span class="token operator">=&gt;</span> <span class="token function">cb</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$bus <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 监听</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$bus<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'say'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 触发</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$bus<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'say'</span><span class="token punctuation">,</span> <span class="token string">'hello'</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="_3-路由实现-hash-和-history-模式"><a href="#_3-路由实现-hash-和-history-模式" class="header-anchor">#</a> 3. 路由实现，hash 和 history 模式</h4> <ul><li><strong>hash 模式</strong>：基于 URL 锚点，依赖 <code>hashchange</code> 事件，无需后端配置，兼容性好但 URL 不美观；</li> <li><strong>history 模式</strong>：基于 HTML5 <code>History API</code>，依赖 <code>popstate</code> 事件，URL 美观，需后端配置避免 404，兼容性稍弱；</li></ul> <h4 id="_4-vue2-如何检测数组变化"><a href="#_4-vue2-如何检测数组变化" class="header-anchor">#</a> 4. vue2 如何检测数组变化</h4> <ul><li><p><strong>核心痛点：<code>Object.defineProperty</code> 对数组的局限性</strong></p> <p><code>Object.defineProperty</code> 只能监听「数组已存在索引的赋值操作」（比如初始化时 <code>arr[0]</code> 会被拦截，但新增索引 <code>arr[1] = 2</code> 无法监听），且完全无法监听「长度修改」和「原生方法调用」。因此，Vue2 必须单独对数组做特殊处理。</p></li> <li><p><strong>实现原理：重写数组的 7 个可变方法，同时保留原方法功能，在方法执行时手动触发依赖更新；并对「索引赋值」「长度修改」提供辅助 API。</strong></p></li> <li><p><strong>局限性：<strong>由于实现机制的限制，以下数组操作</strong>无法被 Vue2 监听</strong>，需要手动规避或使用辅助 API</p> <ol><li><p><strong>直接通过索引修改元素</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 无法监听，不会触发更新</span>
<span class="token comment">// 解决方案：用 this.$set</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><strong>直接修改数组长度</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span>arr<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 无法监听，不会触发更新</span>
<span class="token comment">// 解决方案：用 splice 清空</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><strong>新增超出当前长度的索引</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span>arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// 若原数组长度为 3（索引 0-2），新增索引 3 无法监听</span>
<span class="token comment">// 解决方案：用 this.$set 或 push</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>arr<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ol></li></ul> <h4 id="_5-自定义指令"><a href="#_5-自定义指令" class="header-anchor">#</a> 5. 自定义指令</h4> <ul><li>使用：<code>vue.directive('name', {})</code></li> <li>钩子：<code>created</code> / <code>beforeMount</code> / <code>mounted</code> / <code>beforeUpdate</code> / <code>updated</code> / <code>beforeUnmount</code> / <code>unmounted</code></li></ul> <div class="language-vue extra-class"><pre class="language-vue"><code>// 全局注册指令 v-debounce
app.directive('debounce', {
  // 绑定指令时执行（只执行一次）
  beforeMount(el, binding) {
    let timer = null;
    // 给元素绑定点击事件，添加防抖逻辑
    el.addEventListener('click', () =&gt; {
      clearTimeout(timer);
      timer = setTimeout(() =&gt; {
        // binding.value 是指令传递的参数（如：v-debounce=&quot;handleClick&quot;）
        binding.value(); 
      }, 500); // 500ms 防抖延迟
    });
  }
});
</code></pre></div><h4 id="_6-v-if-和-v-for-的优化级"><a href="#_6-v-if-和-v-for-的优化级" class="header-anchor">#</a> 6. v-if 和 v-for 的优化级</h4> <table><thead><tr><th>Vue 版本</th> <th>优先级规则</th> <th>本质逻辑</th></tr></thead> <tbody><tr><td>Vue 2</td> <td><code>v-for</code> &gt; <code>v-if</code></td> <td>渲染时先执行 <code>v-for</code> 遍历，再对每个遍历项执行 <code>v-if</code> 判断（即使大部分项会被 <code>v-if</code> 过滤，也会先完整遍历）</td></tr> <tr><td>Vue 3</td> <td><code>v-if</code> &gt; <code>v-for</code></td> <td>渲染时先执行 <code>v-if</code> 判断，再执行 <code>v-for</code>（若 <code>v-if</code> 为 <code>false</code>，<code>v-for</code> 不会执行；但注意：<code>v-if</code> 中无法访问 <code>v-for</code> 的遍历变量，因为 <code>v-for</code> 还没执行）</td></tr></tbody></table> <h4 id="_7-生命周期及每个周期的事情"><a href="#_7-生命周期及每个周期的事情" class="header-anchor">#</a> 7. 生命周期及每个周期的事情</h4> <table><thead><tr><th>钩子函数</th> <th>所属阶段</th> <th>执行时机</th> <th>核心操作</th> <th>注意事项</th></tr></thead> <tbody><tr><td><code>beforeCreate</code></td> <td>创建阶段</td> <td>实例刚创建，<code>data</code>/<code>methods</code>/<code>props</code> 未初始化</td> <td>无（无法访问 <code>this</code> 上的响应式数据、方法）</td> <td>几乎不用，仅极少数场景（如初始化非响应式数据）</td></tr> <tr><td><code>created</code></td> <td>创建阶段</td> <td>实例创建完成，<code>data</code>/<code>methods</code>/<code>props</code> 已初始化</td> <td>1. 初始化数据（如处理 <code>props</code> 数据）；2. 发起异步请求（axios）；3. 绑定事件监听</td> <td>无法操作 DOM（组件还没挂载），<code>$el</code> 为 <code>undefined</code></td></tr> <tr><td><code>beforeMount</code></td> <td>挂载阶段</td> <td>挂载开始前，模板编译完成，未渲染到 DOM</td> <td>最后一次修改数据的机会（修改后仍能触发首次渲染）</td> <td><code>$el</code> 仍未挂载到页面，DOM 操作无效</td></tr> <tr><td><code>mounted</code></td> <td>挂载阶段</td> <td>组件挂载完成，DOM 渲染完成</td> <td>1. 操作 DOM（如获取 DOM 元素、初始化第三方插件：echarts/element-ui）；2. 发起异步请求（推荐）</td> <td>页面首次渲染完成，<code>$el</code> 可访问，是最常用的钩子之一</td></tr> <tr><td><code>beforeUpdate</code></td> <td>更新阶段</td> <td>响应式数据变化，重新渲染前</td> <td>监控数据变化，修改数据（不会触发额外更新）</td> <td>不要做异步操作，避免无限更新循环</td></tr> <tr><td><code>updated</code></td> <td>更新阶段</td> <td>组件重新渲染完成，DOM 已更新</td> <td>处理更新后的 DOM（如调整第三方插件尺寸、同步数据到 DOM）</td> <td>避免修改响应式数据（会再次触发更新）</td></tr> <tr><td><code>beforeDestroy</code></td> <td>销毁阶段</td> <td>组件销毁前（实例仍可用）</td> <td>清理资源：1. 清除定时器 / 计时器；2. 取消事件监听（<code>$off</code>）；3. 取消 axios 请求</td> <td>仍可访问 <code>this</code> 和 DOM，是清理资源的关键时机</td></tr> <tr><td><code>destroyed</code></td> <td>销毁阶段</td> <td>组件销毁完成，实例被销毁</td> <td>最终清理（极少用）</td> <td><code>this</code> 仍存在但已无响应式，DOM 已被移除，资源必须在 <code>beforeDestroy</code> 清理</td></tr> <tr><td>（补充）<code>activated</code></td> <td>缓存组件专属</td> <td>被 <code>&lt;keep-alive&gt;</code> 缓存的组件激活时</td> <td>恢复数据、重新发起请求、重启定时器</td> <td>仅配合 <code>&lt;keep-alive&gt;</code> 使用</td></tr> <tr><td>（补充）<code>deactivated</code></td> <td>缓存组件专属</td> <td>被 <code>&lt;keep-alive&gt;</code> 缓存的组件失活时</td> <td>暂停定时器、取消请求</td> <td>仅配合 <code>&lt;keep-alive&gt;</code> 使用</td></tr></tbody></table> <h4 id="_8-hooks-的理解"><a href="#_8-hooks-的理解" class="header-anchor">#</a> 8. Hooks 的理解</h4> <ul><li><p>本质：Hooks 是 “逻辑复用 + 状态管理” 的函数，解决传统选项式 API 逻辑分散、复用困难的问题；</p></li> <li><p>核心价值</p> <ul><li><p>逻辑聚合：相关代码放在一起，可读性提升</p></li> <li><p>逻辑复用：自定义 Hooks 实现通用逻辑抽离，无命名冲突</p></li> <li><p>简洁性：函数式写法替代复杂的 mixin / 高阶组件</p></li></ul></li></ul> <p>简单记：<strong>Hooks = 可复用的逻辑函数 + 状态 / 生命周期封装</strong></p> <h3 id="二、原理相关"><a href="#二、原理相关" class="header-anchor">#</a> 二、原理相关</h3> <ul><li><p><a href="https://juejin.cn/post/7140446835311083534" target="_blank" rel="noopener noreferrer">v-for 到底为啥要加上 key?<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p><a href="https://juejin.cn/post/7147461004954173471" target="_blank" rel="noopener noreferrer">听说你很了解 Vue3 响应式<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li></ul> <h4 id="_1-响应式原理-☆☆☆☆☆"><a href="#_1-响应式原理-☆☆☆☆☆" class="header-anchor">#</a> 1. 响应式原理 ☆☆☆☆☆</h4> <p>​	核心：就是 “数据变了视图自动更新”，不用手动操作 DOM，底层是靠拦截数据读写来实现的</p> <ol><li>数据劫持：拦截数据的读写操作，通过 <code>Object.definedProperty</code> / <code>proxy</code> 拦截数据的 <code>getter</code> 和 <code>setter</code></li> <li>依赖收集：在读取某个数据时，会触发属性的 <code>getter</code>，对使用了该数据的 <code>依赖</code> 进行收集（比如组件渲染函数、watch、computed）</li> <li>触发更新：数据改变时候，会触发数据的 <code>setter</code>，通知所有依赖进行更新</li></ol> <p><a href="/study-record/4.日常/20251101/框架/源码理解.html">简易实现</a></p> <h4 id="_2-nexttick-原理-☆☆"><a href="#_2-nexttick-原理-☆☆" class="header-anchor">#</a> 2. $nextTick 原理 ☆☆</h4> <ul><li><p>使用：在DOM更新后执行延迟回调，在会调中可以获取最新的DOM</p></li> <li><p>原理：Vue 异步更新Dom，vue 的视图更新（watcher执行）其实也是调用了 nextTick</p> <ol><li><p>Vue观察到数据更新，就会创建一个异步任务队列 <code>callbacks</code>，缓冲同一时间循环中发生的所有数据改变</p></li> <li><p>视图的更新 <code>flushSchedulerQueue/flushBatcherQueue</code>（也是一个队列，包含了许多数据更新触发要触发的watcher）会第一个通过 <code>nextTick</code> 入队</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">cb</span><span class="token operator">:</span> <span class="token punctuation">[</span>flushBatcherQueue<span class="token punctuation">]</span>
</code></pre></div></li> <li><p>然后是用户调用 <code>nextTick</code> 时传入的回调函数入队</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">cb</span><span class="token operator">:</span> <span class="token punctuation">[</span>flushBatcherQueue<span class="token punctuation">,</span> nextTick回调<span class="token punctuation">]</span>
</code></pre></div></li> <li><p>同步任务执行完毕，执行异步微任务，就从 cb 取出微任务一个个执行：视图更新 =&gt; nextTick回调</p></li></ol></li></ul> <p><img src="https://willianliushao.github.io/study-record/assets/img/nextTick.63f0c113.png" alt="img"></p> <ul><li>vue2：<code>promise.then</code> &gt; <code>MutationObserver</code> &gt; <code>setImmediate</code> &gt; <code>setTimeOut</code></li> <li>vue3：<code>promise.then</code> &gt; <code>setTimeOut</code></li></ul> <h4 id="_3-虚拟-dom-的理解-diff-算法-☆☆☆☆"><a href="#_3-虚拟-dom-的理解-diff-算法-☆☆☆☆" class="header-anchor">#</a> 3. 虚拟 DOM 的理解？diff 算法 ☆☆☆☆</h4> <ol><li><p><strong>为什么需要虚拟 DOM</strong></p> <ul><li>真实 DOM 操作性能消耗高</li> <li>DOM 操作逻辑繁琐，如：列表删节点，增节点，索引变化</li> <li>缺乏跨平台能力</li></ul></li> <li><p><strong>VDOM 核心结构</strong></p> <div class="language-vue extra-class"><pre class="language-vue"><code>// Vue 中虚拟 DOM 的简化结构（VNode 对象）
const vnode = {
  type: 'div', // 节点类型（标签名/组件/文本等）
  props: { // 节点属性（对应真实 DOM 的 attributes/props）
    id: 'app',
    class: 'container',
    onClick: () =&gt; console.log('click')
  },
  children: [ // 子节点（数组/文本节点）
    { type: 'p', props: {}, children: 'Hello 虚拟 DOM' }
  ],
  el: null, // 关联的真实 DOM 元素（框架内部维护，用户无需操作）
  shapeFlag: 1 // 节点类型标记（框架内部用于优化判断）
}
</code></pre></div></li> <li><p><strong>核心工作流程</strong></p></li></ol> <p>​		<strong>生成 VDOM → 计算差异（Diff）→ 同步更新真实 DOM</strong>，也就是常说的 “Render → Diff → Patch”</p> <ol start="4"><li><p><strong>Diff 算法的核心设计原则</strong></p> <ul><li><p><strong>同层比较</strong>：只对比 VNode 树的同一层级节点，不跨层级对比（跨层级 DOM 操作极少，没必要浪费性能）</p></li> <li><p><strong>标签相同视为同一节点</strong>：如果两个 VNode 的 <code>type</code>（标签 / 组件类型）不同，直接销毁旧节点、创建新节点（不深入对比子节点）</p></li> <li><p><strong>列表节点需加 key</strong>：列表渲染时（如 <code>v-for</code>），通过 <code>key</code> 唯一标识节点，避免误判节点的增删改（比如列表重排时，<code>key</code> 能让框架准确识别 “哪个节点是移动的，而非重新创建”）</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 简化版 Diff 对比逻辑</span>
<span class="token keyword">function</span> <span class="token function">diff</span><span class="token punctuation">(</span><span class="token parameter">oldVNode<span class="token punctuation">,</span> newVNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> patches <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 存储差异补丁</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVNode<span class="token punctuation">.</span>type <span class="token operator">!==</span> newVNode<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1. 节点类型不同：直接替换整个节点</span>
    patches<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'REPLACE'</span><span class="token punctuation">,</span> newVNode <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> newVNode<span class="token punctuation">.</span>children <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 2. 文本节点：对比文本内容，不同则更新</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVNode<span class="token punctuation">.</span>children <span class="token operator">!==</span> newVNode<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      patches<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'TEXT'</span><span class="token punctuation">,</span> <span class="token literal-property property">content</span><span class="token operator">:</span> newVNode<span class="token punctuation">.</span>children <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 3. 元素节点：对比 props 和子节点</span>
    <span class="token comment">// 对比 props 差异（新增/删除/更新属性）</span>
    <span class="token keyword">const</span> propsDiff <span class="token operator">=</span> <span class="token function">compareProps</span><span class="token punctuation">(</span>oldVNode<span class="token punctuation">.</span>props<span class="token punctuation">,</span> newVNode<span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>propsDiff<span class="token punctuation">)</span> patches<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'PROPS'</span><span class="token punctuation">,</span> <span class="token literal-property property">diff</span><span class="token operator">:</span> propsDiff <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 递归对比子节点（同层比较）</span>
    <span class="token keyword">const</span> childrenDiff <span class="token operator">=</span> <span class="token function">diffChildren</span><span class="token punctuation">(</span>oldVNode<span class="token punctuation">.</span>children<span class="token punctuation">,</span> newVNode<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>childrenDiff<span class="token punctuation">)</span> patches<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'CHILDREN'</span><span class="token punctuation">,</span> <span class="token literal-property property">diff</span><span class="token operator">:</span> childrenDiff <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> patches<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li> <li><p><strong>优势和局限性</strong></p> <ul><li><strong>提升性能</strong>：最小化 dom 操作，减少 回流重绘，在视图复杂场景优势明显</li> <li>**简化开发：**用户无需关注视图层，仅需对数据维护</li> <li>**跨平台：**通过不同的渲染器，可支持  <code>app/服务端/浏览器</code> 端</li> <li>**局限：**因为需要创建虚拟DOM，diff 对比都需要消耗时间，在简单UI，少量数据场景下，时间可能不如直接操作 DOM</li></ul></li> <li><p><strong>Vue3 中的优化</strong></p></li></ol> <ul><li><strong>静态提升</strong>：模板中静态节点（如无绑定属性的 <code>&lt;div&gt;</code>）会被缓存，避免每次渲染都重新创建 VNode；</li> <li><strong>PatchFlags（补丁标记）</strong>：编译时标记 VNode 的 “动态部分”（如仅动态文本、仅动态 props），Diff 时只对比标记的动态部分，忽略静态部分；</li> <li><strong>按需 Diff</strong>：组件渲染时只生成 “动态数据相关” 的 VNode，静态部分复用缓存，减少 VNode 创建和 Diff 开销；</li> <li><strong>Fragment（碎片）</strong>：支持多个根节点（无需外层包裹 <code>&lt;div&gt;</code>），减少不必要的 DOM 节点。</li></ul> <blockquote><p>虚拟 DOM 记忆口诀（精炼版）</p> <ol><li>是什么：JS 对象，DOM 镜像</li> <li>为什么：省 DOM 操作、简化开发、跨平台</li> <li>三步流：生新 VDOM → Diff 找差异 → 批量更真实 DOM</li> <li>Diff 三原则：同层比、类型异则换、列表必加 key</li> <li>优与限：提效跨平台，简单场景微开销</li> <li>Vue3 优化：静节点缓存、只比动态区</li></ol></blockquote> <h4 id="_4-key-的作用"><a href="#_4-key-的作用" class="header-anchor">#</a> 4. key 的作用</h4> <h4 id="_5-vue2-和-vue3-区别"><a href="#_5-vue2-和-vue3-区别" class="header-anchor">#</a> 5. vue2 和 vue3 区别</h4> <ol><li>架构/代码优化
<ul><li><code>ts 重写</code></li> <li>monorepo 包管理方式</li> <li><code>体积优化</code> <ul><li><code>移除部分 api</code>（$set，filter，sync，$get等）</li> <li><code>tree-shaking</code>: 使用了 esmodule，tree-shaking 依赖于 es6模块的静态结构特性</li></ul></li></ul></li> <li>性能优化
<ul><li><code>响应式</code>：proxy 和 Reflect 替代 defineProperty</li> <li><code>diff优化</code>：对比流程使用<strong>最长递增子序列</strong></li> <li><code>编译优化</code>（[提高虚拟 DOM 运行时性能](<a href="https://cn.vuejs.org/guide/extras/rendering-mechanism.html#compiler-informed-virtual-dom" target="_blank" rel="noopener noreferrer">渲染机制 | Vue.js<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)）
<ul><li>更新类型标记 <strong>patchFlag</strong></li> <li>函数缓存 <strong>cacheHandlers</strong></li> <li>静态节点提升 <strong>hoistStatic</strong></li> <li>树结构打平 <strong><a href="https://cn.vuejs.org/guide/extras/rendering-mechanism.html#tree-flattening" target="_blank" rel="noopener noreferrer">Block<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></strong></li></ul></li></ul></li> <li>语法API
<ul><li><code>composition API</code></li> <li><code>Teleport</code></li> <li><code>Fragments</code></li></ul></li></ol> <h4 id="_6-proxy的优点"><a href="#_6-proxy的优点" class="header-anchor">#</a> 6. Proxy的优点</h4> <ol><li>数组：不用改写7种方法，不会污染原型链，数组索引相关的变化可以检测</li> <li>对象：不需要提供额外的 <code>$set/$delete</code> API 进行操作</li> <li>性能：无需预遍历对象属性，通过“懒代理”模式，待访问到具体属性再执行代理，提高初始化性能</li> <li>底层优势：<code>defineProperty</code> 只能拦截 <code>get</code>  和  <code>set</code>，而 <code>Proxy</code> 提供了多达13种拦截操作，覆盖几乎所有的基础行为，拓展性强</li></ol> <h4 id="_7-v-model-双向绑定的原理"><a href="#_7-v-model-双向绑定的原理" class="header-anchor">#</a> 7. v-model 双向绑定的原理</h4> <ol><li><p>核心原理：语法糖</p> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>msg<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>msg = $event.target.value<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>checkbox<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:checked</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>isAgree<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@change</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>isAgree = $event.target.checked<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>radio<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:checked</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>val<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@change</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>val = $event.target.val<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div></li></ol> <h4 id="_8-computed-实现原理"><a href="#_8-computed-实现原理" class="header-anchor">#</a> 8. computed 实现原理</h4> <h4 id="_9-keep-alive"><a href="#_9-keep-alive" class="header-anchor">#</a> 9. keep-alive</h4> <h4 id="_10-template-到-render-的过程-模板渲染原理"><a href="#_10-template-到-render-的过程-模板渲染原理" class="header-anchor">#</a> 10. template 到 render 的过程 / 模板渲染原理</h4> <ul><li><p>**核心：**将开发者编写的模板（HTML 类语法）转化为可执行的 JavaScript 代码，最终生成 DOM 并挂载到页面</p></li> <li><p><strong>步骤：</strong></p> <ol><li>模板编译：<code>模板（Template）</code> → <code>编译阶段（Compile）</code> → <code>渲染函数（Render）</code> <ul><li>解析（Parse）：<code>Template</code> → <code>AST（抽象语法树）</code></li> <li>生成（Generate）：<code>AST</code> → <code>渲染函数（Render）</code></li></ul></li> <li>渲染：<code>Render</code> → <code>vnode</code></li> <li>挂载/更新：<code>vnode</code> → <code>patch</code> → <code>真实Dom</code> <ul><li><code>Diff 算法</code></li></ul></li></ol></li> <li><p>vue3的优化</p> <ol><li>编译阶段：vue2仅标记静态节点，vue3 采用 PatchFlags + 静态提升 + 预编译</li> <li>diff 算法：vue2全量对比，vue3只对比带 PatchFlags 的动态节点</li></ol></li></ul> <h3 id="三、性能"><a href="#三、性能" class="header-anchor">#</a> 三、性能</h3> <h4 id="_1-性能优化"><a href="#_1-性能优化" class="header-anchor">#</a> 1. 性能优化</h4> <ol><li>编码阶段</li> <li>打包优化</li> <li>SEO 优化</li> <li>用户体验</li></ol> <h4 id="_2-首屏加载优化"><a href="#_2-首屏加载优化" class="header-anchor">#</a> 2. 首屏加载优化</h4> <p>一、**资源体积优化：**gzip 、cdn、组件库按需加载</p> <p>二、**页面渲染优化：**路由懒加载、骨架屏、SSR、本地缓存或http缓存</p> <h4 id="_3-seo"><a href="#_3-seo" class="header-anchor">#</a> 3. SEO</h4> <ol><li>SSO</li> <li>静态化</li></ol> <h3 id="vue3响应式原理"><a href="#vue3响应式原理" class="header-anchor">#</a> Vue3响应式原理</h3> <h3 id="编译器实现"><a href="#编译器实现" class="header-anchor">#</a> 编译器实现</h3> <h3 id="宏定义原理"><a href="#宏定义原理" class="header-anchor">#</a> 宏定义原理</h3> <h3 id="运行时"><a href="#运行时" class="header-anchor">#</a> 运行时</h3> <h3 id="原理-按三部分"><a href="#原理-按三部分" class="header-anchor">#</a> 原理（按三部分）</h3> <ul><li>Compiler <strong>编译器</strong> (运行 js 文件)
<ul><li>template 模板解析 （h 函数）</li> <li>style 样式解析 (scope)</li> <li>script 脚本解析
<ul><li>宏定义 defineProp、defineEmit</li> <li>vue macro</li></ul></li></ul></li> <li>Reactivity 响应式
<ul><li>Proxy</li> <li>Reflect</li> <li>track、trigger</li></ul></li> <li>Runtime 运行时
<ul><li>指令处理</li> <li>Dom 渲染</li></ul></li></ul> <h2 id="四、浏览器、webpack-和-性能优化"><a href="#四、浏览器、webpack-和-性能优化" class="header-anchor">#</a> 四、浏览器、webpack 和 性能优化</h2> <h3 id="_1-内存泄漏"><a href="#_1-内存泄漏" class="header-anchor">#</a> 1. 内存泄漏</h3> <ul><li>**意外的全局变量：**函数内直接赋值给未声明的变量，导致生成全局变量</li> <li>**未清理的定时器和事件监听：**页面销毁或组件切换时，定时器和监听器未清理</li> <li>**未置空的闭包：**闭包引用了私有变量，不会被垃圾回收，导致内存泄漏</li> <li>**游离Dom：**DOM使用了变量保存，后续DOM删除后，变量未情况，导致泄漏</li></ul> <h3 id="_2-垃圾回收"><a href="#_2-垃圾回收" class="header-anchor">#</a> 2. 垃圾回收</h3> <p><a href="https://juejin.cn/post/6981588276356317214?searchId=20251120152823DDEB18246FF404E1D0AD" target="_blank" rel="noopener noreferrer">「硬核JS」你真的了解垃圾回收机制吗<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>Q：什么是垃圾回收机制？</strong></p> <p><code>GC</code> 即 <code>Garbage Collection</code> ，程序工作过程中会产生很多 <code>垃圾</code>，这些垃圾是程序不用的内存或者是之前用过了，以后不会再用的内存空间，而 <code>GC</code> 就是负责回收垃圾的，因为他工作在引擎内部，所以对于我们前端来说，<code>GC</code> 过程是相对比较无感的，这一套引擎执行而对我们又相对无感的操作也就是常说的 <code>垃圾回收机制</code> 了</p> <p><strong>Q：垃圾是怎样产生的？</strong></p> <p><strong>Q：为什么要进行垃圾回收？</strong></p> <p><strong>Q：垃圾回收是怎样进行的？</strong></p> <ol><li><p>标记清除法（各大浏览器常用）</p> <p>标记整理</p></li> <li><p>引用计数法</p></li></ol> <p><strong>Q：V8 引擎对垃圾回收进行了哪些优化？</strong></p> <ol><li>分代式垃圾回收</li></ol> <h3 id="_3-回流重绘"><a href="#_3-回流重绘" class="header-anchor">#</a> 3. 回流重绘</h3> <ul><li>**概念：**回流和重绘是浏览器渲染页面时的关键步骤</li></ul> <p>回流是当DOM结构或布局信息改变，比如元素尺寸、位置变化，浏览器得重新计算元素布局，这个过程会影响整个页面的布局流，比较消耗性能。</p> <p>重绘呢，是元素样式改变但不影响布局，像颜色、背景变化，浏览器只需重新绘制这些元素，不用调整布局，性能消耗相对小些。</p> <ul><li><p>**特点：**而且回流必然会触发重绘，但重绘不一定引发回流。</p></li> <li><p>**优化：**实际开发里要优化性能，就得减少回流重绘，比如用CSS3动画替代JS操作布局，批量修改DOM时先隐藏元素再操作，避免频繁获取offsetTop这类会强制刷新布局的属性。</p></li></ul> <h3 id="_4-浏览器缓存"><a href="#_4-浏览器缓存" class="header-anchor">#</a> 4. 浏览器缓存</h3> <h2 id="五、node-和-ts"><a href="#五、node-和-ts" class="header-anchor">#</a> 五、node 和 ts</h2> <h2 id="六、http-和-网络"><a href="#六、http-和-网络" class="header-anchor">#</a> 六、http 和 网络</h2> <h3 id="_1-http"><a href="#_1-http" class="header-anchor">#</a> 1. HTTP</h3> <h3 id="_2-https"><a href="#_2-https" class="header-anchor">#</a> 2. HTTPS</h3> <h3 id="_3-tcp-udp"><a href="#_3-tcp-udp" class="header-anchor">#</a> 3. TCP&amp;UDP</h3> <h3 id="_4-dns"><a href="#_4-dns" class="header-anchor">#</a> 4. DNS</h3> <blockquote><p><strong>高频面试题</strong></p></blockquote> <ol><li>HTTP 1.0、1.1、2、3 版本的核心差异是什么？</li> <li>HTTP 状态码的分类及常见场景？</li> <li>HTTP 和 HTTPS 的区别？HTTPS 如何保证安全？</li> <li>TCP 和 UDP 的区别？各自的应用场景？</li> <li>TCP 三次握手和四次挥手的过程？为什么需要三次握手 / 四次挥手？</li></ol> <h2 id="七、项目"><a href="#七、项目" class="header-anchor">#</a> 七、项目</h2> <blockquote><p>使用STAR法则准备</p> <ul><li>遇到什么问题，需求</li> <li>怎么评估解决方案、方案对比</li> <li>方案落地</li> <li>反思、优化</li></ul></blockquote> <h3 id="场景题"><a href="#场景题" class="header-anchor">#</a> 场景题</h3> <blockquote><p>优化自己的面试表现</p> <p>流程化 -- SOP</p></blockquote> <h4 id="怎么应对"><a href="#怎么应对" class="header-anchor">#</a> 怎么应对</h4> <ol><li>交代背景</li> <li>调研方案</li> <li>方案落地</li> <li>反思，追求更优解</li></ol> <h3 id="举例"><a href="#举例" class="header-anchor">#</a> 举例</h3> <p>当被面试官问到：1000W行表格如何渲染？</p> <p>多维格表、飞书表格、钉钉表格，在线表格追求大数据量</p> <ol><li>数据足够大，大数据公司，需要在前端展示大量数据，以往防卡顿，所以我们想要通过更好方案实现</li> <li>我作为负责人，调研这部分方案
<ul><li>DOM方案（卡顿不行）</li> <li>虚拟表格（非最优解）</li> <li>canvas table</li> <li>可视区绘制算法优化</li> <li>canvas 结合 WebAssembly 技术实现（skia + WebAssembly）</li> <li>&quot;WebAssembly&quot;: Unk</li></ul></li> <li>我封装了画布表格引擎，解决了上述问题，并且能够实现1000W数据加载流畅交互</li> <li>在这个过程中遇到哪些问题？我是怎么解决问题的？卡点是什么？</li></ol> <h3 id="_1-微前端"><a href="#_1-微前端" class="header-anchor">#</a> 1. 微前端</h3> <p>https://juejin.cn/user/2295436010068254/posts</p> <h4 id="monorepo"><a href="#monorepo" class="header-anchor">#</a> Monorepo</h4> <ol><li>Monorepo 如何实现增量构建 / 缓存？</li> <li>Monorepo 常用工具及选型</li> <li>Monorepo 中如何处理子项目的版本发布？</li></ol> <h3 id="_2-监控sdk"><a href="#_2-监控sdk" class="header-anchor">#</a> 2. 监控sdk</h3> <p><a href="/study-record/4.日常/20251101/项目/监控.html">监控</a></p> <h4 id="常见问题"><a href="#常见问题" class="header-anchor">#</a> 常见问题：</h4> <ol><li>为什么要自研sdk？
<ul><li>方便接入团队的告警业务</li> <li>方便做各维度的数据联合分析（漏斗图），做行为回溯（热力图，回放）</li> <li>灵活业务拓展，自定义埋点，AB测试</li></ul></li> <li>如果让多平台使用？</li> <li>监控数据采集是否会丢失？</li> <li>如何进行数据上报？会丢失吗？丢失的数据怎么办？</li> <li>上报的时机？</li></ol> <h3 id="_3-低代码"><a href="#_3-低代码" class="header-anchor">#</a> 3. 低代码</h3> <h3 id="_4-即时通讯"><a href="#_4-即时通讯" class="header-anchor">#</a> 4. 即时通讯</h3> <h3 id="_5-ai"><a href="#_5-ai" class="header-anchor">#</a> 5. AI</h3> <ol><li>AI 在你前端工作中的具体应用场景是什么？解决了哪些实际问题？</li> <li>对 MCP（Model Context Protocol）有了解吗？在前端对接 AI 服务时它能起到什么作用？</li> <li>如何通过提示词（Prompt）编写，让 AI 生成的前端代码更贴合业务需求？你有没有总结过相关的提示词技巧？</li> <li>你了解 Agent 模式吗？它在前端场景中能有哪些应用？</li></ol></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/study-record/assets/js/app.17aac99d.js" defer></script><script src="/study-record/assets/js/2.016b014c.js" defer></script><script src="/study-record/assets/js/1.4d9187d3.js" defer></script><script src="/study-record/assets/js/77.06a7f50c.js" defer></script>
  </body>
</html>
