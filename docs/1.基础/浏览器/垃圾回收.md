# V8垃圾回收机制(GC)


> [「硬核JS」你真的了解垃圾回收机制吗](https://juejin.cn/post/6981588276356317214)

## 相关问题

**1. 什么是垃圾回收机制？**

  `垃圾`：程序工作过程中，不用或者用过了，之后不会再用的内存空间
  `垃圾回收`：浏览器内部引擎自动执行，处理垃圾并回收内存空间的过程

  

**2. 为什么要进行垃圾回收？**

**3. 垃圾是怎么产生的？**

**4. 垃圾回收是怎么进行的？** 

- **标记清除算法** (JS引擎最常用)

  - `优`：实现简单
  - `缺`：
    - 内存碎片化：清除后，空间内存变得不连续
    - 分配速度慢：内存不连续，直接导致每次分配新内存时，需要对碎片内存遍历以寻找合适的内存空间

    ![](https://images.vrm.cn/ox/2023/02/06/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png)

  - `优化`
    - 标记整理：在标记结束后，会将所有活着的对象向内存一端移动，再进行清理

    ![](https://images.vrm.cn/ox/2023/02/06/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png)


- **引用计数算法**
      - `缺点`：循环引用导致内存无法释放



**5. V8做了哪些优化？**

- **分代式垃圾回收**

  - `新生代`：
    - Scavenge => Cheney算法
    - 分为`使用区` 和 `空闲区`： 新加入的对象会进入使用区，当使用区快写满时，执行一次垃圾清理
    - **垃圾清理过程**:
      - step1：对使用区(From空间)垃圾进行标记
      - step2：将使用区的活动对象(不用清理的)复制进空闲区(To空间)并排序(整理)
      - step3：清空使用区的所有内存
      - step4：交换使用区和空闲区(交换完后空闲区是空的)

    - 晋升条件：
      - 当复制一个对象进入空闲区的时候，如果该对象已经经历过一次Scavenge回收，会直接移动到老生代空间
      - 当复制一个对象进入空闲区的时候，如果空闲区的占用超过了**25%**，该对象会直接进入老生代

  - `老生代`：
    - 使用标记清除法（V8则使用标记整理法进行优化）

    ![](https://images.vrm.cn/ox/2023/02/06/%E5%88%86%E4%BB%A3%E5%BC%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png)
​
  - `分代的优点`：
    - 分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，可以说此机制的出现很大程度`提高了垃圾回收机制的效率`


- **并行回收**（对新生代的优化）


- **增量标记与惰性清理**（对老生代的优化）

  - 优化空间：分代回收提高了回收效率，但还是一种`全停顿`(执行垃圾回收的时候，会阻塞js主线程)的方式
  - 概念：将一次`GC`标记过程，分成多个小步，每执行完一小步就让应用逻辑执行一会儿，交替多次
  - 关键：怎么暂停垃圾回收？ 怎么继续回收？

  ![](https://images.vrm.cn/ox/2023/02/06/%E5%A2%9E%E9%87%8F%E6%A0%87%E8%AE%B0.png)

  - **三色标记法(暂停与恢复)**

    - 利用灰色标记下一次要开始执行标记的位置，从而实现了暂停与恢复

  - **写屏障**

    - 解决了在js脚本执行过程中新加入的对象无法被标记的问题

