# 一个月前端面试复习计划（目标20-25k，不复习算法）

本复习计划旨在为拥有微前端、性能监控、WebSocket及低代码项目经验的前端开发者，量身定制一套为期一个月的面试准备方案。计划聚焦于20-25k薪资水平所需的技术深度与广度，完全排除算法题的复习，以项目经验为核心，系统性地梳理和巩固相关技术栈。每日学习强度适中，旨在实现高效、深度的知识回顾与能力提升。

## 1. 第一周：微前端架构深度复习

本周的核心目标是深度复盘和巩固微前端相关的技术知识与实践。微前端作为现代前端架构的重要组成部分，尤其受到中大型企业项目的青睐，是面试中考察候选人架构能力和工程化思维的关键点。复习内容将围绕微前端的核心概念、主流框架（如qiankun）的实战应用、应用间通信与路由管理，以及如何将过往项目经验转化为面试中的亮点展开。通过本周的系统学习，应能清晰阐述微前端的原理、解决过的复杂问题，并对相关面试问题有充分的准备。

### 1.1 微前端核心概念与原理

在深入技术细节之前，必须对微前端的核心概念、设计哲学及其解决的问题有深刻的理解。这不仅是技术实现的基础，也是在面试中展现技术视野和架构思维的关键。本节将系统梳理微前端的定义、核心价值、适用场景，并探讨其与传统的模块化、组件化开发模式的本质区别。

#### 1.1.1 微前端定义、优势及适用场景

微前端（Micro-Frontends）是一种前端架构风格，其核心理念借鉴了微服务的思想，旨在将庞大、复杂的单体前端应用（Single-Page Application, SPA）拆解为一组更小、更独立、更易于管理的子应用 。这些子应用可以由不同的团队独立开发、独立部署，并使用不同的技术栈（如React, Vue, Angular等），最终在用户端被整合成一个统一、内聚的产品 。这种架构模式的出现，主要是为了应对日益复杂的前端应用和跨团队协作带来的挑战。随着Web应用功能的不断膨胀，单体应用的代码库会变得异常庞大，导致编译速度慢、开发效率低、部署风险高等问题。同时，在大型组织中，多个团队共同开发一个应用时，技术栈统一、代码冲突、沟通协调等问题也日益突出。

微前端架构带来了诸多显著优势。首先是**技术栈无关性**，每个子应用都可以根据自身需求选择最合适的技术栈，避免了整个项目被锁定在单一技术上，为技术升级和演进提供了灵活性 。其次是**独立开发与部署**，各个团队可以并行开发自己的子应用，互不影响，并且可以独立地进行构建、测试和部署，大大缩短了交付周期，降低了发布风险。再者是**应用自治**，每个子应用都是一个完整的、可独立运行的实体，拥有自己的路由、状态管理和业务逻辑，实现了关注点分离，提高了代码的可维护性和可复用性 。此外，微前端还能实现**增量升级**，可以逐步将旧系统的功能模块迁移到新的技术栈上，而无需进行颠覆性的重写，降低了技术迁移的成本和风险。

微前端架构特别适用于以下场景：
1.  **大型、复杂的企业级应用**：当应用功能模块众多，业务逻辑复杂，且由多个团队协作开发时，微前端能够有效解耦，提升开发效率。
2.  **需要整合多个独立应用的平台**：例如企业内部的统一工作台，需要将来自不同部门、不同团队开发的多个应用（如OA系统、CRM系统、报表系统）整合到一个统一的门户中。
3.  **需要独立部署和快速迭代的场景**：当业务需求变化频繁，需要快速响应市场变化时，微前端的独立部署能力可以显著缩短上线周期。
4.  **技术栈多样化的项目**：当团队中存在多种技术栈（如既有React项目，又有Vue项目）需要共存并整合时，微前端提供了一个理想的解决方案。
5.  **遗留系统迁移**：对于需要逐步替换老旧技术栈的项目，可以采用“绞杀者模式”，通过微前端架构，用新开发的子应用逐步替换旧系统的功能，实现平滑过渡。

#### 1.1.2 微前端架构如何解决单体应用痛点

微前端架构通过其独特的设计思想，针对性地解决了单体前端应用在规模扩大后所面临的诸多痛点。这些痛点主要包括**代码库膨胀与维护困难**、**团队协作效率低下**、**技术栈僵化**以及**部署风险高**等。微前端通过将单体应用“化整为零”，从根本上改变了应用的开发和交付模式。

首先，针对**代码库膨胀与维护困难**的问题，微前端将庞大的应用拆分成多个职责单一、边界清晰的子应用。每个子应用的代码量相对较小，逻辑更加内聚，这使得代码更易于理解、维护和测试。开发者只需关注自己负责的子应用，无需在庞大的代码库中迷失方向，从而显著提升了开发效率和代码质量。这种“单一职责”的原则  使得每个模块的功能更加专注，降低了系统的复杂度。

其次，对于**团队协作效率低下**的挑战，微前端提供了有效的解决方案。在单体应用中，多个团队共同开发同一个代码库，极易产生代码冲突、合并困难、沟通成本高等问题。微前端架构允许不同的团队独立负责一个或多个子应用，团队之间通过定义好的接口或事件机制进行通信，实现了物理和逻辑上的隔离。这种“应用自治”  的模式，使得团队可以独立进行技术选型、开发、测试和部署，极大地减少了团队间的耦合和依赖，提升了并行开发的效率。

再者，关于**技术栈僵化**的问题，微前端架构的**技术栈无关**特性提供了极大的灵活性。在单体应用中，一旦选定技术栈，后续很难进行更改或引入新技术，整个项目会被技术债务所累。而在微前端架构下，每个子应用都可以根据自身的业务需求和团队技术背景，选择最合适的技术栈。例如，一个子应用可以使用React，另一个可以使用Vue，甚至可以集成使用Angular开发的遗留模块。这种灵活性不仅避免了技术锁定，也为团队尝试新技术、进行技术演进提供了可能。

最后，针对**部署风险高**的痛点，微前端的独立部署能力带来了革命性的改变。在单体应用中，任何微小的改动都需要重新构建和部署整个应用，这可能导致“牵一发而动全身”的风险，一次小的发布就可能引发全局性的故障。微前端架构下，每个子应用都可以独立地进行构建、测试和部署。当某个子应用需要更新时，只需部署该子应用即可，其他子应用不受影响。这种“独立交付”的模式  大大降低了部署的风险，实现了更频繁、更可靠的持续交付。

#### 1.1.3 微前端与模块化、组件化的区别

微前端、模块化和组件化都是前端工程化中用于解决代码复用、组织和管理问题的重要思想，但它们在抽象层次、应用范围和实现目标上存在本质的区别。理解这些区别，有助于在面试中更精准地阐述微前端的价值和定位。

**组件化（Componentization）** 是最细粒度的代码组织方式。它关注的是将一个页面或一个功能模块拆分成一个个独立、可复用的UI单元（即组件）。每个组件封装了自己的HTML结构、CSS样式和JavaScript逻辑。组件化的核心思想是“高内聚、低耦合”，通过组合不同的组件来构建复杂的用户界面。例如，一个按钮、一个输入框、一个弹窗都可以被视为一个组件。组件化的主要目标是**提升UI的复用性和开发效率**，它通常运行在同一个应用内部，由同一个框架（如React、Vue）管理。

**模块化（Modularization）** 的抽象层次高于组件化，它关注的是将应用的业务逻辑、工具函数、配置等按照功能或职责划分为独立的模块。每个模块都是一个独立的文件或文件集合，通过`import`/`export`等机制进行依赖管理和功能暴露。模块化的主要目标是**解决JavaScript代码的命名冲突、依赖混乱和代码组织问题**，提升代码的可维护性和可复用性。例如，可以将所有与用户相关的API请求封装在`user.js`模块中，将所有格式化工具函数封装在`utils.js`模块中。模块化是构建大型JavaScript应用的基础，但它仍然是在一个统一的构建系统和运行时环境中。

**微前端（Micro-Frontends）** 则是最高层次的架构抽象。它借鉴了微服务的思想，将整个前端应用拆分为多个独立的、可独立开发、独立部署的子应用 。每个子应用本身就是一个完整的、可以独立运行的前端应用，拥有自己的技术栈、路由、状态管理和构建流程。微前端的核心目标是**解决大型应用的组织架构、团队协作、技术栈演进和独立交付等问题**。它不仅仅是代码层面的拆分，更是组织架构和交付流程的重塑。微前端架构需要一个“基座”（Base）或“容器”来负责加载、管理和协调这些子应用。

总结来说，三者的区别可以从以下几个维度进行对比：

| 维度         | 组件化                   | 模块化                     | 微前端                             |
| :----------- | :----------------------- | :------------------------- | :--------------------------------- |
| **抽象层次** | UI层面                   | 代码逻辑层面               | 应用架构层面                       |
| **拆分粒度** | 最小，通常是UI单元       | 中等，通常是功能或业务单元 | 最大，通常是完整的应用             |
| **核心目标** | 提升UI复用性和开发效率   | 解决代码组织、依赖管理问题 | 解决大型应用的组织、协作、交付问题 |
| **技术栈**   | 通常统一                 | 统一                       | 可以多样化                         |
| **运行时**   | 在同一个应用和框架内     | 在同一个应用和构建系统内   | 每个子应用独立运行，由基座整合     |
| **部署方式** | 作为整体应用的一部分部署 | 作为整体应用的一部分部署   | 每个子应用可以独立部署             |

用一个比喻来理解：构建一个电商网站，**组件化**就像是制作好一个个标准的乐高积木块（按钮、商品卡片、购物车图标）；**模块化**则是将这些积木块和相关的说明书（业务逻辑）打包成一个“搭建城堡”的套装；而**微前端**则是将整个网站拆分成“首页”、“商品详情页”、“购物车页”、“用户中心”等多个独立的、可以由不同团队开发的完整页面，最后通过一个导航系统（基座）将它们组合成一个完整的网站。

### 1.2 主流微前端框架实战（以qiankun为例）

在理解了微前端的理论概念后，掌握一个主流的微前端框架是将其应用于实践的关键。qiankun（乾坤）是目前国内最流行、应用最广泛的微前端解决方案之一，由蚂蚁金服开源。它基于single-spa进行了封装和增强，提供了更完善的功能和更友好的开发体验。本节将以qiankun为例，深入探讨其安装配置、主应用与子应用的交互机制，以及其核心的沙箱隔离技术。

#### 1.2.1 qiankun框架的安装、配置与基本使用

qiankun框架的设计哲学是“简单、强大、可靠”，旨在让开发者能够快速地将多个前端应用整合成一个微前端应用。其基本使用流程可以分为三个步骤：主应用的搭建、子应用的改造以及应用的注册与启动。

**1. 主应用的搭建与配置**

主应用（也称基座应用）是整个微前端架构的控制中心，负责管理所有子应用的生命周期、路由分发和通信。主应用通常是一个普通的前端应用，如基于React或Vue的项目。首先，需要在主应用中安装qiankun。

```bash
npm install qiankun # 或者 yarn add qiankun
```

安装完成后，在主应用的入口文件（如`src/main.js`或`src/index.js`）中，引入qiankun的`registerMicroApps`和`start`方法。

```javascript
import { registerMicroApps, start } from 'qiankun';

// 注册子应用
registerMicroApps([
  {
    name: 'reactApp', // 子应用名称，必须唯一
    entry: '//localhost:7100', // 子应用的入口地址
    container: '#subapp-container', // 子应用挂载的DOM节点
    activeRule: '/react', // 激活子应用的路由规则
  },
  {
    name: 'vueApp',
    entry: '//localhost:7200',
    container: '#subapp-container',
    activeRule: '/vue',
  },
]);

// 启动qiankun
start();
```

在上述代码中，`registerMicroApps`方法接收一个数组，数组的每个元素都是一个子应用的配置对象。关键配置项包括：
-   `name`: 子应用的名称，用于标识和区分不同的子应用。
-   `entry`: 子应用的入口资源地址，可以是HTML的URL，也可以是JS的URL。qiankun会自动加载该地址的资源。
-   `container`: 子应用渲染时挂载的DOM容器选择器，主应用需要提供一个对应的DOM节点。
-   `activeRule`: 路由匹配规则，当主应用的路由匹配到该规则时，会激活并加载对应的子应用。

**2. 子应用的改造**

为了让一个普通的前端应用能够作为子应用被qiankun加载，需要进行一些必要的改造。这些改造主要是为了让子应用能够正确地导出其生命周期钩子，并处理在微前端环境下的资源加载和路由问题。

首先，子应用需要在自己的入口文件（如`src/main.js`）中导出三个生命周期函数：`bootstrap`、`mount`和`unmount`。

```javascript
// src/main.js (以React为例)
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';

function render(props) {
  const { container } = props;
  ReactDOM.render(
    <App />,
    container ? container.querySelector('#root') : document.querySelector('#root')
  );
}

// 独立运行时，直接渲染
if (!window.__POWERED_BY_QIANKUN__) {
  render({});
}

// 导出生命周期函数
export async function bootstrap() {
  console.log('[react16] react app bootstraped');
}

export async function mount(props) {
  console.log('[react16] props from main framework', props);
  render(props);
}

export async function unmount(props) {
  const { container } = props;
  ReactDOM.unmountComponentAtNode(
    container ? container.querySelector('#root') : document.querySelector('#root')
  );
}
```

-   `bootstrap`: 应用在首次挂载前会调用，可以在这里做一些初始化操作。
-   `mount`: 应用每次挂载时调用，通常在这里执行渲染逻辑。
-   `unmount`: 应用每次卸载时调用，需要在这里清理副作用，如卸载DOM、取消事件监听等。

其次，需要配置子应用的路由。为了避免子应用的路由与主应用或其他子应用冲突，通常需要为子应用设置一个基础路径（basename）。

```javascript
// src/router/index.js (以React Router为例)
import { BrowserRouter } from 'react-router-dom';

<BrowserRouter basename={window.__POWERED_BY_QIANKUN__ ? '/react' : '/'}>
  {/* ... */}
</BrowserRouter>
```

最后，还需要配置子应用的打包工具（如Webpack），使其能够打包出符合qiankun规范的资源。主要是设置`output`配置项，确保资源路径正确，并允许跨域访问。

```javascript
// webpack.config.js
module.exports = {
  // ...
  output: {
    library: `${packageName}-[name]`, // 包名
    libraryTarget: 'umd', // 打包成umd格式
    jsonpFunction: `webpackJsonp_${packageName}`, // 避免与主应用冲突
  },
  devServer: {
    port: 7100, // 子应用端口
    headers: {
      'Access-Control-Allow-Origin': '*', // 允许跨域
    },
  },
};
```

通过以上步骤，一个普通的前端应用就被改造成了可以被qiankun加载的子应用。

#### 1.2.2 主应用与子应用的注册、加载与生命周期

在qiankun中，主应用与子应用之间的关系是核心。主应用扮演着“ orchestrator”（协调者）的角色，负责子应用的注册、加载、挂载、卸载等整个生命周期的管理。这个过程是动态的，基于路由的变化来驱动。

**1. 应用的注册**

如1.2.1节所述，主应用通过`registerMicroApps`方法完成子应用的注册。这个过程本质上是向qiankun的注册表中添加子应用的元数据信息，包括名称、入口、挂载点和激活规则。qiankun内部会维护一个应用注册表，用于后续的路由匹配和应用加载。

```javascript
import { registerMicroApps } from 'qiankun';

registerMicroApps([
  {
    name: 'app1',
    entry: 'http://localhost:8080',
    container: '#subapp-viewport',
    activeRule: '/app1',
    // 可以传递props给子应用
    props: {
      data: 'some data from main app',
      onGlobalStateChange: (state, prev) => { /* ... */ }
    }
  },
  // ... other apps
]);
```

在注册时，主应用还可以通过`props`属性向子应用传递数据或回调函数，这是主应用与子应用进行通信的重要方式之一。

**2. 应用的加载**

当用户在主应用中进行路由跳转，URL发生变化时，qiankun会监听路由变化（通过劫持`history.pushState`和`history.replaceState`等方法）。一旦URL匹配到某个子应用的`activeRule`，qiankun就会启动该子应用的加载流程。

加载过程大致如下：
1.  **匹配应用**：根据当前URL和`activeRule`，从注册表中找到需要激活的子应用。
2.  **加载资源**：根据子应用的`entry`配置，通过`fetch`或`script`标签等方式，加载子应用的HTML入口文件。
3.  **解析资源**：解析HTML文件，提取出其中的JavaScript和CSS资源链接。
4.  **执行JS，获取生命周期钩子**：创建一个沙箱环境，在沙箱中执行子应用的JavaScript代码，并获取其导出的`bootstrap`、`mount`、`unmount`等生命周期函数。

这个加载过程是异步的，qiankun会处理好资源的并行加载和依赖关系，确保子应用的代码能够正确执行。

**3. 应用的生命周期管理**

一旦子应用的资源加载完成并获取到其生命周期钩子，qiankun就会根据应用的状态调用相应的生命周期函数。

-   **挂载（Mount）** ：当子应用首次被激活或从其他应用切换回来时，qiankun会调用其`mount`函数。在`mount`函数中，子应用会执行其渲染逻辑，将DOM挂载到主应用指定的`container`中。此时，子应用对用户可见并可交互。
-   **卸载（Unmount）** ：当用户从当前子应用路由切换到其他子应用或主应用的路由时，当前子应用会被卸载。qiankun会调用其`unmount`函数。在`unmount`函数中，子应用需要负责清理其创建的所有副作用，例如卸载DOM、移除全局事件监听器、取消未完成的网络请求等，以避免内存泄漏和状态污染。
-   **初始化（Bootstrap）** ：`bootstrap`函数在应用首次挂载前被调用一次，通常用于执行一些一次性的初始化操作，例如创建全局状态管理实例、初始化第三方库等。

这个生命周期管理机制是qiankun实现子应用隔离和动态加载的核心。通过标准化的生命周期钩子，qiankun能够精确地控制每个子应用的运行状态，确保它们在微前端环境中能够稳定、可靠地协同工作。

#### 1.2.3 qiankun的沙箱机制（JS沙箱与样式隔离）

沙箱（Sandbox）机制是微前端架构中的核心技术之一，其目的是实现子应用之间的完全隔离，防止它们之间的全局变量、样式、事件等相互污染。qiankun提供了强大的沙箱机制，主要包括JavaScript沙箱和样式隔离两部分。

**1. JavaScript沙箱**

JavaScript沙箱的目标是隔离子应用运行时的全局变量和全局API，防止一个子应用的代码修改了全局状态，从而影响到其他子应用或主应用。qiankun主要提供了两种JS沙箱实现：`SnapshotSandbox`（快照沙箱）和`ProxySandbox`（代理沙箱）。

-   **SnapshotSandbox（快照沙箱）** ：这是qiankun较早版本的默认沙箱实现。其工作原理是在子应用挂载前，对当前的全局对象（`window`）进行一次快照，记录下所有属性的状态。在子应用运行期间，允许其自由地修改全局对象。当子应用卸载时，会再次对全局对象进行快照，并与挂载前的快照进行对比，找出所有被修改的属性，然后将这些属性恢复到初始状态。这种方式的优点是实现简单，兼容性好。缺点是性能开销较大，因为需要遍历和对比大量的属性，并且无法支持多个子应用同时运行（因为只有一个全局`window`对象）。

-   **ProxySandbox（代理沙箱）** ：这是qiankun在新版本中引入的更先进的沙箱实现，也是目前推荐的方案。它利用ES6的`Proxy`对象来创建一个`window`对象的代理。当子应用访问或修改全局变量时，实际上操作的是这个代理对象。qiankun会为每个子应用创建一个独立的代理对象，并将其作为子应用的全局对象。这样，每个子应用都拥有自己独立的“沙箱环境”，它们对全局变量的修改都被限制在自己的代理对象中，不会影响到真正的全局`window`对象，也不会影响到其他子应用。这种方式的优点是性能更好，隔离性更强，可以支持多个子应用同时运行。缺点是需要浏览器支持`Proxy`，对于旧版浏览器存在兼容性问题。

**2. 样式隔离**

样式隔离的目标是防止不同子应用的CSS样式相互覆盖和污染。qiankun提供了两种主要的样式隔离方案：

-   **严格样式隔离（StrictStyleIsolation）** ：这种方案会为每个子应用的容器DOM节点添加一个特殊的属性，例如`data-qiankun="reactApp"`。然后，qiankun会遍历子应用加载的所有CSS规则，并使用PostCSS等工具，自动为每条CSS选择器添加一个属性选择器前缀，例如`.my-button`会被重写为`[data-qiankun="reactApp"] .my-button`。这样，子应用的所有样式都被限制在了其挂载容器内部，无法影响到外部的DOM元素，从而实现了严格的样式隔离。这种方式的优点是隔离效果非常好。缺点是性能开销较大，需要对CSS进行解析和重写，并且可能会与一些动态插入样式的第三方库产生兼容性问题。

-   **实验性样式隔离（ExperimentalStyleIsolation）** ：这种方案也被称为“动态样式表”（Dynamic Stylesheet）。其原理是，当子应用被激活时，将其所有的`<style>`和`<link>`标签插入到DOM中；当子应用被卸载时，再将这些标签从DOM中移除。通过动态地添加和移除样式表，可以确保在任何时候，只有当前激活的子应用的样式是生效的。这种方式的优点是实现简单，性能较好。缺点是如果多个子应用同时显示在页面上（例如，一个子应用在另一个子应用的弹窗中），样式仍然会产生冲突。

在实际项目中，可以根据具体需求选择合适的沙箱和样式隔离方案。例如，对于需要高度隔离的场景，可以选择`ProxySandbox`和严格样式隔离；对于性能要求较高且子应用不会同时显示的场景，可以选择`SnapshotSandbox`和动态样式表。qiankun的灵活配置使得开发者可以根据实际情况进行权衡和选择。

### 1.3 微前端通信与路由管理

在微前端架构中，虽然各个子应用是独立开发和部署的，但它们最终需要协同工作，共同构成一个完整的用户流程。因此，应用间的通信和路由管理是实现这种协同的关键。qiankun提供了多种通信机制，并需要开发者对路由进行精心设计，以确保微前端应用的顺畅运行。

#### 1.3.1 微前端应用间的通信方式（props、eventBus、全局状态管理）

微前端应用间的通信是面试中经常被问到的重点问题，因为它直接关系到架构设计的合理性。qiankun提供了几种不同层次的通信方式，以适应不同的场景。

**1. 基于props的通信**

这是最简单、最直接的通信方式。在主应用注册子应用时，可以通过`props`配置项向子应用传递数据。这些数据可以是静态的，也可以是动态的（例如，一个函数或一个包含响应式数据的对象）。

```javascript
// 主应用
registerMicroApps([
  {
    name: 'sub-app',
    entry: '//localhost:8080',
    container: '#subapp',
    activeRule: '/sub-app',
    props: {
      userInfo: { name: 'Alice', id: 123 },
      onLogin: (user) => { /* 主应用处理登录事件 */ }
    }
  }
]);

// 子应用
export async function mount(props) {
  console.log('从主应用接收到的数据:', props.userInfo);
  props.onLogin({ name: 'Bob' }); // 调用主应用传递的方法
  render(props);
}
```

这种方式的优点是简单明了，数据流向清晰（父传子）。缺点是只能实现主应用向子应用的单向数据流，不适合复杂的跨子应用通信。

**2. 基于全局状态管理的通信**

对于更复杂的场景，例如跨子应用的数据共享或状态同步，可以使用全局状态管理方案。qiankun官方提供了一个名为`@qiankunjs/shared`的库，或者开发者可以自行实现一个全局状态管理器。

一个常见的模式是，在主应用中创建一个全局的`EventEmitter`或`Observable`实例，并将其通过`props`传递给所有子应用。子应用可以订阅这个全局状态的变化，也可以发布状态更新。

```javascript
// 主应用 - 创建一个全局事件总线
import { EventEmitter } from 'events';
const globalEventBus = new EventEmitter();

registerMicroApps([
  {
    name: 'app1',
    // ...
    props: { globalEventBus }
  },
  {
    name: 'app2',
    // ...
    props: { globalEventBus }
  }
]);

// 子应用1 - 发布事件
props.globalEventBus.emit('user-changed', { id: 456 });

// 子应用2 - 订阅事件
props.globalEventBus.on('user-changed', (user) => {
  console.log('用户数据更新了:', user);
});
```

这种方式可以实现任意方向（主-子，子-主，子-子）的通信，灵活性高。缺点是如果管理不当，容易导致事件流混乱，难以调试，类似于“事件地狱”。

**3. 基于发布-订阅模式的官方通信方案**

qiankun官方推荐了一种基于`initGlobalState`和`onGlobalStateChange`/`setGlobalState`的通信方案。主应用通过`initGlobalState`初始化一个全局状态，子应用通过`onGlobalStateChange`监听状态变化，通过`setGlobalState`修改全局状态。

```javascript
// 主应用
import { initGlobalState, MicroAppStateActions } from 'qiankun';

const actions = initGlobalState({ user: null });

actions.onGlobalStateChange((state, prev) => {
  console.log('主应用检测到状态变化:', state, prev);
});

// 子应用
export function mount(props) {
  props.onGlobalStateChange((state, prev) => {
    console.log('子应用检测到状态变化:', state, prev);
  }, true); // 第二个参数为true，表示立即触发一次回调

  props.setGlobalState({ user: { name: 'Charlie' } });
}
```

这种方案的优点是结构清晰，由qiankun统一管理，避免了自行实现全局状态管理的复杂性。它同样支持双向通信，并且是官方推荐的做法。

在实际项目中，通常会组合使用这些通信方式。对于简单的父子通信，使用`props`；对于需要跨应用共享的全局状态（如用户信息、权限等），使用官方的全局状态管理方案或自定义的`EventBus`。

#### 1.3.2 微前端的路由同步与冲突解决策略

路由是微前端架构中的一个核心难点。由于多个子应用都有自己的路由系统，如何将这些路由系统整合在一起，并与主应用的路由协同工作，同时避免冲突，是一个需要精心设计的问题。

**1. 路由同步策略**

qiankun采用了一种基于`basename`的路由同步策略。其核心思想是，主应用和每个子应用都有自己的路由基础路径（basename），通过组合这些路径来形成最终的、唯一的URL。

-   **主应用路由**：主应用的路由通常定义了各个子应用的入口。例如，主应用的路由`/react`对应React子应用，`/vue`对应Vue子应用。
-   **子应用路由**：每个子应用也需要配置自己的`basename`，这个`basename`通常是主应用为其分配的路径前缀。

例如，一个典型的路由配置如下：
-   主应用URL: `http://garfish.bytedance.com/example`
-   主应用路由: `/appA` -> 激活子应用A
-   子应用A的`basename`: `/example/appA`
-   子应用A内部路由: `/detail`

当用户访问`http://garfish.bytedance.com/example/appA/detail`时，路由的解析过程如下：
1.  主应用的路由系统首先匹配到`/example/appA`，激活子应用A。
2.  子应用A被加载后，其内部的路由系统会以`/example/appA`作为基础路径，然后匹配剩余的路径`/detail`，从而渲染出对应的页面。

这种策略确保了每个子应用的路由都是在其自己的命名空间下进行的，避免了路由冲突，并且生成的URL符合用户的认知习惯 。

**2. 路由冲突解决与异常处理**

尽管`basename`策略能解决大部分路由冲突，但在一些复杂的场景下，仍然可能出现问题。

-   **Hash模式与History模式的混用**：如果主应用使用History模式，而子应用使用Hash模式，或者反之，可能会导致路由混乱。例如，主应用路由为`/appA`，子应用路由为`#/detail`，最终URL可能变成`/appA#/detail`，这在嵌套路由时可能会产生不符合直觉的URL结构 。因此，最佳实践是主应用和子应用统一使用History模式。
-   **路由劫持**：qiankun内部通过劫持浏览器的历史API（`pushState`, `replaceState`, `popstate`事件）来实现路由的同步。当子应用内部进行路由跳转时，qiankun会捕获到这个行为，并更新主应用的路由，反之亦然。这种劫持机制确保了主子应用路由状态的一致性。
-   **404处理**：在微前端架构中，404处理需要特别小心。通常，主应用需要配置一个通配符路由（`*`），当所有子应用的路由都无法匹配时，由主应用来渲染一个统一的404页面。同时，每个子应用内部也应该有自己的404处理逻辑，以应对直接访问子应用内部不存在的路由的情况。

通过合理的路由设计和qiankun提供的机制，可以有效地管理微前端应用的路由，实现流畅的用户体验。

#### 1.3.3 微前端应用的独立部署与集成

微前端架构的一大核心价值在于支持子应用的独立部署。这意味着每个子应用都可以拥有自己的代码仓库、独立的CI/CD流水线，并且可以独立地发布到生产环境，而无需与其他子应用或主应用进行协调。

**1. 独立部署**

每个子应用都是一个标准的、可独立运行的前端应用。其部署流程与部署一个普通的SPA应用完全相同：
1.  代码提交到独立的Git仓库。
2.  触发CI/CD流水线（如Jenkins, GitLab CI, GitHub Actions）。
3.  流水线执行代码检查、单元测试、构建打包。
4.  将构建生成的静态资源（HTML, JS, CSS, 图片等）上传到静态资源服务器或CDN。

部署完成后，每个子应用都会有一个独立的访问地址（`entry`），例如：
-   React子应用：`https://cdn.example.com/react-app/index.html`
-   Vue子应用：`https://cdn.example.com/vue-app/index.html`

**2. 集成与动态加载**

子应用的集成是由主应用完成的。主应用在运行时，根据路由规则动态地加载和渲染对应的子应用。

主应用的配置（如`registerMicroApps`中的`entry`）指向了各个子应用部署后的地址。当主应用启动时，它并不会立即加载所有子应用的代码，而是采用懒加载的方式。只有当用户访问到某个子应用对应的路由时，主应用才会通过`fetch`请求去加载该子应用的入口HTML文件，然后解析并执行其中的资源。

这种“运行时集成”的方式带来了极大的灵活性：
-   **独立发布**：任何一个子应用的更新，只需要重新部署该子应用即可。主应用无需任何改动，用户在下次访问时，会自动加载到最新的子应用版本。
-   **灰度发布**：可以结合配置中心或后端服务，实现子应用的灰度发布。例如，可以让一部分用户访问新版本的子应用，另一部分用户访问旧版本，从而实现平滑过渡。
-   **A/B测试**：可以为同一个功能开发两个不同版本的子应用，然后通过主应用的路由配置，将流量分发到不同的版本，进行A/B测试。

为了实现这种动态加载，通常需要一个“应用配置中心”。这个配置中心可以是一个简单的JSON文件，也可以是一个后端服务。主应用在启动时，会从这个配置中心获取所有子应用的最新信息（如`entry`地址、版本号等），然后再进行注册和加载。这样，当子应用的部署地址发生变化时，只需更新配置中心即可，无需修改主应用的代码。

### 1.4 微前端项目经验总结与面试题梳理

在复习的最后阶段，将理论知识与自身的项目经验相结合，并准备好应对常见的面试问题，是至关重要的。面试官不仅关心你是否知道微前端是什么，更关心你是否真正实践过，以及你在实践中解决了哪些具体问题。

#### 1.4.1 复盘过往微前端项目中的挑战与解决方案

在面试中，当被问及项目经验时，最有说服力的方式是讲述一个具体的故事，即“遇到了什么问题，是如何分析并解决的”。对于微前端项目，可以从以下几个方面进行复盘和总结：

**1. 技术选型与架构设计**
-   **挑战**：为什么选择微前端架构？当时面临的具体痛点是什么（例如，单体应用过大、团队协同困难、技术栈需要升级等）？
-   **解决方案**：是如何进行技术选型的？对比了哪些框架（如qiankun, single-spa, Module Federation）？最终选择qiankun的原因是什么（例如，社区活跃度、功能完善度、与现有技术栈的契合度等）？整个微前端架构是如何设计的，包括主应用和子应用的划分原则、通信机制、部署策略等。

**2. 沙箱隔离与样式冲突**
-   **挑战**：在项目中是否遇到过JS全局变量污染或CSS样式冲突的问题？具体表现是什么？
-   **解决方案**：是如何利用qiankun的沙箱机制解决JS隔离的？是选择了`SnapshotSandbox`还是`ProxySandbox`，为什么？对于样式冲突，采用了哪种隔离方案（严格隔离还是动态样式表）？在实践中，是否遇到过某些第三方库（如一些UI组件库）与沙箱机制不兼容的情况？是如何解决的（例如，通过配置`excludeAssetFilter`来排除某些资源，或者对第三方库进行特殊处理）？

**3. 应用间通信与状态管理**
-   **挑战**：项目中子应用之间是否有数据共享或状态同步的需求？通信的复杂度如何？
-   **解决方案**：采用了哪种通信方式（props, EventBus, 全局状态管理）？为什么选择这种方式？例如，如果使用了全局状态管理，是如何设计全局状态的结构的？如何避免状态管理的混乱？是否遇到过跨应用通信导致的性能问题或调试困难？

**4. 性能优化**
-   **挑战**：微前端架构是否带来了新的性能问题？例如，子应用首次加载慢、资源重复加载等。
-   **解决方案**：采取了哪些性能优化措施？例如，是否实现了子应用的预加载（`prefetch`）？如何对子应用的资源进行打包优化（如代码分割、懒加载）？是否对主应用的加载逻辑进行了优化？

**5. 部署与运维**
-   **挑战**：独立部署带来了哪些便利，又带来了哪些新的挑战（例如，版本管理、回滚策略、跨应用问题定位）？
-   **解决方案**：是如何设计CI/CD流水线的？如何实现子应用的版本控制和灰度发布？当线上出现问题时，是如何快速定位和解决问题的？

在复盘时，最好能用STAR法则（Situation, Task, Action, Result）来组织你的回答，让故事更清晰、更有条理。

#### 1.4.2 整理微前端相关的常见面试问题与回答思路

除了项目经验，还需要准备一些理论性的面试题。以下是一些常见的微前端面试问题及回答思路：

**1. 什么是微前端？它解决了什么问题？**
-   **回答思路**：首先给出微前端的定义（一种将单体前端应用拆分为多个独立、可组合的子应用的架构风格）。然后，结合项目经验，阐述它如何解决单体应用的痛点，如代码库庞大、团队协作困难、技术栈僵化、部署风险高等。

**2. 微前端和iframe有什么区别？**
-   **回答思路**：这是经典问题。iframe可以实现完美的隔离，但存在URL不同步、UI不同步、通信困难、加载慢等问题。微前端框架（如qiankun）通过JS沙箱和样式隔离来模拟iframe的隔离效果，同时解决了iframe的诸多弊端，提供了更好的用户体验和更灵活的开发模式。

**3. qiankun的沙箱机制是如何实现的？**
-   **回答思路**：分别阐述JS沙箱和样式隔离。JS沙箱可以介绍`SnapshotSandbox`和`ProxySandbox`的原理和区别 。样式隔离可以介绍严格隔离和动态样式表的实现方式。最好能结合项目经验，谈谈在实践中遇到的沙箱相关问题及解决方案。

**4. 微前端应用之间如何通信？**
-   **回答思路**：列举qiankun提供的几种通信方式（props, 官方全局状态, 自定义EventBus等），并说明各自的优缺点和适用场景。强调在项目中是如何根据具体需求选择合适的通信方案的。

**5. 如何处理微前端中的路由冲突？**
-   **回答思路**：核心是`basename`策略。解释如何通过为主应用和子应用设置不同的基础路径来避免冲突。可以结合项目中的路由配置进行说明。

**6. 微前端如何进行独立部署？**
-   **回答思路**：描述每个子应用拥有独立的仓库和CI/CD流水线，构建后部署到静态资源服务器。主应用通过配置中心或硬编码的方式，在运行时动态加载子应用的资源。可以谈谈灰度发布、A/B测试等高级部署策略。

**7. 微前端带来了哪些新的挑战？**
-   **回答思路**：任何事物都有两面性。可以谈谈微前端带来的复杂性，如架构设计更复杂、调试难度增加、性能优化需要考虑更多因素（如子应用加载性能）、对团队的工程化能力要求更高等。然后，可以补充说明是如何在项目中应对这些挑战的。

通过系统性的复习和充分的准备，你将能够在面试中自信、清晰地展示你在微前端领域的专业能力和实践经验。

## 2. 第二周：性能监控与优化专项复习

第二周的核心目标是系统性地梳理和深化您在性能监控与优化方面的项目经验。当前，前端面试越来越注重场景题和实际解决问题的能力，而性能优化是其中最能体现候选人技术深度和工程化思维的领域之一 。仅仅了解“八股文”式的理论知识已不足以应对高级别岗位的面试，面试官更看重候选人如何设计、实现并落地一套完整的性能监控与优化方案。因此，本周的复习将围绕“测量-分析-优化-验证”的闭环展开，从核心指标的解析入手，深入到监控工具的设计思路，再到具体的优化策略，最后落脚于您过往项目经验的总结与面试表达。通过这一周的复习，您需要能够清晰、有逻辑地向面试官阐述您在性能优化领域的实践、思考和成果。

### 2.1 前端性能核心指标与测量

在现代前端开发中，性能不再是一个模糊的概念，而是一系列可量化、可追踪的核心指标（Core Web Vitals）。理解并掌握这些指标的测量方法，是进行有效性能优化的第一步。浏览器提供了一系列强大的API和工具，使得开发者能够精确地获取和分析页面加载与运行过程中的各项性能数据。本小节将重点介绍这些关键性能指标的定义、意义以及如何利用浏览器原生API和开发者工具进行测量与分析。

#### 2.1.1 关键性能指标（FP、FCP、LCP、FID、CLS）解析

前端性能优化的核心在于提升用户体验，而用户体验的优劣可以通过一系列关键性能指标（Key Performance Indicators, KPIs）来量化。这些指标不仅帮助开发者客观地评估网站性能，也是搜索引擎排名（如Google的Core Web Vitals）的重要参考。在面试中，能够清晰解释这些指标的含义、重要性以及它们之间的区别，是展示您性能优化基础知识扎实程度的关键。

以下是几个最核心指标的详细解析：

*   **首次绘制 (First Paint, FP)** ：FP标记的是浏览器首次将像素渲染到屏幕上的时间点。这个渲染可以是任何内容，例如背景色、一个边框，甚至是页面的默认背景。FP主要关注的是“从无到有”的过程，即浏览器开始渲染的时刻。虽然它标志着页面开始响应，但用户可能还看不到任何有意义的内容。因此，FP更多地被视为一个信号，表明浏览器已经开始处理HTML和CSS，但不一定代表用户感知的加载速度。

*   **首次内容绘制 (First Contentful Paint, FCP)** ：FCP衡量的是从页面开始加载到页面内容的任何部分（如文本、图像、`<canvas>`元素等）被渲染到屏幕上的时间。与FP不同，FCP关注的是“有意义的内容”首次出现的时间。这是用户感知页面加载速度的一个重要里程碑，因为它意味着用户开始看到页面的实际内容，而不仅仅是一个空白的背景。一个快速的FCP可以给用户带来“页面正在快速加载”的积极反馈。

*   **最大内容绘制 (Largest Contentful Paint, LCP)** ：LCP是Core Web Vitals的核心指标之一，它测量的是视口内最大的图像或文本块完成渲染的时间。LCP旨在更准确地反映页面的主要内容何时对用户可见。一个较大的LCP元素通常是页面的核心内容，例如一篇文章的标题图或一段重要的文本。LCP是一个以用户为中心的性能指标，因为它直接关系到用户能否快速看到并理解页面的核心信息。根据Google的建议，为了提供良好的用户体验，**LCP应控制在2.5秒以内**。

*   **首次输入延迟 (First Input Delay, FID)** ：FID是另一个Core Web Vitals指标，它衡量的是从用户首次与页面交互（如点击链接、按钮或输入文本）到浏览器实际能够开始处理该交互的时间。FID主要反映了页面的响应性，即主线程是否被阻塞。如果主线程正在执行一个耗时的JavaScript任务，用户的点击或输入就会被延迟处理，导致FID值较高。一个较低的FID（**Google建议小于100毫秒**）意味着页面能够快速响应用户操作，提供流畅的交互体验。

*   **累积布局偏移 (Cumulative Layout Shift, CLS)** ：CLS是第三个Core Web Vitals指标，它衡量的是页面在加载过程中所有意外布局偏移的总和。布局偏移指的是页面元素在渲染后发生的位置变化，例如图片或广告加载后导致文本内容下移。这种意外的移动会严重影响用户体验，可能导致用户点击到错误的位置。CLS通过计算每次布局偏移的分数（影响分数 * 距离分数）并累加得出。一个较低的CLS（**Google建议小于0.1**）意味着页面布局稳定，用户体验更佳。

理解这些指标的定义、计算方式以及它们对用户体验的影响，是进行性能优化的基础。在面试中，您可以结合自己的项目经验，举例说明您是如何针对这些指标进行优化的，例如通过图片懒加载优化LCP，通过代码分割减少主线程阻塞来优化FID，或者为图片预设尺寸来优化CLS。

#### 2.1.2 使用Performance API进行性能数据获取

浏览器提供的Performance API是前端性能监控的基石，它允许开发者以编程方式获取精确到微秒级的性能数据，覆盖了从页面导航、资源加载到用户交互的完整生命周期。相比于传统的通过`Date.now()`计算时间差的方式，Performance API提供了更高精度、更全面、更标准化的性能测量能力。在面试中，深入阐述如何利用Performance API设计和实现一套前端性能监控系统，是展示您技术深度和工程化能力的绝佳机会。

Performance API的核心是`window.performance`对象，它包含了多个重要的属性和方法：

*   **`performance.timing` (已废弃)** ：这是一个`PerformanceTiming`对象，提供了页面加载过程中各个关键时间点的`DOMHighResTimeStamp`（高精度时间戳）。尽管该接口已被标记为废弃，取而代之的是`PerformanceNavigationTiming`，但理解其包含的各个阶段对于理解页面加载流程仍然非常有帮助。例如，`navigationStart`表示浏览器开始导航的时间，`domContentLoadedEventStart`表示DOM内容加载完成的时间。通过计算这些时间点之间的差值，可以得到DNS查询时间、TCP连接时间、首字节时间（TTFB）等关键性能指标。

*   **`performance.getEntriesByType()`**：这是获取性能数据的核心方法。通过传入不同的类型，可以获取不同类型的性能条目。
    *   **`'navigation'`**：返回一个`PerformanceNavigationTiming`对象的数组，包含了当前页面的导航性能数据，如`domContentLoadedEventEnd`、`loadEventEnd`等，是`performance.timing`的现代替代品。
    *   **`'resource'`**：返回一个`PerformanceResourceTiming`对象的数组，包含了页面加载的所有资源（如图片、脚本、样式表、XHR请求等）的详细性能数据。通过遍历这个数组，可以分析每个资源的加载耗时、大小、协议等信息，从而定位性能瓶颈。
    *   **`'paint'`**：返回一个`PerformancePaintTiming`对象的数组，包含了FP和FCP的时间戳。
    *   **`'measure'`**：返回通过`performance.measure()`方法创建的自定义性能测量条目。

*   **`performance.mark()` 和 `performance.measure()`**：这两个方法允许开发者创建自定义的性能标记和测量。`performance.mark(name)`可以在代码的任何位置创建一个带有名称的时间戳，而`performance.measure(name, startMark, endMark)`则可以计算两个标记之间的时间差。这在测量特定代码块（如组件初始化、API请求耗时）的执行时间时非常有用，为性能分析提供了极大的灵活性。

*   **`PerformanceObserver`**：这是一个用于异步监听性能条目的接口。通过创建一个`PerformanceObserver`实例并指定要观察的条目类型，可以在性能事件发生时收到通知，而无需轮询`performance.getEntriesByType()`。这种方式更高效，也更符合现代Web开发的最佳实践。例如，可以监听`'largest-contentful-paint'`、`'first-input'`和`'layout-shift'`条目来实时获取LCP、FID和CLS的值。

在面试中，您可以详细描述如何结合这些API来构建一个性能监控SDK。例如，您可以在应用初始化时创建一个`PerformanceObserver`来监听LCP、FID、CLS等关键指标，并在页面卸载前（`beforeunload`事件）将这些数据上报到服务器。同时，您还可以利用`performance.mark()`和`performance.measure()`来追踪关键业务逻辑的执行时间，为性能优化提供更精细化的数据支持。这种系统性的思考和实践能力，远比简单地背诵API文档更能打动面试官。

#### 2.1.3 利用Lighthouse、Chrome DevTools进行性能分析

虽然Performance API提供了强大的编程接口来获取性能数据，但对于日常开发和问题排查，图形化的开发者工具（如Chrome DevTools）和自动化审计工具（如Lighthouse）同样不可或缺。它们能够以更直观、更便捷的方式帮助开发者发现性能瓶颈、分析加载过程并验证优化效果。在面试中，展示您熟练使用这些工具的能力，可以证明您具备高效的性能问题定位和解决能力。

**Chrome DevTools Performance面板**是进行深度性能分析的利器。通过录制一次页面加载或交互过程，Performance面板会生成一份详细的性能报告，包含以下关键信息：

*   **火焰图 (Flame Chart)** ：以时间轴的形式展示了主线程的活动，包括JavaScript执行、样式计算、布局、绘制等。通过分析火焰图，可以直观地看到哪些函数执行耗时最长，哪些操作导致了页面的卡顿（长任务）。这对于定位导致高FID或页面无响应的JavaScript代码非常有帮助。
*   **网络瀑布图 (Network Waterfall)** ：展示了页面所有资源的加载顺序和耗时。通过瀑布图，可以分析资源加载的并行情况，发现是否存在阻塞渲染的资源（如同步加载的JavaScript），或者是否有资源加载过慢。结合瀑布图的详细信息，可以判断是否需要采用资源懒加载、预加载或CDN加速等优化策略。
*   **帧率图 (FPS Chart)** ：实时显示页面的帧率。如果帧率低于60fps，通常意味着存在性能问题，可能导致动画或滚动不流畅。通过帧率图可以快速定位到导致掉帧的操作。
*   **性能摘要 (Summary)** ：提供了页面加载过程中各个阶段（如加载、脚本、渲染、绘制）的时间占比，帮助开发者从宏观上把握性能瓶颈所在。

**Lighthouse**则是一个开源的自动化工具，可以对网页进行全面的质量审计，包括性能、可访问性、最佳实践和SEO。在性能审计方面，Lighthouse会模拟一个移动设备或桌面设备，对页面进行加载，并生成一份包含多项性能指标（如FCP、LCP、FID、CLS）和优化建议的报告。Lighthouse的优势在于其自动化和标准化，它可以：

*   **提供量化的性能得分**：Lighthouse会给出一个0-100的性能得分，让开发者对页面的整体性能有一个直观的认识。
*   **给出具体的优化建议**：报告会列出具体的优化机会，例如“移除未使用的JavaScript”、“预加载关键请求”、“适当调整图片大小”等，并估算出实施这些优化后可能带来的性能提升。
*   **诊断性能问题**：Lighthouse会诊断出一些常见的性能问题，如主线程工作过长、存在大的DOM树、使用了过时的API等。

在面试中，您可以分享一个具体的案例：例如，您在使用DevTools的Performance面板时发现某个第三方库在初始化时执行了大量同步任务，导致主线程阻塞，FID值偏高。通过分析火焰图，您定位到了具体的函数，并通过代码分割和按需加载的方式，将这部分代码的执行延迟到真正需要时，从而显著降低了FID。或者，您可以使用Lighthouse对页面进行审计，发现LCP指标不佳，原因是首屏的大图没有进行优化。根据Lighthouse的建议，您为图片添加了`loading="lazy"`属性，并使用了更现代的图片格式（如WebP），最终使LCP得到了显著改善。这些具体的实践案例，远比空泛的理论知识更具说服力。

### 2.2 性能监控工具设计与实现

在掌握了性能指标的测量方法后，下一步是思考如何系统性地收集、上报、分析和利用这些数据。设计并实现一套前端性能监控工具，是性能优化从“点”到“面”的升华，也是高级前端工程师必备的能力。这套工具的目标是实现性能问题的“可观测性”，即能够主动发现、定位和预警性能问题，而不是被动地等待用户反馈。在面试中，能够清晰地阐述一套性能监控工具的设计思路，将极大地提升您的竞争力。

#### 2.2.1 设计全站请求耗时统计工具的思路

设计一套全站请求耗时统计工具是性能监控的核心任务之一。其目标是全面、准确地捕获应用中所有HTTP请求的耗时信息，为分析接口性能、定位后端瓶颈和优化用户体验提供数据支持。在面试中，当被问及如何设计这样一套工具时，您可以从以下几个方面进行系统性阐述，展示您的架构设计能力和对前端性能监控的深刻理解 。

**1. 数据采集方案的选择与实现**

采集请求耗时数据是第一步，也是最关键的一步。目前主要有以下几种实现方式，每种方式都有其适用场景和优缺点：

*   **基于`PerformanceObserver`和`PerformanceResourceTiming` API**：这是最推荐的方式。通过创建一个`PerformanceObserver`来监听`'resource'`类型的性能条目，可以捕获到页面加载的所有静态资源（JS、CSS、图片等）和通过`XMLHttpRequest`或`fetch`发起的网络请求的详细性能数据。`PerformanceResourceTiming`接口提供了从DNS查询到响应接收完成的各个阶段的时间戳，如`domainLookupStart`、`connectStart`、`requestStart`、`responseStart`和`responseEnd`。通过这些数据，可以计算出DNS耗时、TCP连接耗时、请求耗时（TTFB）和内容传输耗时。这种方式的优点是精度高、信息全面，且是浏览器原生支持的API，性能开销小。

*   **拦截`XMLHttpRequest`和`fetch` API**：这是一种更通用的方案，可以捕获所有通过这两个API发起的请求，无论浏览器是否支持`PerformanceResourceTiming`。实现方式是重写`XMLHttpRequest`的`open`、`send`方法和`fetch`函数，在请求发送前记录开始时间，在请求完成（`load`事件或`Promise` resolved）后记录结束时间，并计算耗时。这种方式的优点是兼容性好，可以捕获到请求的请求头、请求体、响应头、响应体等更丰富的上下文信息，便于进行更精细化的分析（例如，根据请求参数或响应状态码进行分类统计）。缺点是实现相对复杂，且可能会与项目中其他对`XHR`或`fetch`的封装产生冲突。

*   **利用Service Worker**：Service Worker作为一个网络代理，可以拦截所有由页面发出的网络请求。在Service Worker中，可以通过监听`fetch`事件来捕获请求，并使用`performance.now()`来测量耗时。这种方式的优点是可以实现离线缓存、请求缓存等高级功能，并且与主线程隔离，不会影响页面性能。缺点是实现复杂，且需要HTTPS环境。

在实际设计中，通常会采用组合方案。例如，优先使用`PerformanceObserver`来获取大部分请求的性能数据，对于需要更详细上下文信息的场景，可以结合拦截`XHR`和`fetch`的方式。

**2. 数据结构设计**

采集到的原始性能数据需要经过结构化处理，以便于上报和后续分析。一个典型的请求耗时数据条目（log）可以包含以下字段：

*   `url`: 请求的URL。
*   `method`: 请求方法（GET, POST等）。
*   `status`: 响应状态码。
*   `startTime`: 请求开始时间戳。
*   `endTime`: 请求结束时间戳。
*   `duration`: 总耗时（`endTime - startTime`）。
*   `dnsTime`: DNS查询耗时。
*   `tcpTime`: TCP连接耗时。
*   `ttfb`: Time To First Byte，首字节时间。
*   `transferTime`: 内容传输耗时。
*   `requestSize`: 请求体大小（如果可获取）。
*   `responseSize`: 响应体大小。
*   `userAgent`: 用户浏览器信息。
*   `timestamp`: 数据上报时的时间戳。
*   `pageUrl`: 当前页面的URL。
*   `userId`: 用户ID（如果已登录）。

**3. 数据上报策略**

采集到的性能数据需要上报到服务器进行集中存储和分析。上报策略需要考虑性能和可靠性：

*   **批量上报**：将多条性能数据在本地聚合，达到一定数量或时间间隔后，一次性批量上报。这可以减少网络请求次数，降低对页面性能的影响。
*   **使用`navigator.sendBeacon()`**：这是一个专门用于在页面卸载时异步发送数据的API。它可以在`beforeunload`或`visibilitychange`事件触发时使用，确保数据能够被可靠地发送，即使页面即将关闭。
*   **失败重试**：上报请求可能因为网络问题而失败，需要实现一个简单的重试机制，例如将失败的数据暂存到`localStorage`中，待网络恢复后再次尝试上报。

通过以上系统性的设计，您可以构建一个功能完善、性能优良的全站请求耗时统计工具。在面试中，清晰地阐述这些设计思路，并结合您在项目中遇到的实际问题（如如何处理跨域请求、如何确保数据的准确性等），将充分展示您的专业能力和工程实践经验 。

#### 2.2.2 性能数据的上报与可视化方案

采集到性能数据只是第一步，如何将这些原始数据高效、可靠地传输到后端，并以直观、易懂的方式呈现出来，是性能监控系统能否真正发挥价值的关键。一个完整的性能监控解决方案必须包含一套稳健的数据上报机制和一套强大的数据可视化方案。在面试中，阐述您对这两部分的设计思路，能够体现您对整个监控数据流的全面理解。

**数据上报方案**

数据上报的核心目标是在不影响用户体验的前提下，将前端采集到的性能数据可靠地发送到服务器。设计上报方案时，需要综合考虑以下几个因素：

*   **上报时机与频率**：
    *   **实时上报**：对于一些关键的、需要立即关注的性能指标（如页面加载错误、严重的卡顿），可以采用实时上报的方式，一旦触发就立即发送。但这可能会产生大量的网络请求，对服务器造成压力。
    *   **批量上报**：这是更常见的策略。将多条性能数据在内存中缓存起来，当满足一定条件时（例如，缓存了10条数据，或者距离上次上报过去了30秒），再一次性批量发送。这种方式可以显著减少网络请求的开销。
    *   **页面卸载时上报**：利用`navigator.sendBeacon()` API，可以在用户关闭页面或跳转到其他页面时，将剩余未上报的数据可靠地发送出去。这确保了数据的完整性，避免了因页面卸载导致的数据丢失。

*   **上报方式**：
    *   **`XMLHttpRequest`/`fetch`**：这是最常用的方式，可以发送POST请求，将性能数据作为请求体（通常是JSON格式）发送到后端。
    *   **`navigator.sendBeacon()`**：如前所述，这是页面卸载时上报的最佳选择，因为它在浏览器后台异步发送数据，不会阻塞页面卸载。
    *   **图片打点**：通过创建一个`Image`对象，将数据作为URL参数附加到请求一个1x1像素的GIF图片上。这种方式兼容性好，可以跨域，但只能发送GET请求，且有URL长度限制。

*   **数据压缩与编码**：
    *   为了减少网络传输的数据量，可以在上报前对数据进行压缩，例如使用`gzip`或`brotli`压缩。前端可以使用`pako`等库进行压缩。
    *   对于特别大的数据，可以考虑使用Protocol Buffers等二进制序列化格式，其效率通常高于JSON。

*   **错误处理与重试机制**：
    *   上报请求可能因为网络问题或服务器错误而失败。需要实现一个重试机制，例如指数退避（exponential backoff）算法，在失败后等待一段时间再重试。
    *   对于多次重试仍然失败的数据，可以将其存储在`localStorage`或`IndexedDB`中，待下次页面加载或网络恢复时再进行上报。

**数据可视化方案**

数据上报到后端后，需要进行存储、处理和可视化，以便开发者和运维人员能够直观地了解应用的性能状况，并快速定位问题。

*   **后端数据存储与处理**：
    *   **存储**：性能数据通常是时序数据（Time Series Data），适合使用时序数据库（如InfluxDB, TimescaleDB）或支持高效写入和聚合查询的数据库（如ClickHouse, Elasticsearch）进行存储。
    *   **处理**：后端服务需要接收前端上报的数据，进行清洗、校验和入库。同时，还需要提供API供前端可视化界面查询数据。这些API通常需要支持按时间范围、页面URL、用户群体等维度进行筛选和聚合（例如，计算P50, P90, P95分位数）。

*   **前端可视化展示**：
    *   **仪表盘 (Dashboard)** ：这是性能监控平台的核心界面。仪表盘上通常会展示一系列关键性能指标的实时和历史趋势图，例如：
        *   **页面加载性能**：FP、FCP、LCP、FID、CLS的趋势图。
        *   **接口请求性能**：各接口的平均耗时、P95/P99耗时、错误率的趋势图。
        *   **资源加载性能**：各类资源（JS、CSS、图片）的平均加载时间、大小分布。
        *   **错误监控**：JS错误数、Promise拒绝数、资源加载错误数的趋势图。
    *   **图表类型**：根据不同的数据类型和展示需求，可以选择合适的图表类型，如折线图（展示趋势）、柱状图（比较不同维度的数据）、饼图（展示占比）、散点图（展示分布）等。
    *   **下钻分析 (Drill-down)** ：一个好的可视化平台应该支持交互式下钻。例如，在仪表盘上看到某个接口的平均耗时突然升高，可以点击该数据点，下钻到更详细的视图，查看该接口在不同时间段、不同用户群体、不同地理区域的耗时分布，从而帮助定位问题的根源。
    *   **告警系统**：当某些关键性能指标超过预设的阈值时（例如，LCP超过4秒，或接口错误率超过1%），系统应该能够通过邮件、短信、即时通讯工具（如钉钉、企业微信）等方式发送告警，通知相关人员进行处理。

在面试中，您可以结合您过往的项目经验，描述您是如何设计和实现数据上报和可视化方案的。例如，您使用了什么技术栈来搭建后端服务，选择了哪种数据库来存储时序数据，使用了哪个前端图表库（如ECharts, D3.js, AntV）来构建仪表盘，以及您是如何设计告警规则的。这些具体的实践细节，将使您的回答更加丰满和有说服力。

### 2.3 前端性能优化策略与实践

在掌握了性能指标的测量和监控方法后，最终的落脚点在于如何采取有效的优化策略来提升用户体验。前端性能优化是一个系统性的工程，涉及到从网络传输、资源加载、代码执行到页面渲染的方方面面。在面试中，能够系统性地阐述性能优化的策略，并结合实际项目经验说明您是如何应用这些策略并取得成效的，是展示您技术广度和深度的关键。当前，面试越来越倾向于场景题，要求候选人能够针对具体的性能问题提出切实可行的解决方案 。

#### 2.3.1 资源加载优化（懒加载、预加载、CDN、HTTP缓存）

资源加载是影响页面首屏渲染速度的关键因素。优化资源加载策略，可以显著缩短用户看到首屏内容的时间，提升LCP等核心指标。以下是几种常用且有效的资源加载优化策略：

*   **懒加载 (Lazy Loading)** ：懒加载的核心思想是“按需加载”，即只加载当前视口内或即将进入视口的资源，而将其他非关键资源的加载推迟到需要时再进行。这种方式可以显著减少首屏需要加载的资源数量，从而加快首屏渲染速度。
    *   **图片懒加载**：对于页面中大量的图片，尤其是那些位于首屏以下的图片，可以使用懒加载。实现方式有多种：
        *   **原生懒加载**：现代浏览器支持`loading="lazy"`属性，只需在`<img>`标签上添加该属性，浏览器就会自动处理懒加载逻辑。这是最简单、最推荐的方式。
        *   **Intersection Observer API**：通过监听图片元素与视口的交叉状态，当图片即将进入视口时，再动态地设置其`src`属性。这种方式兼容性更好，且可以实现更复杂的懒加载逻辑（例如，提前一定距离开始加载）。
    *   **组件懒加载**：在单页应用（SPA）中，可以使用路由级别的代码分割（Code Splitting）来实现组件的懒加载。例如，在React中，可以使用`React.lazy()`和`Suspense`；在Vue中，可以使用动态`import()`语法。这样，只有当用户访问到某个路由时，对应的组件代码才会被加载。

*   **预加载 (Preloading) 与预连接 (Preconnect)** ：与懒加载相反，预加载和预连接是一种“提前加载”的策略，用于加载那些对当前页面至关重要的资源，或者提前建立与关键域名的连接，以减少后续请求的延迟。
    *   **`<link rel="preload">`**：用于告诉浏览器某个资源（如字体、关键CSS、JavaScript模块）对当前页面非常重要，需要尽快加载。浏览器会优先加载这些被`preload`的资源。
    *   **`<link rel="prefetch">`**：用于告诉浏览器某个资源（如下一个页面可能用到的资源）在未来可能会被用到，可以在浏览器空闲时提前加载。这可以加速后续页面的加载速度。
    *   **`<link rel="preconnect">`**：用于提前与某个域名建立DNS解析、TCP连接和TLS握手。这对于加载来自第三方域名的资源（如CDN、字体服务）非常有用，可以节省后续请求的连接建立时间。
    *   **`<link rel="dns-prefetch">`**：仅提前进行DNS解析，比`preconnect`更轻量，适用于那些只需要解析DNS的场景。

*   **内容分发网络 (CDN)** ：CDN通过在全球各地部署边缘服务器，将网站的静态资源（如图片、JS、CSS）缓存到离用户最近的服务器上。当用户请求这些资源时，CDN会自动将请求路由到最优的边缘节点，从而大大减少了网络传输的延迟，加快了资源加载速度。使用CDN是提升全球用户访问速度最有效的方法之一。

*   **HTTP缓存策略**：合理配置HTTP缓存头，可以让浏览器缓存已加载过的资源，避免在后续访问中重复下载，从而显著提升页面加载速度。
    *   **强缓存 (Expires/Cache-Control)** ：通过设置`Expires`或`Cache-Control: max-age`响应头，告诉浏览器在指定的时间内，可以直接从本地缓存中读取资源，而无需向服务器发送任何请求。这是最理想的缓存策略。
    *   **协商缓存 (Last-Modified/ETag)** ：当强缓存失效后，浏览器会携带`If-Modified-Since`（对应`Last-Modified`）或`If-None-Match`（对应`ETag`）请求头向服务器询问资源是否有更新。如果服务器判断资源未修改，会返回`304 Not Modified`状态码，浏览器则继续使用本地缓存。这种方式需要一次网络请求，但可以避免重新传输未修改的资源内容。

在面试中，您可以结合一个具体的场景来阐述这些策略的应用。例如，在一个电商网站的首页，您可能会：
1.  使用CDN来分发所有静态资源。
2.  对网站的Logo、主图等关键图片使用`<link rel="preload">`进行预加载。
3.  对商品列表中的大量图片使用`loading="lazy"`进行懒加载。
4.  为所有静态资源设置合理的`Cache-Control`头，实现长期缓存。
5.  对来自第三方统计服务的域名使用`<link rel="preconnect">`。
通过这样系统性的优化，可以显著提升首页的加载速度和用户体验。

#### 2.3.2 代码层面优化（代码分割、Tree Shaking、非必要资源延迟加载）

除了资源加载，代码本身的体积和执行效率也是影响前端性能的重要因素。随着应用复杂度的增加，JavaScript包的大小往往会急剧膨胀，导致首屏加载时间变长，主线程被长时间阻塞，从而影响FID和TTI（Time to Interactive）等关键指标。因此，从代码层面进行优化，减少不必要的代码传输和执行，是性能优化中至关重要的一环。

*   **代码分割 (Code Splitting)** ：代码分割是现代前端构建工具（如Webpack, Rollup, Vite）提供的一项核心功能，其目的是将一个大型的JavaScript包拆分成多个较小的块（chunks），并按需加载。这可以显著减少首屏需要加载和执行的JavaScript代码量。
    *   **动态导入 (Dynamic Imports)** ：这是最常见的分割方式。通过在代码中使用`import()`语法，可以创建一个异步的代码块。当代码执行到`import()`语句时，才会去加载对应的模块。这在SPA中通常与路由懒加载结合使用，实现按路由拆分代码。
    *   **防止重复 (Prevent Duplication)** ：通过配置`optimization.splitChunks`（Webpack），可以将多个入口点或异步模块中共同引用的依赖（如`react`, `lodash`）提取到一个单独的`vendor` chunk中。这样，即使用户在不同页面间跳转，这些公共库也只需要加载一次，并被浏览器缓存。

*   **Tree Shaking (摇树优化)** ：Tree Shaking是一种通过消除JavaScript中未使用代码（dead code）来减小包体积的优化技术。它依赖于ES6模块的静态结构（`import`和`export`）。构建工具在打包时，会分析模块间的依赖关系，并只将那些被实际引用的代码包含到最终的bundle中。例如，如果您只从`lodash`库中引用了`debounce`函数，Tree Shaking会确保只有`debounce`相关的代码被打包，而不是整个`lodash`库。为了有效利用Tree Shaking，需要确保：
    *   使用ES6模块语法。
    *   使用的第三方库提供了ES6模块版本（即`package.json`中的`module`字段）。
    *   在`package.json`中设置`"sideEffects": false`，或者明确指定哪些文件是有副作用的，以帮助构建工具更好地进行优化。

*   **非必要资源延迟加载 (Lazy Loading Non-Critical Resources)** ：除了代码分割，还可以将一些非必要的、不影响首屏渲染的资源和逻辑进行延迟加载。
    *   **第三方库延迟加载**：对于一些非核心的第三方库（如广告SDK、聊天机器人、非首屏的图表库），可以在页面加载完成后再动态加载。例如，可以在`window.onload`事件触发后，或者当用户滚动到特定区域时，再去加载这些库。
    *   **非关键JavaScript延迟执行**：将一些非关键的JavaScript代码（如数据统计、用户行为分析）放在页面底部，或者使用`async`或`defer`属性来延迟其执行。`async`会使脚本异步下载，下载完成后立即执行，可能会阻塞HTML解析。`defer`会使脚本异步下载，但会推迟到整个HTML解析完成后再执行，不会阻塞HTML解析，是更推荐的方式。

*   **Polyfill按需加载**：为了兼容旧版浏览器，我们通常会引入大量的Polyfill。但这些Polyfill对于现代浏览器来说是不必要的，会增加包的体积。可以使用`@babel/preset-env`的`useBuiltIns: 'usage'`配置，根据目标浏览器和代码中实际使用的特性，按需引入所需的Polyfill。或者，可以使用`Polyfill.io`等服务，根据用户的User-Agent动态地返回所需的Polyfill脚本。

在面试中，您可以分享一个您通过代码层面优化显著提升应用性能的案例。例如，您可能通过分析Webpack的bundle分析报告（如`webpack-bundle-analyzer`），发现某个第三方库（如`moment.js`）体积巨大，且只使用了其中一小部分功能。您可能采取了以下优化措施：
1.  使用`dayjs`或`date-fns`等更轻量的库替换`moment.js`。
2.  对路由进行代码分割，将每个页面的代码拆分成独立的chunk。
3.  将`echarts`等图表库配置为按需加载，只有当用户访问到包含图表的页面时才加载。
通过这些优化，您成功地将首屏JavaScript包的大小减少了50%以上，显著提升了页面的加载速度和可交互时间。

#### 2.3.3 渲染层面优化（避免回流与重绘、虚拟滚动）

渲染层面的优化对于提升页面的流畅度和响应速度至关重要。以下是一些常用的渲染层面优化策略：

1.  **避免回流（Reflow）与重绘（Repaint）** ：回流和重绘是浏览器渲染过程中的两个重要步骤。回流是指当元素的尺寸、位置或结构发生变化时，浏览器需要重新计算元素的布局，并重新构建渲染树的过程。重绘是指当元素的样式发生变化，但不影响其布局时，浏览器只需要重新绘制元素的过程。回流的性能开销远大于重绘，因此，需要尽量避免回流的发生。

    为了避免回流，可以采取一些措施，如避免频繁地修改元素的样式、使用`transform`和`opacity`来进行动画（因为它们不会触发回流）、使用`DocumentFragment`来进行DOM操作、将需要多次修改的元素设置为`display: none`，修改完成后再显示出来等。此外，还可以使用`requestAnimationFrame`来进行动画，它可以将动画操作与浏览器的刷新频率同步，从而提高动画的流畅度。

2.  **虚拟滚动（Virtual Scrolling）** ：当列表中的数据量非常大时，如果一次性渲染所有的列表项，会导致DOM元素过多，从而影响页面的性能。虚拟滚动是一种优化技术，它只渲染可视区域内的列表项，并在滚动时动态地更新列表项的内容，从而避免了渲染大量的DOM元素。实现虚拟滚动的方式有很多种，如使用一些开源的虚拟滚动库，如`react-window`、`vue-virtual-scroller`等。通过使用虚拟滚动，可以显著提高长列表的渲染性能，提升用户体验。

3.  **使用CSS动画代替JavaScript动画**：CSS动画通常比JavaScript动画性能更好，因为它们可以由浏览器的合成器（Compositor）来执行，而不会阻塞主线程。因此，在实现动画效果时，我们应该优先考虑使用CSS动画。

4.  **优化图片**：图片是网页中常见的资源，也是影响性能的重要因素。我们可以通过压缩图片、使用合适的图片格式（如WebP）、使用懒加载等方式来优化图片的加载和渲染。

通过综合使用这些策略，我们可以有效地优化页面的渲染过程，从而提升页面的流畅度和响应速度。

### 2.4 性能优化项目经验总结与面试题梳理

#### 2.4.1 复盘过往性能优化项目中的具体措施与效果

在复盘过往的性能优化项目时，需要详细记录所采取的具体措施以及这些措施所带来的效果。这不仅可以为未来的项目提供宝贵的经验，也可以在面试中展现出自己的实践能力和解决问题的能力。复盘时，可以按照“问题-分析-措施-效果”的结构来进行描述。例如，可以描述在某个项目中，发现首屏加载时间过长，影响了用户体验。经过分析，发现是由于首页加载了大量的图片和JS文件，导致了网络请求过多，阻塞了页面的渲染。

为了解决这个问题，采取了以下措施：首先，对图片进行了优化，使用了WebP格式，并进行了压缩，从而减少了图片的体积。其次，对JS文件进行了代码分割，将非关键的JS文件进行了懒加载，只在需要时才加载。最后，使用了CDN来加速资源的加载。实施这些措施后，首屏加载时间从原来的5秒降低到了2秒，显著提升了用户体验。

在复盘时，还需要注意量化效果。例如，可以说“通过优化，首屏加载时间降低了60%”、“页面加载速度提升了30%”等。量化的效果可以更直观地展现出优化的价值。此外，还可以记录一些在优化过程中遇到的困难和挑战，以及如何克服这些困难的过程。例如，在优化过程中，可能会遇到一些兼容性问题，需要通过查阅文档、调试代码等方式来解决。通过记录这些过程，可以展现出自己的学习能力和解决问题的能力。

#### 2.4.2 整理性能监控与优化相关的常见面试问题与回答思路

在准备性能监控与优化相关的面试时，需要对常见的面试问题进行梳理和总结，并准备好相应的回答思路。这些问题通常会围绕性能指标、性能监控工具、性能优化策略等方面展开。例如，面试官可能会问：“在进行前端性能监控时，你会关注哪些关键指标？”在回答这个问题时，可以提到一些关键性能指标，如FP、FCP、LCP、FID、CLS等，并解释它们的含义和重要性 。例如，LCP用于衡量页面的加载性能，FID用于衡量页面的交互性，CLS用于衡量页面的视觉稳定性。

另一个常见的问题是：“你会使用哪些工具来进行性能分析？”在回答这个问题时，可以提到一些常用的性能分析工具，如Lighthouse、Chrome DevTools、Performance API等，并简要介绍它们的功能和使用方法 。例如，Lighthouse可以进行全面的性能审计，Chrome DevTools的Performance面板可以记录详细的性能数据，Performance API可以获取自定义的性能指标。

面试官还可能会问：“你会如何进行前端性能优化？”在回答这个问题时，可以从资源加载优化、代码层面优化、渲染层面优化等方面进行阐述。例如，在资源加载优化方面，可以提到懒加载、预加载、CDN、HTTP缓存等。在代码层面优化方面，可以提到代码分割、Tree Shaking、非必要资源延迟加载等。在渲染层面优化方面，可以提到避免回流与重绘、虚拟滚动等。在回答时，最好能够结合具体的项目经验，说明自己是如何应用这些优化策略的，以及取得了什么样的效果。通过这样的准备，可以在面试中展现出自己对性能优化的深入理解和实践经验，从而提高面试的成功率。

## 3. 第三周：WebSocket与低代码平台专项复习

### 3.1 WebSocket协议与实战应用

#### 3.1.1 WebSocket协议原理与握手过程

WebSocket是一种在单个TCP连接上进行全双工通信的协议，它使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。WebSocket协议建立在HTTP协议之上，通过一次HTTP握手来建立连接。握手过程如下：首先，客户端向服务器发送一个HTTP请求，请求头中包含`Upgrade: websocket`和`Connection: Upgrade`字段，表示希望将协议升级为WebSocket。此外，请求头中还包含`Sec-WebSocket-Key`字段，这是一个由客户端随机生成的Base64编码的字符串，用于服务器验证。

服务器收到客户端的握手请求后，会进行验证。如果验证通过，服务器会返回一个HTTP响应，状态码为`101 Switching Protocols`，表示同意升级协议。响应头中也包含`Upgrade: websocket`和`Connection: Upgrade`字段，以及`Sec-WebSocket-Accept`字段。`Sec-WebSocket-Accept`字段的值是根据客户端发送的`Sec-WebSocket-Key`和一个固定的字符串（`258EAFA5-E914-47DA-95CA-C5AB0DC85B11`）进行SHA-1哈希计算，再进行Base64编码得到的。客户端收到服务器的响应后，会进行验证，如果验证通过，WebSocket连接就建立成功了。

一旦连接建立成功，客户端和服务器就可以通过WebSocket连接进行双向数据传输。WebSocket协议定义了两种类型的数据帧：文本帧和二进制帧。客户端和服务器可以随时发送数据帧，而不需要像HTTP那样，每次通信都需要建立新的连接。这种全双工通信模式使得WebSocket非常适合实时性要求高的应用场景，如在线聊天、实时游戏、股票交易系统等。WebSocket协议还定义了一些控制帧，如`ping`、`pong`、`close`等，用于心跳检测和连接关闭。

#### 3.1.2 WebSocket与HTTP、SSE、长轮询的对比

WebSocket、HTTP、SSE（Server-Sent Events）和长轮询都是用于客户端和服务器之间通信的技术，但它们在通信模式、实时性、开销等方面有所不同。HTTP是一种基于请求-响应模式的协议，客户端发送请求，服务器返回响应。这种模式适用于大多数Web应用场景，但对于需要实时数据推送的场景，HTTP的效率较低，因为每次通信都需要建立新的连接，并且服务器无法主动向客户端推送数据。

长轮询是一种模拟实时通信的技术，客户端发送一个请求，服务器保持连接，直到有数据时才返回响应。客户端收到响应后，立即发送下一个请求。这种方式可以实现准实时的数据推送，但仍然需要频繁地建立和关闭连接，开销较大。SSE是一种基于HTTP的服务器推送技术，它允许服务器向客户端单向推送数据。客户端通过`EventSource`对象来接收服务器推送的数据。SSE的优点是实现简单，自动重连，但缺点是只支持单向通信，并且部分浏览器不支持。

WebSocket是一种全双工通信协议，它允许客户端和服务器之间进行双向数据传输。与HTTP相比，WebSocket在建立连接后，通信开销更小，因为不需要每次都发送HTTP头。与长轮询和SSE相比，WebSocket的实时性更高，因为它是一个持久的连接，服务器可以随时向客户端推送数据。WebSocket的缺点是实现相对复杂，需要服务器和客户端都支持WebSocket协议。下表总结了这几种技术的对比：

| 技术      | 通信模式   | 实时性 | 开销 | 适用场景           |
| --------- | ---------- | ------ | ---- | ------------------ |
| HTTP      | 请求-响应  | 低     | 高   | 大多数Web应用      |
| 长轮询    | 模拟实时   | 中     | 高   | 简单的实时应用     |
| SSE       | 服务器推送 | 中     | 中   | 新闻推送、股票行情 |
| WebSocket | 全双工     | 高     | 低   | 在线聊天、实时游戏 |

#### 3.1.3 前端WebSocket API的使用与封装

前端可以通过`WebSocket`对象来使用WebSocket协议。创建`WebSocket`对象时，需要传入服务器的URL。`WebSocket`对象提供了一些事件，如`open`、`message`、`error`、`close`，用于处理连接的不同状态。

```javascript
const ws = new WebSocket('ws://localhost:8080');

ws.onopen = function(event) {
  console.log('WebSocket连接已建立');
  ws.send('Hello, Server!');
};

ws.onmessage = function(event) {
  console.log('收到服务器消息:', event.data);
};

ws.onerror = function(error) {
  console.error('WebSocket错误:', error);
};

ws.onclose = function(event) {
  console.log('WebSocket连接已关闭');
};
```

在实际项目中，通常会对`WebSocket` API进行封装，以简化使用、增加功能（如心跳、重连）。封装后的WebSocket类可以提供更友好的API，例如`send()`、`on()`、`off()`等，并自动处理连接的建立、断开、重连等逻辑。

### 3.2 WebSocket在复杂场景下的应用

#### 3.2.1 WebSocket心跳机制与重连策略

在复杂的网络环境中，WebSocket连接可能会因为网络波动、服务器重启等原因而断开。为了保证连接的稳定性，需要实现心跳机制和重连策略。

**心跳机制**：心跳机制用于检测连接是否仍然活跃。客户端可以定期向服务器发送一个`ping`消息，服务器收到后返回一个`pong`消息。如果客户端在一定时间内没有收到`pong`消息，就可以认为连接已经断开，并触发重连。

**重连策略**：当连接断开时，客户端可以尝试重新连接。重连策略需要考虑重连的频率和次数。可以采用指数退避算法，即每次重连失败后，等待的时间会指数级增加，以避免对服务器造成过大的压力。同时，可以设置一个最大重连次数，如果超过该次数仍然无法连接，则可以认为服务器不可用，并停止重连。

#### 3.2.2 WebSocket安全性考虑（如鉴权、数据加密）

WebSocket连接的安全性是一个重要的问题。为了保证连接的安全性，可以采取以下措施：

*   **鉴权**：在建立WebSocket连接时，可以进行鉴权。例如，可以在URL中携带token，或者在握手请求头中添加鉴权信息。服务器在收到连接请求时，会验证token的有效性，如果验证失败，则拒绝连接。
*   **数据加密**：WebSocket协议本身支持加密，可以使用`wss://`协议（WebSocket Secure）来建立加密连接。`wss://`协议使用TLS/SSL对数据进行加密，可以防止数据在传输过程中被窃听或篡改。
*   **输入验证**：服务器需要对客户端发送的数据进行验证，防止恶意数据对服务器造成攻击。例如，可以对数据的长度、格式进行限制，并对特殊字符进行转义。

#### 3.2.3 基于WebSocket的实时应用（如聊天室、协同编辑）设计

基于WebSocket可以设计各种实时应用，如在线聊天室、协同编辑器等。在设计这些应用时，需要考虑以下几个方面：

*   **消息协议**：需要定义一套消息协议，用于客户端和服务器之间的通信。消息协议可以采用JSON格式，包含消息类型、消息内容、发送者、接收者等信息。
*   **房间管理**：对于聊天室、协同编辑等应用，需要对用户进行分组管理。可以将用户分配到不同的房间（room），每个房间内的用户可以相互通信。
*   **状态同步**：在协同编辑等应用中，需要保证所有用户看到的状态是一致的。服务器需要维护一个全局的状态，并在状态发生变化时，将最新的状态推送给所有用户。
*   **冲突解决**：在协同编辑等应用中，可能会出现多个用户同时修改同一部分内容的情况。需要设计一套冲突解决机制，例如采用操作转换（Operational Transformation, OT）算法，来保证数据的一致性。

### 3.3 低代码平台原理与实践

#### 3.3.1 低代码平台的核心概念与设计思想

低代码平台（Low-Code Platform）是一种通过可视化拖拽和配置，而非传统编码方式，来快速构建应用程序的开发平台。其核心设计思想是**降低开发门槛，提高开发效率**，让非专业开发者（如业务人员）也能参与到应用构建中，同时让专业开发者能更专注于复杂业务逻辑的实现。

低代码平台通常包含以下几个核心概念：
*   **可视化设计器（Designer）** ：提供一个所见即所得的界面，用户可以通过拖拽组件、配置属性来设计页面布局。
*   **组件库（Component Library）** ：提供一系列预置的、可复用的UI组件（如按钮、输入框、表格等），用户可以直接在设计器中使用。
*   **数据模型（Data Model）** ：允许用户定义和管理应用的数据结构，并与后端数据源进行连接。
*   **逻辑编排（Logic Orchestration）** ：提供一种可视化的方式来定义业务逻辑，例如通过流程图、事件-动作模型等。
*   **代码生成器（Code Generator）** ：将用户在可视化设计器中的设计，自动转换为可运行的前端代码（如HTML、CSS、JavaScript）。

#### 3.3.2 低代码平台的页面搭建、数据绑定与逻辑编排

在低代码平台中，页面搭建、数据绑定和逻辑编排是三个核心环节。

**页面搭建**：用户通过从组件库中拖拽组件到画布上，来构建页面的布局和结构。每个组件都有自己的属性面板，用户可以在属性面板中配置组件的样式、行为等。

**数据绑定**：低代码平台支持将组件的属性与数据源进行绑定。数据源可以是静态数据，也可以是来自API接口的动态数据。例如，可以将一个表格组件的数据源绑定到一个API接口，表格会自动显示接口返回的数据。

**逻辑编排**：低代码平台提供了一种可视化的方式来定义业务逻辑。例如，可以配置一个按钮的点击事件，当按钮被点击时，执行一个API请求，并将请求结果显示在页面上。这种事件-动作的模型，使得用户无需编写代码，就能实现复杂的交互逻辑。

#### 3.3.3 低代码平台的二次开发与自定义组件

为了满足更复杂的业务需求，低代码平台通常支持二次开发和自定义组件。

**二次开发**：低代码平台生成的代码通常是可读的、可维护的，开发者可以在生成的代码基础上进行二次开发，添加更复杂的业务逻辑。

**自定义组件**：低代码平台通常提供一套SDK，允许开发者开发自定义组件。开发者可以使用自己熟悉的前端框架（如React、Vue）来开发组件，并将其发布到平台的组件库中，供其他用户使用。

### 3.4 WebSocket与低代码项目经验总结与面试题梳理

#### 3.4.1 复盘过往WebSocket与低代码项目中的核心贡献

在复盘WebSocket与低代码项目时，需要重点突出自己的核心贡献。例如，在WebSocket项目中，可以描述自己是如何设计和实现心跳机制、重连策略的，是如何解决WebSocket安全性问题的，以及是如何基于WebSocket开发实时应用的。

在低代码项目中，可以描述自己是如何参与低代码平台的设计和开发的，是如何实现自定义组件的，以及是如何解决低代码平台在性能和可扩展性方面遇到的问题的。

#### 3.4.2 整理WebSocket与低代码相关的常见面试问题与回答思路

在准备WebSocket与低代码相关的面试时，可以整理一些常见的面试问题，并提前准备好回答思路。以下是一些可能会被问到的问题以及相应的回答思路：

1.  **WebSocket和HTTP有什么区别？**
    *   **回答思路**：从通信模式、连接开销、数据格式、适用场景等方面进行对比。

2.  **WebSocket是如何建立连接的？**
    *   **回答思路**：详细描述WebSocket的握手过程，包括客户端发送的请求头和服务器返回的响应头。

3.  **如何保证WebSocket连接的稳定性？**
    *   **回答思路**：介绍心跳机制和重连策略的实现。

4.  **如何保证WebSocket连接的安全性？**
    *   **回答思路**：介绍鉴权、数据加密、输入验证等安全措施。

5.  **什么是低代码平台？它的核心优势是什么？**
    *   **回答思路**：给出低代码平台的定义，并阐述其在降低开发门槛、提高开发效率等方面的优势。

6.  **低代码平台是如何实现页面搭建、数据绑定和逻辑编排的？**
    *   **回答思路**：结合具体的低代码平台，描述其可视化设计器、组件库、数据模型、逻辑编排等核心功能。

7.  **低代码平台如何进行二次开发和自定义组件？**
    *   **回答思路**：介绍低代码平台的二次开发方式和自定义组件的开发流程。

## 4. 第四周：综合能力提升与面试准备

### 4.1 前端安全与工程化

#### 4.1.1 常见Web安全漏洞（XSS、CSRF）原理与防御

前端安全是Web开发中不可忽视的重要环节。常见的Web安全漏洞包括跨站脚本攻击（XSS）和跨站请求伪造（CSRF）。

**XSS（Cross-Site Scripting）** ：攻击者通过在页面中注入恶意脚本，当用户访问该页面时，恶意脚本会在用户的浏览器中执行，从而窃取用户的敏感信息（如Cookie、Session ID等）。XSS攻击可以分为反射型、存储型和DOM型。

*   **防御措施**：
    *   **输入过滤**：对用户输入的数据进行过滤，过滤掉其中的HTML标签和JavaScript代码。
    *   **输出转义**：在将数据输出到页面时，对数据进行转义，将特殊字符（如`<`、`>`、`"`、`'`等）转换为HTML实体。
    *   **使用CSP（Content Security Policy）** ：CSP是一种HTTP响应头，用于限制页面可以加载哪些资源，从而防止XSS攻击。

**CSRF（Cross-Site Request Forgery）** ：攻击者通过诱导用户在已登录的网站上执行非预期的操作，从而利用用户的身份进行恶意操作。例如，攻击者可以在一个恶意网站上放置一个图片链接，当用户点击该链接时，会向用户的银行网站发送一个转账请求。

*   **防御措施**：
    *   **使用CSRF Token**：在表单中添加一个随机的CSRF Token，服务器在收到请求时，会验证Token的有效性。
    *   **验证Referer/Origin**：服务器可以验证请求的Referer或Origin头，判断请求是否来自合法的网站。
    *   **使用SameSite Cookie**：将Cookie的SameSite属性设置为`Strict`或`Lax`，可以防止Cookie在跨站请求中被发送。

#### 4.1.2 JWT鉴权机制原理与应用

JWT（JSON Web Token）是一种用于在网络应用间安全传输信息的开放标准。JWT通常用于用户鉴权。

**JWT的结构**：JWT由三部分组成，用`.`分隔：
*   **Header（头部）** ：包含令牌的类型（JWT）和使用的签名算法（如HS256、RS256等）。
*   **Payload（载荷）** ：包含需要传输的数据，如用户ID、用户名、过期时间等。
*   **Signature（签名）** ：用于验证令牌的真实性，防止被篡改。

**JWT的工作原理**：
1.  用户登录后，服务器生成一个JWT，并将其返回给客户端。
2.  客户端将JWT存储在本地（如localStorage、sessionStorage或Cookie中）。
3.  客户端在后续的请求中，将JWT放在请求头中（通常是`Authorization`头）发送给服务器。
4.  服务器在收到请求后，会验证JWT的签名，如果验证通过，则认为用户是合法的，并处理请求。

**JWT的优点**：
*   **无状态**：服务器不需要存储会话信息，减轻了服务器的负担。
*   **可扩展**：JWT可以包含任意的用户信息，方便进行权限控制。
*   **跨语言**：JWT是一种开放标准，可以被多种编程语言支持。

**JWT的缺点**：
*   **无法撤销**：一旦JWT被签发，在过期之前，服务器无法将其撤销。
*   **安全性问题**：如果JWT被泄露，攻击者就可以冒充用户进行操作。

#### 4.1.3 前端工程化（构建工具、CI/CD、自动化部署）概念

前端工程化是指利用工具和规范，将前端开发流程标准化、自动化，从而提高开发效率、代码质量和项目可维护性。

**构建工具**：构建工具用于将源代码转换为可运行的代码。常用的构建工具包括Webpack、Vite、Rollup等。构建工具通常提供以下功能：
*   **代码转换**：将ES6+、TypeScript等代码转换为浏览器兼容的代码。
*   **代码压缩**：压缩JavaScript、CSS、HTML代码，减小文件体积。
*   **代码分割**：将代码分割成多个文件，实现按需加载。
*   **模块打包**：将多个模块打包成一个或多个文件。

**CI/CD（持续集成/持续部署）** ：CI/CD是一种软件开发实践，旨在通过自动化的方式，将代码从开发到部署的整个过程串联起来。
*   **持续集成（CI）** ：开发人员频繁地将代码集成到主干，每次集成都会通过自动化的构建和测试来验证，从而尽早地发现和解决问题。
*   **持续部署（CD）** ：将经过验证的代码自动部署到生产环境。

**自动化部署**：自动化部署是CI/CD的一部分，它通过脚本或工具，将代码自动部署到服务器。自动化部署可以减少人工操作的错误，提高部署效率。

### 4.2 主流框架对比与项目复盘

#### 4.2.1 React与Vue核心思想、生态对比

React和Vue是目前最流行的两个前端框架，它们在核心思想、生态系统等方面有所不同。

**核心思想**：
*   **React**：React的核心思想是**组件化**和**函数式编程**。React使用JSX来描述UI，将UI视为状态的函数。React强调单向数据流，通过状态（state）和属性（props）来管理组件的数据。
*   **Vue**：Vue的核心思想是**组件化**和**响应式编程**。Vue使用模板语法来描述UI，通过数据劫持和发布-订阅模式来实现数据的响应式。Vue支持双向数据绑定，通过`v-model`指令可以方便地实现表单元素和数据的双向绑定。

**生态系统**：
*   **React**：React的生态系统非常庞大，拥有丰富的第三方库和工具。React本身只关注UI层，其他功能（如路由、状态管理）需要通过第三方库来实现。常用的React生态库包括React Router（路由）、Redux/MobX（状态管理）、Next.js（服务端渲染框架）等。
*   **Vue**：Vue的生态系统相对完整，官方提供了一系列配套的库和工具。Vue官方提供了Vue Router（路由）、Vuex/Pinia（状态管理）、Nuxt.js（服务端渲染框架）等。

#### 4.2.2 如何根据项目需求选择合适的技术栈

在选择技术栈时，需要综合考虑项目的具体需求、团队的技术背景、社区活跃度、学习成本等因素。

*   **项目需求**：如果项目需要高度的灵活性和可定制性，可以选择React。如果项目需要快速开发，并且对性能要求较高，可以选择Vue。
*   **团队技术背景**：如果团队对React比较熟悉，可以选择React。如果团队对Vue比较熟悉，可以选择Vue。
*   **社区活跃度**：React和Vue都拥有非常活跃的社区，但React的社区规模更大，第三方库更丰富。
*   **学习成本**：Vue的学习曲线相对平缓，更容易上手。React的学习曲线相对陡峭，需要掌握JSX、函数式编程等概念。

#### 4.2.3 系统性复盘所有项目经验，提炼亮点与难点

在面试前，需要对所有项目经验进行系统性复盘，并提炼出其中的亮点和难点。

**亮点**：亮点是指项目中取得的突出成果，例如：
*   通过性能优化，将页面加载速度提升了50%。
*   通过引入微前端架构，解决了团队协作和部署的难题。
*   通过开发自定义组件，丰富了低代码平台的组件库。

**难点**：难点是指项目中遇到的挑战和解决方案，例如：
*   如何解决微前端应用之间的样式冲突问题。
*   如何设计一套高效的WebSocket心跳和重连机制。
*   如何优化低代码平台的渲染性能。

在面试中，通过讲述这些亮点和难点，可以充分展示自己的技术能力和解决问题的能力。

### 4.3 简历优化与面试技巧

#### 4.3.1 如何根据目标JD优化简历，突出项目经验

简历是面试的敲门砖，一份好的简历可以让你在众多候选人中脱颖而出。在撰写简历时，需要根据目标JD（Job Description）进行优化，突出与职位要求相关的项目经验和技术技能。

*   **关键词匹配**：仔细阅读JD，找出其中的关键词，并在简历中突出这些关键词。例如，如果JD中提到了“微前端”，那么在简历中就应该重点描述自己的微前端项目经验。
*   **量化成果**：在描述项目经验时，尽量使用数据来量化自己的成果。例如，可以说“通过优化，将页面加载速度提升了30%”，而不是“参与了性能优化工作”。
*   **突出亮点**：将与目标职位最相关的项目经验放在最前面，并用加粗或下划线等方式突出其中的亮点。

#### 4.3.2 行为面试问题（STAR法则）的准备与演练

行为面试问题旨在通过了解候选人过去的行为，来预测其未来的表现。在回答行为面试问题时，可以使用STAR法则来组织自己的回答。

*   **S（Situation）** ：描述事件的背景和情况。
*   **T（Task）** ：描述自己需要完成的任务。
*   **A（Action）** ：描述自己采取的具体行动。
*   **R（Result）** ：描述行动带来的结果。

例如，当被问到“请描述一个你解决过的最困难的技术问题”时，可以使用STAR法则来回答：
*   **S**：在XX项目中，我们遇到了一个严重的性能问题，页面加载速度非常慢，用户体验很差。
*   **T**：我的任务是找出性能瓶颈，并进行优化，将页面加载速度提升到一个可接受的水平。
*   **A**：我首先使用Chrome DevTools对页面进行了性能分析，发现是由于首页加载了大量的图片和JS文件。然后，我采取了以下措施：对图片进行了懒加载和压缩，对JS文件进行了代码分割和Tree Shaking，并使用了CDN来加速资源的加载。
*   **R**：通过这些优化，我们将首屏加载时间从5秒降低到了2秒，用户满意度得到了显著提升。

#### 4.3.3 技术面试中的沟通技巧与问题拆解方法

在技术面试中，良好的沟通技巧和问题拆解方法同样重要。

*   **沟通技巧**：
    *   **清晰表达**：在回答问题时，要思路清晰，语言简洁，避免使用模糊不清的词语。
    *   **主动沟通**：如果遇到不懂的问题，可以主动向面试官提问，或者说出自己的思考过程。
    *   **保持自信**：在面试过程中，要保持自信，展现出自己的专业能力和热情。

*   **问题拆解方法**：
    *   **理解问题**：在回答问题之前，要确保自己完全理解了问题的含义。可以向面试官复述一遍问题，以确认自己的理解是否正确。
    *   **拆解问题**：将复杂的问题拆解成多个小问题，逐个解决。
    *   **给出方案**：在给出解决方案时，要说明自己的思路，并分析不同方案的优缺点。

### 4.4 模拟面试与求职策略

#### 4.4.1 进行模拟面试，查漏补缺

在正式面试之前，可以进行几次模拟面试，以熟悉面试流程，发现自己的不足之处。可以请朋友或同事扮演面试官，或者使用一些在线的模拟面试平台。

在模拟面试后，要认真复盘，总结自己的表现，找出需要改进的地方。例如，哪些技术问题回答得不够好，哪些项目经验描述得不够清晰，哪些沟通技巧需要提升等。

#### 4.4.2 制定合理的求职策略与面试节奏

在求职过程中，需要制定合理的求职策略和面试节奏。

*   **求职策略**：
    *   **广撒网**：在求职初期，可以多投递一些简历，以增加面试机会。
    *   **重点突破**：在收到面试邀请后，要对目标公司进行深入了解，并针对性地进行准备。
    *   **保持耐心**：求职是一个漫长的过程，需要保持耐心，不要因为几次失败而气馁。

*   **面试节奏**：
    *   **合理安排时间**：不要安排过多的面试，以免精力不济。
    *   **留出准备时间**：在面试前，要留出足够的时间进行准备。
    *   **及时复盘**：在面试后，要及时进行复盘，总结经验教训。

#### 4.4.3 面试后的复盘与总结

每次面试后，都要进行复盘和总结，以不断提升自己的面试能力。

*   **记录问题**：将面试中遇到的问题记录下来，并进行深入研究。
*   **反思表现**：反思自己在面试中的表现，找出需要改进的地方。
*   **总结经验**：总结面试中的成功经验，并在后续的面试中加以应用。