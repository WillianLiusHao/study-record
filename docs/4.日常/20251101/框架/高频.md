Vue 作为前端主流框架，面试 / 笔试中的高频考点集中在**核心原理、组件化、响应式、生命周期、性能优化、Vue2/Vue3 差异**等方向，以下按「基础必问」「原理深挖」「实战应用」「Vue3 新特性」四大维度梳理高频考点，附核心答案和考察思路：

### 一、基础必问考点（入门级，必考）

#### 1. Vue 核心特性

- **考察问题**：Vue 的核心特性有哪些？

- 核心答案：

  - 数据驱动（MVVM 思想，数据变化自动更新视图）；
  - 组件化（独立可复用的 UI 单元，单文件组件 SFC）；
  - 双向绑定（v-model 语法糖，Vue2 `Object.defineProperty`/Vue3 `Proxy`）；
  - 指令系统（v-if/v-for/v-bind/v-on 等，简化 DOM 操作）；
  - 生命周期（组件从创建到销毁的完整流程）；
  - 混入（Mixin）/ 插件（Plugin）（逻辑复用）。

#### 2. 生命周期（Vue2/Vue3 对比）

- 考察问题：

  - Vue2 生命周期钩子有哪些？执行顺序？
  - created 和 mounted 的区别？
  - Vue3 组合式 API 中生命周期如何变化？

#### 3. v-if vs v-show

- **考察问题**：v-if 和 v-show 的区别？使用场景？

- 核心答案

  - 底层逻辑：v-if 是**条件渲染**（满足条件才创建 DOM，不满足则销毁）；v-show 是**样式切换**（始终创建 DOM，通过 `display: none` 控制显示 / 隐藏）。
  - 性能消耗：v-if 切换有**编译 / 挂载 / 销毁开销**，初始渲染开销低；v-show 初始渲染开销高，切换开销低。
  - 使用场景：v-if 适用于**低频切换**（如权限控制）；v-show 适用于**高频切换**（如 Tab 切换）。
  - 额外：v-if 可以和 v-else/v-else-if 配合，v-show 不支持；v-if 优先级高于 v-for（Vue2 中不建议同用，Vue3 修复了优先级问题）。

#### 4. v-for 关键问题

- 考察问题

  - v-for 为什么要加 key？key 的作用？
  - v-for 和 v-if 同用的问题？
  
- 核心答案

  - key 的作用：作为 DOM 节点的唯一标识，Vue 基于 key 做**diff 算法优化**，避免错误的 DOM 复用（如列表乱序、数据更新异常）；key 推荐用唯一 id，而非 index（index 会随列表变化，失去唯一标识意义）。
- v-for 与 v-if 同用（Vue2）：v-for 优先级更高，会先遍历所有元素再判断 v-if，导致**性能浪费**；解决方案：外层套 template 用 v-if，或用 computed 过滤列表。

#### 5. 双向绑定原理（Vue2/Vue3）

- **考察问题**：Vue 的双向绑定原理？Vue2 和 Vue3 的区别？

- 核心答案

  - 核心思想：**数据劫持 + 发布 - 订阅模式**。
  - Vue2 实现：
    1. 用 `Object.defineProperty` 劫持 data 中所有属性的 getter/setter；
    2. 模板编译时，解析指令 / 插值表达式，为每个依赖创建 Watcher；
    3. getter 中收集依赖（Watcher 加入 Dep），setter 中触发 Dep 通知所有 Watcher 更新视图。
  - Vue3 实现：
    1. 用 `Proxy` 代理整个响应式对象（而非单个属性），支持数组 / 新增属性的劫持；
    2. 结合 `Reflect` 实现属性操作的拦截，解决 `Object.defineProperty` 的局限性；
    3. 引入 Reactive Effect 替代 Watcher，基于副作用函数实现依赖收集。
  - 局限性对比：Vue2 无法监听数组下标修改 / 对象新增属性（需用 Vue.set）；Vue3 Proxy 天然支持。

### 二、原理深挖考点（中高级，区分度高）

#### 1. Vue 响应式原理深度拆解

- 考察问题

  - 为什么 Vue2 无法监听数组的 push/pop 等方法？如何解决？
  - Dep 和 Watcher 的关系？
  - Vue3 的响应式系统（Reactive/Ref/Effect）原理？
  
- 核心答案

  - Vue2 数组问题：`Object.defineProperty` 只能劫持对象属性，无法劫持数组下标；Vue2 对数组的 7 个变异方法（push/pop/shift/unshift/splice/sort/reverse）做了重写，触发视图更新；但直接修改下标（如 arr [0] = 1）仍无法监听，需用 `Vue.set(arr, 0, 1)`。
  - Dep & Watcher：Dep（依赖管理器）对应单个响应式属性，Watcher 对应单个视图依赖；一个 Dep 可包含多个 Watcher（一对多），一个 Watcher 可依赖多个 Dep（多对一）；数据更新时，Dep 遍历所有 Watcher 执行 update。
  - Vue3 响应式：
    - Reactive：针对对象，返回 Proxy 代理对象；
    - Ref：针对基本类型，包装为 {value: xxx} 的对象，通过 getter/setter 劫持；
    - Effect：副作用函数，执行时收集依赖（track），依赖变化时重新执行（trigger）。

#### 2. Vue 虚拟 DOM & Diff 算法

- 考察问题

  - 为什么需要虚拟 DOM？
  - Vue 的 Diff 算法核心逻辑？
  - Key 在 Diff 中的作用？
  
- 核心答案

  - 虚拟 DOM 意义：用 JS 对象描述 DOM 结构，避免直接操作真实 DOM（开销大）；跨平台（可渲染到小程序 / Canvas 等）；批量更新，减少 DOM 操作次数。
  - Vue Diff 核心（同级比较，非跨层级）：
    1. 先判断节点类型，类型不同直接销毁旧节点创建新节点；
    2. 类型相同则对比属性（props/class/style），更新差异；
    3. 列表对比（v-for）：用 key 建立新旧节点的映射，采用**双指针法**（头头 / 尾尾 / 头尾 / 尾头）快速匹配，减少移动 / 删除操作；
    4. 无法匹配时，用 key 生成的映射表查找，找不到则创建新节点，最后处理剩余节点。
  - Key 的作用：让 Diff 算法快速定位相同节点，避免不必要的 DOM 移动 / 重建，提升列表更新性能。

#### 3. 组件通信方式（全场景）

- **考察问题**：Vue 有哪些组件通信方式？适用场景？

- 核心答案

  | 通信方式                  | 适用场景                   | 核心用法                            |
  | ------------------------- | -------------------------- | ----------------------------------- |
  | props/$emit               | 父子组件                   | 父传子用 props，子传父用 $emit      |
  | *p**a**re**n**t*/children | 父子组件（直接访问）       | 子组件 this.$parent 访问父实例      |
  | $refs                     | 父访问子组件（DOM / 实例） | 父组件 ref="xxx" → this.$refs.xxx   |
  | provide/inject            | 跨层级组件（祖孙）         | 父 provide 提供数据，子 inject 注入 |
  | Vuex/Pinia                | 全局状态管理（任意组件）   | 集中式存储，响应式共享              |
  | EventBus                  | 任意组件（小型项目）       | 新建 Vue 实例作为事件中心           |
  | *a**tt**rs*/listeners     | 跨层级透传（祖孙）         | 父传子未声明的 props 存入 $attrs    |
  
  - 补充：Vue3 中 $attrs 包含 class/style，Vue2 不包含；Pinia 替代 Vuex 成为官方推荐，更轻量、支持 TypeScript。

#### 4. Mixin 原理 & 优缺点（延伸到 Composition API）

- 考察问题

  - Mixin 的合并规则？
  - Mixin 的缺点？为什么 Vue3 推荐 Composition API？
  
- 核心答案

  （结合前文原理）：

  - 合并规则：生命周期钩子数组合并（混入先执行），data / 方法同名覆盖（组件 > 混入），watch 数组合并（混入先执行）；
  - Mixin 缺点：命名冲突、逻辑来源模糊、不支持参数；
  - Composition API 优势：函数式组合，逻辑来源清晰；支持参数传递；无命名冲突；更好的 TypeScript 支持。

#### 5. 异步更新队列（$nextTick 原理）

- 考察问题

  - Vue 的异步更新原理？为什么需要 $nextTick？
  - $nextTick 的实现方式？
  
- 核心答案

  - 异步更新原因：Vue 为提升性能，将数据更新的视图更新操作**批量延迟执行**，而非同步更新；数据变化时，Watcher 标记为脏，放入异步队列，等待下一个事件循环执行更新。
  - $nextTick 作用：等待异步更新队列执行完成后执行回调，保证获取到更新后的 DOM。
  - 实现方式：优先使用微任务（Promise.then > MutationObserver），降级到宏任务（setTimeout）；Vue3 中统一使用 Promise。

### 三、实战应用考点（工程化 / 性能 / 问题排查）

#### 1. Vue 性能优化手段

- **考察问题**：Vue 项目有哪些性能优化方式？

- 核心答案

  - 代码层面：
    1. 合理使用 v-if/v-show，避免 v-for 与 v-if 同用；
    2. 列表优化：key 用唯一 id，大数据列表用虚拟列表（vue-virtual-scroller）；
    3. 响应式优化：非响应式数据不放入 data（用 Object.freeze 冻结）；
    4. 计算属性缓存：用 computed 替代方法（避免重复执行）；
    5. 异步组件：路由 / 组件按需加载（const Comp = () => import ('./Comp.vue')）。
  - 工程化层面：
    1. 打包优化：Tree-Shaking、CDN 引入第三方库、压缩代码；
    2. 懒加载：路由懒加载、图片懒加载（v-lazy）；
    3. 缓存优化：keep-alive 缓存组件（避免重复渲染）；
    4. 服务端优化：SSR（Nuxt.js）提升首屏加载速度。
  - 进阶优化：
    1. 自定义指令封装高频 DOM 操作；
    2. 避免过度响应式：Vue3 中用 shallowReactive/shallowRef；
    3. 事件解绑：组件销毁前解绑自定义事件，避免内存泄漏。

#### 2. keep-alive 原理 & 应用

- **考察问题**：keep-alive 的作用？原理？激活 / 失活钩子？

- 核心答案

  - 作用：缓存组件实例，避免重复创建 / 销毁，提升切换性能（如 Tab 切换）。
  - 原理：
    1. keep-alive 是抽象组件（不渲染真实 DOM），内部维护一个缓存对象（cache），存储组件实例；
    2. 组件首次渲染时存入 cache，再次渲染时直接从 cache 取出，不执行 created/mounted 钩子；
    3. 可通过 include/exclude 属性指定缓存 / 排除的组件，max 属性限制缓存数量（LRU 策略）。
  - 钩子：缓存组件激活时触发 `activated`，失活时触发 `deactivated`（Vue3 中对应 onActivated/onDeactivated）。

#### 3. 路由相关（Vue Router）

- 考察问题

  - 路由守卫有哪些？执行顺序？
  - 路由懒加载如何实现？
  - hash 模式 vs history 模式的区别？
  
- 核心答案

  - 路由守卫分类：
    1. 全局守卫：beforeEach（前置）、beforeResolve（解析前）、afterEach（后置）；
    2. 路由独享守卫：beforeEnter；
    3. 组件内守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave；
  - 执行顺序：全局 beforeEach → 路由 beforeEnter → 组件 beforeRouteEnter → 全局 beforeResolve → 全局 afterEach。
  - 路由懒加载：结合 import () 动态导入，如 `{ path: '/home', component: () => import('./Home.vue') }`，打包时拆分 chunk，减小首屏体积。
  - 模式区别：
    - hash 模式：基于 URL hash（#），兼容性好，无需后端配置；
    - history 模式：基于 HTML5 History API，URL 无 #，需后端配置（nginx 重定向到 index.html），避免刷新 404。

#### 4. 常见问题排查

- 考察问题

  - 为什么 data 必须是函数？
  - 组件中修改 props 会报错？如何解决？
  - 子组件无法更新父组件数据？
  
- 核心答案

  - data 是函数：组件复用时，函数返回新的对象，避免多个实例共享同一数据（如果是对象，所有实例会修改同一个对象）；
  - 修改 props 报错：props 是单向数据流（父传子），子组件不能直接修改；解决方案：子组件通过 $emit 通知父组件修改，或在子组件中定义 data 接收 props 作为初始值；
  - 子组件更新父组件数据：通过 $emit 触发父组件方法，由父组件修改数据（单向数据流原则）。

### 四、Vue3 核心新特性（高频新增考点）

#### 1. Composition API 核心

- 考察问题

  - setup 函数的作用？执行时机？
  - Reactive vs Ref 的区别？使用场景？
  - Computed & Watch 的用法变化？
  
- 核心答案

  - setup：组件的入口，替代选项式 API（data/methods 等）；执行时机在 beforeCreate 之前，this 为 undefined；返回对象 / 函数（渲染函数）。
  - Reactive vs Ref：
    - Reactive：代理对象，仅支持对象 / 数组，不能代理基本类型；
    - Ref：包装基本类型为 {value: xxx}，对象类型内部会调用 reactive；模板中访问 ref 无需 .value（自动解包），js 中需 .value。
  - Computed/Watch：
    - Computed：支持传入 getter/setter，返回 ref 对象；
    - Watch：支持监听多个源，支持深度监听（deep）、立即执行（immediate），返回停止监听的函数。

#### 2. Vue3 架构变化

- **考察问题**：Vue3 为什么用 TS 重构？架构上的优化？

- 核心答案

  - TS 重构：提升类型安全，支持更好的 TypeScript 集成，降低维护成本；
  - 架构优化：
    1. 模块化拆分（如 reactivity 模块可独立使用）；
    2. 编译优化（PatchFlags 标记动态节点，减少 Diff 范围）；
    3. 体积优化（Tree-Shaking 支持，按需引入功能）。

#### 3. Teleport（瞬移组件）

- **考察问题**：Teleport 的作用？使用场景？

- 核心答案

  - 作用：将组件的 DOM 结构渲染到指定的 DOM 节点下（如 body），但组件的逻辑仍属于当前组件；
- 场景：弹窗 / 模态框（避免父组件样式溢出 / 层级问题）。

#### 4. Suspense 组件

- **考察问题**：Suspense 的作用？如何使用？

- 核心答案

  - 作用：等待异步组件加载完成前显示 fallback 内容（如加载中），提升用户体验；
- 使用：包裹异步组件，通过 default 插槽放异步组件，fallback 插槽放加载提示。

### 总结

Vue 高频考点可归纳为：

1. **基础概念**：生命周期、指令、双向绑定；
2. **核心原理**：响应式、虚拟 DOM/Diff、异步更新、Mixin；
3. **实战应用**：组件通信、性能优化、路由、工程化；
4. **Vue3 升级**：Composition API、架构优化、新组件（Teleport/Suspense）。

备考时需结合「原理理解 + 代码实践」，不仅要记结论，还要理解底层逻辑（如 Diff 算法、响应式劫持），并能结合实际项目场景分析问题（如性能优化、通信方式选型）。