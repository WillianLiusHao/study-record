## 1. 响应式原理

```js
1. new Vue()
2. Observer：劫持监听所有的属性 通知变化 Dep -> Watcher -> 视图更新 Updater
3. Compiler：订阅数据变化 Watcher
```

```js
class Vue {
  constructor(options) {
    this.$options = options
    this.$data = options.data

    observe(this.$data) // 对data进行响应式处理

    proxy(this) // data数据代理到vm

    // 编译
    new Compiler(this.$options.el, this)
  }
}

function observe(obj) {
  if (typeof obj !== 'object') {
    return
  }

  new Observer(obj)
}

class Observer {
  constructor(val) {
    this.val = val
    this.walk(val)
  }

  walk (obj) {
    Object.keys(obj).forEach(key => {
      defineReactive(obj, key, obj[key])
    })
  }
}

class Compiler {
  constructor(el, vm) {
    this.$vm = vm
    this.$el = document.querySelector(el)
    if (this.$el) {
      this.complie(this.$el)
    }
  }
}

complie(el) {
  const childNodes = el.childNodes;
  Array.from(childNodes).forEach(node => {
    if (this.isElement(node)) {
      // complie 编译node节点
      // node.nodeType 1
    } else if (this.isInterpolation(node)) {
      // {{ a }}
      // complie 解析插值文本
    }
    if (node.childNodes && node.childNodes.length > 0) {
      // 递归
      this.complie(node)
    }
  })
}
```

1. defineReactive： 对data中的每个key，创建 Dep 依赖实例
2. 当页面获取key(比如name)相关节点，就会针对 name 创建 watcher
3. 当name被读取时候（getter），就是将 watcher 添加到 name的 Dep
4. 当name变化（setter），根据 name 的 Dep 触发 watcher 更新

## 依赖收集

依赖
<p>{{name1}}</p>
<p>{{name2}}</p>
<p>{{name3}}</p>

key = name2 Watcher2
key = name3 Watcher3

Dep1 deps = [Watcher1, Watcher3]
Dep2 deps = [Watcher2]

1. defineReactive 为 key 创建 Dep 实例
2. key = name1 Watcher1
3. getter name1 Watcher1 添加到 name1 的 Deps
4. setter Deps 通知 watcher 进行更新

```js
class Watcher {
  constructor(vm, key, updater) {
    this.vm = vm
    this.key = key
    this.updateFn = updater

    // 创建实例的时候，把当前的实例制定到Dep.target
    Dep.target = this
    vm[key]
    Dep.target = null
  }
  // 更新DOM
  update() {
    this.updateFn.call(this.vm, this.vm[this.key])
  }
}

// 声明Dep
class Dep {
  constructor() {
    this.deps = []
  }
  addDep(dep) {
    this.deps.push(dep)
  }
  notify() {
    this.deps.forEach((dep) => dep.update())
  }
}

function defineReactive(obj, key, val) {
  const dep = new Dep()
  Object.definedProperty(obj, key {
    get() {
      Dep.target && dep.addDep(Dep.target) // Dep.target 就是watcher实例
    },
    set(newVal) {
      if (mewVal = val) return
      dep.notify()
    }
  })
}
```



## 2.nextTick

```js
export function nextTick(cb?: Function, ctx?: Object) {
    let _resolve;
    
    // callbacks 异步队列数组
    callbacks.push(() => {
        if(cb) {
            try {
                cb.call(ctx)
            } catch(e) {
				handleError(e)
            }
        } else if (_resolve) {
			_resolve()	
        }
    })
    
    // 执行异步延迟函数 timerFunc
    if (!pending) {
		pending = true
        timerFunc()
    }
    
    if (!cb && typeof Promise !== 'undefined') {
		return new Promise(resolve => {
			_resolve = resolve
        })
    }
}

// timerFunc的降级处理
export let isUsingMicroTask = false
if (typeof Promise !== 'undefined' && isNative(Promise)) {
	// 1.是否支持原生Promise
    const p = Promise.resolve()
    timerFunc = () => {
        p.then(flushCallbacks)
    }
    isUsingMicroTask = true
} else if (typeof MutationObserver !== 'undefined' && isNative(MutationObserver)) {
    // 2. 是否原生支持 MutationObserver
    timerFunc = () => {...}
    isUsingMicroTask = true
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
    // 3. 是否原生支持 setImmediate
    timerFunc = () => {
        setImmediate(flushCallbacks)
    }
    isUsingMicroTask = true
} else {
    // 4. 都不行就直接用 setTimeout
    timerFunc = () => {
        setTimeout(flushCallbacks, 0)
    }
}

```



## 3. SPA实现

### hash 模式

```js
class Router {
    constructor() {
        this.routes = {};
        this.currentUrl = '';
        
        window.addEventListener('load', this.refresh)
        window.addEventListener('hashChange', this.refresh)
    }
    route(path, cb) {
        this.routes[path] = cb
    }
    push(path) {
        this.routes[path] && this.routes[path]()
    }
}

// 使用
window.miniRouter = new Router()
miniRouter.route('/', () => {console.log('page1')})
miniRouter.route('/page2', () => {console.log('page2')})

miniRouter.push('/')
miniRouter.push('page2')
```

### history 模式

```js
class Router {
    constructor() {
        this.routes = {}
        this.listenPopState()
    }
    init(path) {
        history.replace({ path }, null, path)
        this.routes[path] && this.routes[path]()
    }
    route(path, cb) {
        this.routes[path] = cb
    }
    push(path) {
        history.pushState({ path }, null, path)
        this.routes[path] && this.routes[path]()
    }
    listenPopState() {
        window.addEventListener('popState', e => {
            const path = e.state.path
            this.routes[path] && this.routes[path]()
        }
    }
}
    
// 使用
window.miniRouter = new Router()
miniRouter.route('/', () => {console.log('page1')})
miniRouter.route('/page2', () => {console.log('page2')})

miniRouter.push('page2')
```



