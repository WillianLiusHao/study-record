# 一、前端监控 SDK 面试考点、难点与亮点梳理

在面试中，前端监控 SDK 相关问题会围绕 **技术实现原理、工程化能力、问题解决思路、性能优化** 四个核心维度展开。以下从考点、难点、亮点三部分系统梳理，帮你精准应对面试。

## 一、核心考点：基础与原理（必须掌握）

这部分是面试高频提问区，重点考察你对监控 SDK“是什么、能做什么、怎么实现” 的基础认知，需结合项目细节展开。

### 1. 监控 SDK 的核心功能模块

面试官会先确认你对监控范围的理解，需清晰拆解核心模块，避免遗漏关键场景：

- **错误监控：覆盖前端所有错误类型，需说明 “监控什么、怎么监控、如何上报”。**
  - 语法错误 / 运行时错误：通过`window.onerror`捕获（注意跨域脚本错误需配置`crossorigin`和`source-map`）。
  - 资源加载错误：通过`window.addEventListener('error', (e) => { if(e.target instanceof HTMLElement) { ... } })`捕获（区分 JS 错误和资源错误）。
  - Promise 错误：通过`window.addEventListener('unhandledrejection', (e) => { ... })`捕获（避免错误静默失败）。
  - React/Vue 框架错误：React 用`componentDidCatch`（类组件）或`ErrorBoundary`（函数组件），Vue 用`app.config.errorHandler`。
- **性能监控：基于 Web Performance API，需明确 “监控哪些指标、指标含义、计算方式”。**
  - 核心 Web 指标（Core Web Vitals）：LCP（最大内容绘制，衡量加载速度）、FID（首次输入延迟，衡量交互响应）、CLS（累积布局偏移，衡量视觉稳定性）。
  - 传统性能指标：FP（首次绘制）、FCP（首次内容绘制）、TTI（首次可交互时间）、TTFB（首字节时间，需结合服务端分析）。
  - 自定义性能：接口请求耗时（拦截`XMLHttpRequest`/`fetch`）、页面跳转耗时、组件渲染耗时。
- **行为监控：记录用户操作，用于分析用户路径和问题复现，需说明 “监控场景、数据脱敏”。**
  - 页面埋点：PV/UV（基于`visibilitychange`判断页面可见性，避免重复统计）、页面停留时间（记录`pagehide`与`pageshow`时间差）。
  - 用户操作：点击事件（代理到`document`，过滤非用户触发的点击）、输入行为、路由跳转（监听`hashchange`/`popstate`或框架路由钩子）。
- **异常上报：确保数据 “能上报、不丢包、不影响主流程”，需说明上报策略。**
  - 上报方式：异步`img`标签（兼容性最好，无跨域问题）、`fetch`（支持更多配置，需处理跨域）。
  - 数据格式：包含`错误类型、错误信息、堆栈、时间戳、设备信息（UA）、页面URL、环境变量（生产/测试）`等核心字段。

### 2. 关键技术原理（高频提问）

需结合项目中实际使用的方案，解释 “为什么这么做”，而非单纯背概念：

- **错误堆栈解析：**

  - 原生错误堆栈包含文件路径、行号，但压缩后的代码需结合`source-map`还原真实代码位置（项目中是否实现了`source-map`解析？是前端解析还是后端解析？）。
  - 跨域脚本错误（`Script error`）的解决：1. 脚本标签添加`crossorigin="anonymous"`；2. 服务端响应头添加`Access-Control-Allow-Origin`。

- **性能指标计算：**

  - 基于`performance.timing`（旧标准）或`performance.getEntriesByType('navigation')`（新标准，Navigation Timing API v2）计算 FP/FCP/TTI。

  - LCP 监控：通过

    ```js
    new PerformanceObserver((entryList) => { ... }).observe({ type: 'largest-contentful-paint', buffered: true })
    ```

    实时监听最大内容元素。

- **请求拦截：**

  - 拦截`XMLHttpRequest`：重写`XMLHttpRequest.prototype.open`和`XMLHttpRequest.prototype.send`，记录请求开始 / 结束时间，计算耗时。
  - 拦截`fetch`：重写`window.fetch`，包装`Promise`，在`then/catch`中记录请求结果和耗时。

- **数据防抖 / 节流：**

  - 高频事件（如滚动、resize）监控需节流（如 100ms 一次），避免生成大量冗余数据；
  - 上报队列需防抖（如 500ms 批量上报一次），减少 HTTP 请求次数，降低性能消耗。

### 3. 工程化与兼容性

考察你对 “SDK 产品化” 的思考，而非单纯的技术实现：

- **兼容性处理：**
  - 低版本浏览器（如 IE11）不支持`PerformanceObserver`/`fetch`，如何降级？（如用`performance.timing`替代、用`XMLHttpRequest`模拟`fetch`）。
  - 不同框架（React/Vue/Angular）的错误监控适配方案（项目中是否做了多框架兼容？）。
- **SDK 体积与加载：**
  - SDK 体积优化：Tree-shaking（排除未使用的模块）、代码压缩（Terser）、按需加载（如行为监控模块可配置关闭）。
  - 加载方式：异步加载（避免阻塞主流程）、动态插入脚本（如`document.createElement('script')`），是否考虑 “首屏加载时不加载 SDK，避免影响首屏性能”？
- **配置化设计：**
  - SDK 是否支持自定义配置？（如`{ enableError: true, enablePerformance: false, reportUrl: 'xxx' }`），方便业务方按需开启模块。
  - 是否支持钩子函数？（如`beforeReport: (data) => { ... }`，允许业务方自定义过滤 / 修改上报数据）。



## 二、项目难点：体现问题解决能力

面试官会重点关注 “你在项目中遇到了什么问题、怎么解决的”，需结合具体场景，说明 “痛点 - 方案 - 效果”，避免泛泛而谈。

### 1. 数据准确性问题（最常见难点）

- **痛点 1：错误重复上报**

  同一错误（如循环中的错误）可能触发多次 `onerror` 导致重复上报，污染数据。

  解决方案：用 “错误唯一标识” 去重（如 `错误信息+堆栈+URL` 哈希值），记录已上报的错误 ID，30 分钟内同一 ID 不再上报。

- **痛点 2：性能指标计算偏差**

  如 LCP 在 “图片懒加载” 场景下，真实 LCP 元素加载延迟，导致监控到的 LCP 值偏小。

  解决方案：延长 LCP 监听时间（如页面加载后 5s 内仍监听），或结合 `load` 事件后再修正 LCP 值；排除非关键元素（如隐藏的图片）。

- **痛点 3：跨域脚本错误无法获取堆栈**

  即使配置了 `crossorigin`，部分 CDN 脚本仍可能因响应头问题导致错误堆栈为空。

  解决方案：前端通过 “错误边界”（如 React ErrorBoundary）在框架层捕获错误，补充上下文信息（如组件名、props），提升错误可复现性。

### 2. 性能影响问题（SDK 的 “自我修养”）

- **痛点 1：SDK 自身消耗主进程资源**

  高频监控（如行为监控、滚动监控）可能导致主线程阻塞，影响页面性能。

  解决方案：

  1. 监控逻辑用 `requestIdleCallback`（空闲时执行）
  2. 复杂计算（如堆栈解析）移交 Web Worker，避免阻塞主线程
  3. 可配置 “采样率”（如 10% 用户开启详细监控），降低整体消耗。

- **痛点 2：上报请求占用网络带宽**

  大量上报数据（如行为日志）可能挤占业务接口带宽，导致业务请求延迟。

  解决方案：

  1. 批量上报（如 10 条数据合并一次上报）
  2. 压缩上报数据（如用 gzip，或自定义二进制格式）
  3. 非关键数据（如行为日志）在弱网环境下延迟上报（监听 `navigator.connection.effectiveType` 判断网络类型）。

### 3. 复杂场景适配

- **痛点 1：单页应用（SPA）路由切换监控**

  SPA 路由切换不会触发 `pageshow` ，导致传统的 PV 统计、性能监控失效。

  解决方案：

  1. 监听框架路由钩子（如 React Router 的 `useEffect`、Vue Router 的 `afterEach`），在路由切换时重新初始化监控（如重新计算 FCP、重置错误计数器）
  2. 用 `performance.getEntriesByType('navigation')` 的 `type` 字段（`reload`/`navigate`/`back_forward`）区分路由类型。

- **痛点 2：iframe 嵌套页面监控**

  父页面无法直接捕获 iframe 内的错误和性能数据，导致监控盲区。

  解决方案：

  1. iframe 内注入 SDK，通过`postMessage`将数据传递给父页面，由父页面统一上报
  2. 父页面监听`iframe`的`load`事件，补充 iframe 的加载性能数据。



## 三、项目亮点：突出差异化优势

亮点是面试中的 “加分项”，需体现你对监控 SDK 的 “深度思考” 或 “创新实践”，避免停留在 “完成基础功能” 层面。

### 1. 技术层面：超越基础功能的优化

- **错误溯源与智能分析：**

  不只是上报错误堆栈，还能关联 “用户操作路径”（如错误发生前用户点击了哪个按钮、输入了什么内容）和 “环境信息”（如浏览器版本、设备型号、网络类型），帮助开发快速复现问题。例如：项目中实现了 “错误 - 操作日志” 关联，点击错误 ID 可查看前 10 步用户操作，复现率提升 60%。

- **性能瓶颈定位：**

  不只是上报性能指标，还能分析 “性能差的原因”。例如：结合`performance.getEntriesByType('resource')`分析资源加载耗时，识别出 “某张图片加载耗时 2s”，或 “某接口响应耗时 1.5s”，直接定位瓶颈点；甚至实现 “性能指标告警”（如 LCP>4s 时触发钉钉告警）。

- **动态配置与灰度发布：**

  实现 “远程配置中心”（如基于 Redis/MySQL），支持动态开启 / 关闭监控模块、调整采样率、更新上报地址，无需重新发布 SDK。例如：线上发现某模块有 bug，可通过配置中心实时关闭该模块，避免影响所有用户；新功能上线时先灰度 10% 用户，验证无问题后全量。

### 2. 工程化层面：体现产品化思维

- **SDK 可扩展架构**：

  采用 “插件化设计”，将错误监控、性能监控、行为监控拆分为独立插件，业务方可按需引入（如`import { ErrorPlugin, PerformancePlugin } from 'monitor-sdk'`），同时支持自定义插件（如业务方自己开发 “小程序监控插件”），提升 SDK 的灵活性。

- **数据可视化与平台联动：**

  不只做 “数据上报”，还参与 “监控平台” 的部分设计，例如：上报的数据在平台上支持 “错误趋势图”“性能分位数统计”“用户分布热力图”，甚至支持 “错误一键跳转至源码（如 GitHub）”“性能问题关联 Jira 工单”，打通 “监控 - 排查 - 修复” 链路。

- **隐私合规处理：**

  符合 GDPR / 国内《个人信息保护法》，实现 “数据脱敏” 和 “用户授权”。例如：

  1. 上报的用户输入内容（如表单）自动脱敏（替换手机号 / 邮箱为`*`）
  2. 提供`init({ enablePrivacy: true })`配置，用户拒绝授权时不采集行为数据，避免合规风险。

### 3. 业务价值层面：体现落地效果

亮点最终要回归 “业务价值”，用数据证明 SDK 的作用，例如：

- **错误排查效率：**SDK 上线后，前端错误平均排查时间从 2 小时缩短至 15 分钟，线上错误率下降 40%。
- **性能优化效果：**通过监控发现 LCP 瓶颈（某首屏图片未压缩），优化后 LCP 从 5s 降至 2.5s，首屏加载时间缩短 30%。
- **业务问题定位：**通过行为监控发现 “某支付按钮点击后无响应”，定位到是 IE 浏览器下的兼容性问题，修复后支付转化率提升 5%。

## 四、面试准备建议

1. **梳理项目细节**：明确你在 SDK 项目中负责的模块（如错误监控 / 性能上报），准备 1-2 个 “难点解决案例”（按 “痛点 - 方案 - 效果” 结构表述）。
2. **模拟问题回答**：针对高频考点（如错误捕获方式、SPA 监控、source-map 解析），提前组织语言，结合项目实际代码片段（如 “我们当时是这么重写 XMLHttpRequest 的：xxx”）。
3. **体现主动性**：主动提及 “你做的优化” 或 “未来可改进的方向”（如 “目前 SDK 在 Web Worker 内的错误监控还未覆盖，后续计划调研 Worker 错误捕获方案”），展现思考深度。





# 二、前端监控 SDK 高频面试题与回答模板

以下梳理**15 道高频面试题**，涵盖基础原理、难点解决、工程化、业务价值四大维度，每个问题配套 “回答模板”（含核心逻辑 + 项目结合点 + 加分项），帮你精准匹配面试场景，避免泛泛而谈。

## 一、基础原理类（必问，考察核心认知）

### 1. 前端监控 SDK 主要监控哪些内容？请分别说明实现思路。☆☆☆☆☆

**回答模板**：

前端监控 SDK 核心覆盖 4 类内容，我们项目中也是围绕这几块落地的：

1. **错误监控**：监控 JS 运行时错误、资源加载错误、Promise 错误、框架错误
   - 运行时 / 语法错误：用`window.onerror`捕获，注意过滤`script error`（需配置`crossorigin`和服务端 CORS 头）；
   - 资源错误：用`window.addEventListener('error', e => { if(e.target instanceof HTMLImageElement/HTMLLinkElement) { ... } })`，区分资源类型（图 / 样式 / 脚本）；
   - Promise 错误：用`window.addEventListener('unhandledrejection', e => { ... })`，避免静默失败；
   - 框架错误：React 用`ErrorBoundary`、Vue 用`app.config.errorHandler`，我们项目还适配了 Vue2/Vue3 双版本。
2. **性能监控**：重点监控 Core Web Vitals 和传统指标
   - 核心指标：LCP 用`PerformanceObserver`监听`largest-contentful-paint`类型，FID/CLS 同理；
   - 传统指标：FP/FCP/TTI 通过`performance.getEntriesByType('navigation')`（新标准）计算，旧浏览器降级用`performance.timing`；
   - 自定义性能：拦截`XHR/fetch`记录接口耗时，我们项目还加了 “组件渲染耗时”（React 用`useEffect`记录挂载时间）。
3. **行为监控**：用于问题复现，需做数据脱敏
   - PV/UV：用`visibilitychange`判断页面可见性，避免重复统计；停留时间记录`pageshow`和`pagehide`的时间差；
   - 用户操作：`document`代理点击事件，过滤非用户触发（如`dispatchEvent`），输入内容只记录长度不记录原文（合规要求）。
4. **异常上报**：确保不丢包、不影响主流程
   - 上报方式：优先用`img`标签（兼容性好），大体积数据用`fetch`（配`keep-alive`）；
   - 策略：批量上报（500ms 防抖）+ 失败重试（3 次，间隔指数退避），我们项目还加了 “离线缓存”（`localStorage`暂存，联网后补发）。

### 2. 如何解决 “跨域脚本错误（Script error）” 无法获取完整堆栈的问题？

**回答模板**：

跨域脚本错误的核心原因是 “浏览器安全策略限制”—— 跨域脚本执行错误时，为避免泄露敏感信息，只返回`Script error.`，不提供堆栈和行号。我们项目分两步彻底解决：

1. **第一步：突破浏览器限制，获取完整错误信息**

   - 脚本标签加 `crossorigin="anonymous"`：告诉浏览器 “该脚本允许跨域访问”；
   - 服务端配置 CORS 响应头：在 CDN 或静态资源服务器添加`Access-Control-Allow-Origin: *`（或指定业务域名），确保浏览器认可跨域权限。这一步做完后，`window.onerror`就能捕获到完整的错误堆栈（如`Uncaught ReferenceError: a is not defined at xxx.js:10`）。

2. **第二步：处理压缩代码的堆栈还原（关键补充）**

   线上代码通常经过压缩（如 Terser），堆栈中的行号是压缩后的位置，开发无法定位。我们项目的方案是：

   - 构建时生成`source-map`文件（只保留生产环境必要信息，排除注释），上传到内部服务器（不对外暴露）；
   - 错误上报时，携带 “压缩文件名 + 压缩后行号 / 列号”；
   - 后端（或监控平台）用`source-map`库（如`source-map` npm 包）解析，将压缩后的位置还原为源码位置，最终在平台上展示 “哪个文件的哪一行出了错”。

实际效果：跨域错误的可定位率从 0 提升到 95% 以上，排查效率大幅提升。

### 3. ~~单页应用（SPA）的监控和传统多页应用有什么区别？你是怎么适配 SPA 的？~~

**回答模板**：

SPA 和多页应用的核心区别是 “路由切换不刷新页面”，导致传统监控的 3 个关键问题：

- PV 统计不准（多页靠`pageshow`，SPA 路由切换不触发）
- 性能指标重复计算（如 FCP 只在首次加载时触发，路由切换后无法重新统计）
- 错误监控断档（路由切换后，旧页面的`onerror`监听可能被销毁）

我们项目针对 SPA 做了 3 点适配，以 React Router 为例：

1. **PV 统计与页面生命周期管理**
   - 监听路由钩子：在`useEffect`（或`history.listen`）中，路由切换时触发 “虚拟页面加载” 事件，重新初始化 PV 统计（记录新路由的`pageshow`时间）；
   - 页面停留时间：路由切换时，计算上一个路由的 “离开时间 - 进入时间”，上报停留时间，避免数据丢失。
2. **性能指标重新采集**
   - 路由切换后，重新监听 LCP/CLS：销毁上一个路由的`PerformanceObserver`，创建新实例，确保新页面的性能指标能被捕获；
   - 自定义 “路由切换耗时”：记录`history.push`触发时间和新组件`componentDidMount`（或`useEffect`）执行时间，计算路由切换的前端耗时（反映 SPA 的交互流畅度）。
3. **错误监控持续生效**
   - 全局错误监听（如`window.onerror`）不随路由销毁，但框架错误（如 React 组件错误）需确保`ErrorBoundary`在根组件层级，覆盖所有路由页面；
   - 路由切换时，清空上一个页面的 “错误去重缓存”（避免同一错误在不同路由下被误判为新错误）。

适配后，SPA 的监控数据和多页应用一致，能精准反映每个路由的错误、性能和用户行为。

### 4. 如何拦截 XHR/fetch 请求，实现接口耗时和错误的监控？☆☆☆

**回答模板**：

拦截请求的核心思路是 “重写原生方法，注入监控逻辑”，我们项目同时支持 XHR 和 fetch，方案如下：

#### （1）XHR 拦截：重写原型方法

```javascript
// 保存原生方法
const originalOpen = XMLHttpRequest.prototype.open;
const originalSend = XMLHttpRequest.prototype.send;

// 重写open：记录请求方法、URL
XMLHttpRequest.prototype.open = function(method, url) {
  this._monitor = { method, url, startTime: Date.now() }; // 挂载监控信息到XHR实例
  originalOpen.apply(this, arguments);
};

// 重写send：监听load/error/abort事件，记录结果和耗时
XMLHttpRequest.prototype.send = function(body) {
  const _this = this;
  // 监听请求完成
  this.addEventListener('load', function() {
    const endTime = Date.now();
    const data = {
      type: 'xhr',
      method: _this._monitor.method,
      url: _this._monitor.url,
      status: _this.status,
      duration: endTime - _this._monitor.startTime,
      isError: _this.status >= 400
    };
    report(data); // 上报数据
  });
  // 监听错误和中断
  this.addEventListener('error', handleError);
  this.addEventListener('abort', handleAbort);
  
  originalSend.apply(this, arguments);
};
```

#### （2）fetch 拦截：包装 Promise

```javascript
const originalFetch = window.fetch;
window.fetch = function(input, init = {}) {
  const url = typeof input === 'string' ? input : input.url;
  const method = init.method || 'GET';
  const startTime = Date.now();

  // 包装Promise，捕获成功/失败
  return originalFetch(input, init)
    .then(response => {
      // 复制response（避免被消费后无法读取）
      const clonedResponse = response.clone();
      const endTime = Date.now();
      const data = {
        type: 'fetch',
        method,
        url,
        status: response.status,
        duration: endTime - startTime,
        isError: response.status >= 400
      };
      // 如果是JSON响应，可额外记录响应体（需脱敏）
      clonedResponse.json().then(resBody => {
        data.responseBody = JSON.stringify(resBody).slice(0, 200); // 只取前200字符
        report(data);
      }).catch(() => report(data)); // 非JSON响应直接上报
      return response; // 不影响原业务逻辑
    })
    .catch(error => {
      const endTime = Date.now();
      report({
        type: 'fetch',
        method,
        url,
        duration: endTime - startTime,
        isError: true,
        errorMsg: error.message
      });
      throw error; // 抛出错误，不影响业务的catch逻辑
    });
};
```

#### （3）关键注意点

- 不破坏原生逻辑：所有重写都调用`apply`/`call`保留原生行为，避免影响业务代码；
- 处理异常场景：如 XHR 的`abort`、fetch 的网络错误，确保这些场景下也能上报；
- 数据脱敏：接口 URL 中的敏感参数（如手机号）需替换（如`/user/13800138000`→`/user/****`），响应体不记录完整信息，符合隐私合规。



## 二、难点解决类（区分度题，考察实战能力）

### 5. 如何避免 SDK 自身的代码影响页面性能？（如占用主线程、消耗带宽）☆☆☆

**回答模板**：

SDK 的核心原则是 “监控不添乱”，我们项目从 “执行、上报、体积” 三个维度做了优化，确保对页面性能的影响低于 1%：

1. **降低主线程占用：让监控逻辑 “不抢资源”**
   - 非紧急逻辑用`requestIdleCallback`：如行为日志的格式化、非核心指标（如滚动位置）的计算，只在浏览器空闲时执行，避免阻塞 JS 执行和页面渲染；
   - 复杂计算移交 Web Worker：如错误堆栈的解析（尤其是`source-map`还原）、大量日志的压缩，我们项目用 Worker 处理后，主线程占用率从 8% 降至 1% 以下；
   - 高频事件节流：如`resize`/`scroll`监控，用 100ms 节流，避免每秒触发几十次监控逻辑。
2. **减少网络消耗：让上报 “不占带宽”**
   - 批量上报：将零散的日志（如行为点击、小错误）缓存到内存队列，500ms 防抖批量上报一次，HTTP 请求数减少 80%；
   - 数据压缩：上报前用`pako`库将 JSON 数据压缩为 gzip 格式（体积减少 60%），服务端解压后解析；
   - 弱网适配：通过`navigator.connection.effectiveType`判断网络类型（如 2G/3G），弱网下延迟上报非关键数据（如行为日志），优先保证错误和性能数据上报。
3. **控制 SDK 体积：让加载 “不拖慢首屏”**
   - 插件化按需加载：将 SDK 拆分为 “核心上报模块”（必选，5KB）、“错误监控模块”（可选，3KB）、“行为监控模块”（可选，2KB），业务方只引入需要的模块；
   - Tree-shaking 优化：用 ES 模块（ESM）打包，配合 Webpack/Rollup 的 Tree-shaking，剔除未使用的代码（如不开启行为监控则不打包相关逻辑）；
   - 异步加载 SDK：业务方通过动态脚本插入（`document.createElement('script')`）加载 SDK，且放在`DOMContentLoaded`后执行，不阻塞首屏渲染。

我们还在内部做了性能压测：在低端机（如 iPhone 8）和弱网（3G）环境下，集成 SDK 后页面的 FCP 只延迟了 20ms，完全在可接受范围内。

### 6. 如何解决 “错误重复上报” 的问题？请举例说明。☆☆☆

**回答模板**：

错误重复上报的核心原因是 “同一错误触发多次监控事件”，比如：

- 循环中抛出的错误（每秒触发 10 次`onerror`）
- SPA 路由切换后，旧页面的错误监听未销毁，重复捕获同一错误
- 同一错误在不同生命周期（如`load`和`DOMContentLoaded`）被捕获

我们项目用 “**唯一标识去重 + 过期清理**” 的方案解决，具体分 3 步：

1. **生成错误的唯一标识（key）**

   基于 “错误的核心特征” 生成哈希值，确保同一错误的 key 唯一，不同错误的 key 不同。我们项目的 key 生成规则是：

   ```javascript
   function generateErrorKey(error) {
     // 核心特征：错误类型+错误信息+堆栈的关键行（前3行）+当前URL
     const errorType = error.name || 'UnknownError';
     const errorMsg = error.message || '';
     const stackKey = (error.stack || '').split('\n').slice(0, 3).join(''); // 取堆栈前3行，避免过长
     const url = window.location.href;
     // 用MD5生成短哈希（避免key过长）
     return md5(`${errorType}_${errorMsg}_${stackKey}_${url}`);
   }
   ```

2. **用 “去重缓存” 记录已上报的错误**

   用`localStorage`（持久化，避免页面刷新后失效）+ 内存对象（高效读取）维护去重缓存，结构如下：

   ```javascript
   // 内存缓存：记录当前页面已上报的错误key（页面关闭后清空）
   const inMemoryCache = new Set();
   // localStorage缓存：记录24小时内已上报的错误key（跨页面/刷新生效）
   const getLocalCache = () => JSON.parse(localStorage.getItem('monitor_error_cache') || '{}');
   const setLocalCache = (cache) => localStorage.setItem('monitor_error_cache', JSON.stringify(cache));
   
   // 检查错误是否已上报
   function isErrorReported(errorKey) {
     // 先查内存（快），再查localStorage（持久）
     if (inMemoryCache.has(errorKey)) return true;
     const localCache = getLocalCache();
     const now = Date.now();
     // 清理24小时前的过期缓存（避免localStorage膨胀）
     Object.keys(localCache).forEach(key => {
       if (now - localCache[key] > 24 * 60 * 60 * 1000) delete localCache[key];
     });
     setLocalCache(localCache);
     // 判断是否存在未过期的key
     if (localCache[errorKey]) return true;
     // 不存在则加入缓存
     inMemoryCache.add(errorKey);
     localCache[errorKey] = now;
     setLocalCache(localCache);
     return false;
   }
   ```

3. **上报前校验去重**

   在错误上报函数中加入校验，已上报的错误直接跳过：

   ```javascript
   function reportError(error) {
     const errorKey = generateErrorKey(error);
     if (isErrorReported(errorKey)) {
       console.log('重复错误，跳过上报', errorKey);
       return;
     }
     // 正常上报逻辑...
   }
   ```

实际效果：之前循环错误会上报 100 次，现在只上报 1 次；SPA 路由切换后的重复错误也被完全过滤，错误数据的准确性提升 90%。

### 7. 如何监控前端的 “白屏” 问题？白屏的常见原因有哪些？

**回答模板**：

白屏是前端严重的用户体验问题，核心是 “页面加载后，关键内容长时间未渲染”。我们项目从 “**白屏检测**” 和 “**原因定位**” 两方面实现监控：

#### （1）白屏检测方案：多维度判断

结合 “DOM 渲染状态” 和 “时间阈值”，避免误判（如首屏加载慢但未白屏）：

1. **DOM 维度**：监听`DOMContentLoaded`后，检查 “关键容器”（如`#app`）是否有子元素（排除空文本节点）；
2. **时间维度**：设置白屏阈值（如 5s），如果`load`事件触发后 5s，关键容器仍无有效内容，判定为白屏；
3. **视觉维度**：辅助判断（可选）—— 用`document.elementFromPoint(100, 100)`（取页面中间点），如果返回的元素是`html`/`body`或`null`，说明中间区域无内容。

核心代码逻辑：

```javascript
function checkWhiteScreen() {
  const criticalContainer = document.getElementById('app'); // 业务方配置的关键容器
  if (!criticalContainer) return; // 容器不存在，不检测

  // 检查容器是否有有效内容（排除空文本、注释节点）
  const hasContent = Array.from(criticalContainer.childNodes).some(node => {
    // 元素节点：有宽高或有子元素
    if (node.nodeType === 1) {
      const rect = node.getBoundingClientRect();
      return rect.width > 0 && rect.height > 0 || node.childNodes.length > 0;
    }
    // 文本节点：非空（排除空格）
    if (node.nodeType === 3) {
      return node.textContent.trim().length > 0;
    }
    return false;
  });

  // 时间阈值+DOM状态判断
  const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart;
  if (loadTime > 5000 && !hasContent) {
    // 判定为白屏，上报数据
    report({
      type: 'whiteScreen',
      loadTime,
      container: '#app',
      // 补充上下文：当前URL、浏览器版本、网络类型
      url: window.location.href,
      ua: navigator.userAgent,
      network: navigator.connection?.effectiveType
    });
  }
}

// 触发检测：load事件后1s（避免load刚触发时内容未渲染完）
window.addEventListener('load', () => setTimeout(checkWhiteScreen, 1000));
```

#### （2）白屏常见原因及定位

上报白屏时，我们还会关联 “其他监控数据”，帮助快速定位原因：

- 原因 1：JS 执行错误（如首屏渲染脚本报错，导致`#app`未挂载）→ 关联 “错误监控数据”，看白屏时间是否有 JS 错误；
- 原因 2：资源加载失败（如首屏 CSS/JS 加载超时）→ 关联 “资源错误数据”，看是否有`link`/`script`加载失败；
- 原因 3：接口返回异常（如首屏接口返回 500，导致数据为空）→ 关联 “接口监控数据”，看白屏前是否有接口错误；
- 原因 4：CSS 样式问题（如`#app`被设置`display: none`）→ 上报时记录关键容器的`computedStyle`（如`display`/`visibility`/`opacity`）。

实际案例：我们曾通过白屏监控发现，某活动页在 iOS 12 浏览器下白屏，关联错误数据后，定位到是 “ES6 语法未转译”（`const`未转成`var`），导致首屏 JS 报错。

## 三、工程化与架构类（考察深度，区分高级开发）

### 8. 你设计的 SDK 是如何实现 “可配置” 和 “可扩展” 的？请举例说明。

**回答模板**：

SDK 的可配置和可扩展是 “产品化” 的关键 —— 不同业务方的需求不同（如 A 业务要行为监控，B 业务只需要错误监控），且未来可能新增功能（如小程序监控）。我们项目用 “**配置中心 + 插件化架构**” 实现，具体如下：

#### （1）可配置：分层配置，满足不同需求

设计 “默认配置 + 业务配置 + 动态配置” 三层结构，优先级：动态配置 > 业务配置 > 默认配置：

1. **默认配置**：内置基础配置，业务方无需关心（如上报间隔 500ms，采样率 100%）；
2. **业务配置**：业务方初始化时传入，覆盖默认配置（如`init({ enableBehavior: false, sampleRate: 50 })`）；
3. **动态配置**：通过接口拉取远程配置（如从监控平台获取），实时生效（如线上发现问题，动态关闭某模块）。

配置项设计（核心部分）：

```javascript
const defaultConfig = {
  reportUrl: 'https://monitor.xxx.com/report', // 默认上报地址
  modules: {
    error: true, // 错误监控：默认开启
    performance: true, // 性能监控：默认开启
    behavior: false // 行为监控：默认关闭（避免隐私问题）
  },
  sampleRate: 100, // 采样率：默认100%（全量）
  batchInterval: 500, // 批量上报间隔：500ms
  beforeReport: (data) => data, // 上报前钩子：默认不处理
  whiteList: [] // 错误上报白名单：默认无（所有错误都上报）
};

// 初始化函数：合并配置
export function init(customConfig = {}) {
  // 1. 合并默认配置和业务配置
  const mergedConfig = { ...defaultConfig, ...customConfig };
  // 2. 拉取动态配置（异步，不阻塞初始化）
  fetch('https://monitor.xxx.com/config')
    .then(res => res.json())
    .then(dynamicConfig => {
      // 动态配置覆盖合并后的配置
      Object.assign(mergedConfig, dynamicConfig);
      // 重新初始化模块（如动态关闭错误监控）
      reInitModules(mergedConfig);
    });
  // 3. 初始化模块
  initModules(mergedConfig);
  return mergedConfig;
}
```

#### （2）可扩展：插件化架构，支持新增功能

将 SDK 拆分为 “核心层” 和 “插件层”，核心层提供基础能力（如上报、配置管理），插件层实现具体监控功能（如错误插件、性能插件）：

1. **核心层能力**：

   - 配置管理：提供`getConfig()`/`setConfig()`方法，供插件获取配置；
   - 上报管理：提供`report(data)`方法，统一处理批量、重试、压缩；
   - 插件注册：提供`registerPlugin(plugin)`方法，标准化插件接入。

2. **插件标准化接口**：

   每个插件必须实现`name`（唯一标识）、`init`（初始化）、`destroy`（销毁）三个方法，核心层通过接口调用插件：

   ```javascript
   // 错误监控插件示例
   export const ErrorPlugin = {
     name: 'error', // 插件名，与配置中的modules.error对应
     init(config) {
       // 初始化错误监听（window.onerror等）
       this.bindListeners();
     },
     destroy() {
       // 销毁监听，避免内存泄漏
       this.unbindListeners();
     },
     bindListeners() {
       window.onerror = this.handleError.bind(this);
       // ...其他监听
     },
     handleError(error) {
       // 错误处理逻辑
       report({ type: 'error', ...error });
     }
   };
   
   // 核心层注册插件
   export function registerPlugin(plugin) {
     if (!plugin.name || !plugin.init) {
       console.error('插件必须实现name和init方法');
       return;
     }
     // 存入插件列表
     window.__MONITOR_PLUGINS__ = window.__MONITOR_PLUGINS__ || {};
     window.__MONITOR_PLUGINS__[plugin.name] = plugin;
     // 根据配置决定是否初始化
     const config = getConfig();
     if (config.modules[plugin.name]) {
       plugin.init(config);
     }
   }
   ```

3. **扩展案例**：新增 “小程序监控插件”

   无需修改核心层代码，只需开发新插件，实现`init`/`destroy`：

   ```javascript
   export const MiniProgramPlugin = {
     name: 'miniProgram',
     init(config) {
       // 小程序特有的监控逻辑（如App.onError、Page.onLoad）
       App({
         onError: (error) => report({ type: 'miniProgramError', ...error })
       });
     },
     destroy() {
       // 小程序销毁逻辑
     }
   };
   // 业务方引入并注册
   import { registerPlugin, MiniProgramPlugin } from 'monitor-sdk';
   registerPlugin(MiniProgramPlugin);
   ```

这种架构的优势：新增功能不影响现有代码，插件可独立迭代，业务方按需引入，灵活性极高。

### 9. SDK 的 “数据上报” 模块需要考虑哪些问题？如何设计一个可靠的上报方案？☆☆☆☆

**回答模板**：

上报模块是 SDK 的 “最后一公里”，核心目标是 “**不丢数据、不影响业务、可追溯**”。我们项目从 “**可靠性**”“**安全性**”“**可观测性**” 三个维度设计上报方案：

#### （1）可靠性：确保数据不丢

1. **批量上报 + 内存队列**：
   - 所有待上报数据先存入内存队列（`Array`），500ms 防抖批量上报（减少 HTTP 请求）；
   - 队列满了（如 100 条）强制上报，避免内存溢出。
2. **失败重试机制**：
   - 上报失败后，将数据移入 “重试队列”，重试 3 次，间隔指数退避（1s→2s→4s），避免频繁重试占用资源；
   - 3 次重试失败后，将数据存入`localStorage`（离线缓存），下次页面加载时检查并补发。
3. **上报方式降级**：
   - 优先用`fetch`（支持 POST、大体积数据、CORS）；
   - 不支持`fetch`的浏览器（如 IE11），降级用`img`标签（兼容性最好，适合小体积数据，如错误日志）；
   - `img`标签也失败时（如网络中断），走离线缓存。

核心代码（简化版）：

```javascript
class Reporter {
  constructor() {
    this.queue = []; // 待上报队列
    this.retryQueue = []; // 重试队列
    this.timer = null; // 批量上报定时器
  }

  // 添加数据到队列
  add(data) {
    this.queue.push(data);
    this.triggerBatch(); // 触发批量上报
    // 队列满了强制上报
    if (this.queue.length >= 100) {
      this.reportBatch();
    }
  }

  // 防抖触发批量上报
  triggerBatch() {
    clearTimeout(this.timer);
    this.timer = setTimeout(() => this.reportBatch(), 500);
  }

  // 批量上报
  async reportBatch() {
    if (this.queue.length === 0) return;
    const data = this.queue.splice(0); // 取出队列数据
    try {
      await this.send(data);
      // 上报成功：如果有重试队列，优先上报重试队列
      if (this.retryQueue.length > 0) {
        const retryData = this.retryQueue.splice(0);
        await this.send(retryData);
      }
    } catch (error) {
      // 上报失败：加入重试队列
      this.retryQueue.push(...data);
      // 重试3次后存入localStorage
      if (this.retryQueue.length > 3 * 100) {
        this.saveToLocal(data);
        this.retryQueue = [];
      }
    }
  }

  // 发送请求（支持fetch/img降级）
  send(data) {
    const config = getConfig();
    const jsonData = JSON.stringify(data);
    // 优先用fetch
    if (window.fetch) {
      return fetch(config.reportUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: jsonData,
        credentials: 'include', // 携带Cookie（用于用户标识）
        keepalive: true // 页面卸载时也能完成上报
      }).then(res => {
        if (!res.ok) throw new Error('上报失败');
      });
    }
    // 降级用img标签（只支持GET，需将数据编码为query）
    const img = new Image();
    img.src = `${config.reportUrl}?data=${encodeURIComponent(jsonData)}`;
    return new Promise((resolve, reject) => {
      img.onload = resolve;
      img.onerror = reject;
    });
  }

  // 离线缓存到localStorage
  saveToLocal(data) {
    const key = `monitor_offline_${Date.now()}`;
    localStorage.setItem(key, JSON.stringify(data));
  }

  // 初始化：补发离线缓存
  init() {
    // 遍历localStorage，补发所有离线数据
    Object.keys(localStorage).forEach(key => {
      if (key.startsWith('monitor_offline_')) {
        const data = JSON.parse(localStorage.getItem(key));
        this.add(data);
        localStorage.removeItem(key); // 补发后删除
      }
    });
  }
}
```

#### （2）安全性：确保数据合规、不泄露

1. **数据脱敏**：
   - 用户信息：手机号、邮箱、身份证号用`*`替换（如`138****8000`）；
   - URL 参数：敏感参数（如`token`/`password`）从上报的 URL 中剔除；
   - 响应体：只记录前 200 字符，且过滤`data.user`等敏感字段。
2. **权限控制**：
   - 提供`beforeReport`钩子，业务方可自定义过滤数据（如`beforeReport: (data) => data.type !== 'behavior' ? data : null`，不上报行为数据）；
   - 动态配置 “上报白名单”，只允许指定域名的上报请求（避免恶意使用 SDK 上报垃圾数据）。
3. **隐私合规**：
   - 支持 “用户授权开关”，用户拒绝授权时，不采集行为、设备等敏感数据；
   - 上报数据不包含唯一用户标识（如 UUID），如需用户关联，由业务方传入脱敏后的用户 ID。

#### （3）可观测性：确保上报问题可追溯

1. **上报日志**：
   - 上报成功 / 失败的日志，在开发环境打印到控制台（生产环境关闭），方便调试；
   - 上报数据中加入`reportId`（唯一标识），监控平台可通过`reportId`查询具体上报记录。
2. **上报监控**：
   - 在 SDK 内部监控 “上报成功率”，如果成功率低于 90%，触发告警（如钉钉通知）；
   - 记录上报耗时，如耗时超过 1s，调整批量上报策略（如减少单次上报数据量）。

### 10. 如何设计 SDK 的 “采样策略”？为什么需要采样？

**回答模板**：

采样的核心目的是 “**在保证数据准确性的前提下，降低 SDK 对业务的性能影响和监控平台的存储压力**”—— 如果百万级用户全量上报，每天可能产生 TB 级数据，存储和计算成本极高，且大部分数据是重复的（如同一错误在不同用户端触发）。

我们项目设计了 “**分层采样策略**”，根据 “数据类型” 和 “业务场景” 动态调整采样率，具体如下：

#### （1）为什么需要采样？

1. **降低性能消耗**：全量上报会产生大量 HTTP 请求，占用带宽和主线程资源，尤其是弱网和低端机；
2. **减少存储成本**：监控平台存储全量数据的成本极高（如 100 万用户，每人每天产生 100 条日志，每天 10 亿条，约 100GB）；
3. **保证数据有效性**：大部分重复数据（如同一错误）对分析价值不大，采样后的数据仍能反映整体趋势（如错误率、性能指标分布）。

#### （2）分层采样策略设计

根据数据的 “重要性” 和 “重复率”，设置不同的采样率：

| 数据类型        | 重要性 | 重复率 | 采样率策略                  | 示例                           |
| --------------- | ------ | ------ | --------------------------- | ------------------------------ |
| 错误监控        | 高     | 中     | 100% 全量（关键错误不遗漏） | 所有 JS 错误、资源错误全量上报 |
| 性能监控        | 中     | 高     | 按用户采样（如 50%）        | 50% 用户的 LCP/CLS 数据上报    |
| 行为监控        | 低     | 极高   | 按用户 + 事件采样（如 20%） | 20% 用户的点击、输入事件上报   |
| 白屏 / 崩溃监控 | 极高   | 低     | 100% 全量（严重问题不遗漏） | 所有白屏、页面崩溃全量上报     |

#### （3）采样实现方案

1. **用户级采样**：基于用户唯一标识（如`navigator.userAgent`+`screen.width`的哈希值），确保同一用户始终被采样（或不被采样），避免数据偏差：

   ```javascript
   // 生成用户唯一标识（非隐私数据，只用于采样）
   function generateUserId() {
     const ua = navigator.userAgent;
     const screen = `${window.screen.width}x${window.screen.height}`;
     return md5(`${ua}_${screen}`).slice(0, 8); // 取前8位哈希
   }
   
   // 用户级采样：判断用户是否在采样范围内
   function isUserSampled(sampleRate) {
     if (sampleRate === 100) return true;
     const userId = generateUserId();
     // 将哈希值转为数字（0-15777215，因为8位16进制最大是FF FF FF = 16^6-1=16777215）
     const userNum = parseInt(userId, 16);
     // 采样率=样本数/总数 → 如50%采样率：userNum < 16777215 * 0.5
     return userNum < 16777215 * (sampleRate / 100);
   }
   ```

2. **事件级采样**：对高频事件（如点击），在用户级采样的基础上，再做事件级采样（如 20% 的点击事件上报），进一步减少数据量：

   ```javascript
   // 事件级采样：随机判断当前事件是否上报
   function isEventSampled(sampleRate) {
     if (sampleRate === 100) return true;
     return Math.random() < (sampleRate / 100);
   }
   
   // 行为监控插件中的采样逻辑
   function handleClick(e) {
     const config = getConfig();
     // 先判断用户是否在采样范围内，再判断事件是否被采样
     if (isUserSampled(config.behaviorSampleRate) && isEventSampled(20)) {
       report({ type: 'click', target: e.target.tagName, ... });
     }
   }
   ```

3. **动态调整采样率**：

   - 峰值时段（如电商大促）：自动降低采样率（如从 50% 降至 20%），避免监控平台过载；
   - 新功能上线：提高采样率（如 100%），确保能捕获新功能的错误和性能问题；
   - 异常场景：如错误率突增，自动提高该错误类型的采样率（100%），便于定位原因。

#### （4）采样数据的准确性保障

- **分层抽样**：确保不同用户群体（如不同浏览器、不同设备）的采样比例一致，避免数据偏差；
- **数据校正**：监控平台展示时，用 “采样率” 对数据进行校正（如采样率 50%，统计错误数时乘以 2），反映真实情况；
- **采样日志**：上报数据中携带`sampleRate`字段，方便平台后续分析和校正。

## 四、业务价值与优化类（考察思维高度，加分项）

### 11. 你做的监控 SDK 给业务带来了哪些实际价值？请举 1-2 个具体案例。

**回答模板**：

SDK 的核心价值是 “**提前发现问题、快速定位问题、优化用户体验**”，我们项目落地后，给业务带来了 3 个关键价值，举 2 个具体案例：

#### 案例 1：线上 JS 错误率从 3% 降至 0.5%，挽回百万级用户损失

- **背景**：某电商 APP 的 H5 页面（日活 50 万），用户反馈 “点击购物车后白屏”，但开发无法复现，问题持续 1 周，用户流失率上升 2%。

- SDK 的作用：

  1. 错误监控捕获到 “`cart.js:203 Uncaught TypeError: Cannot read property 'id' of undefined`”，且堆栈显示是 “用户删除最后一件商品后，`cartList[0].id`未判空”；
  2. 关联行为数据发现：该错误只在 “iOS 11 浏览器 + 删除最后一件商品” 场景下触发（之前测试未覆盖该场景）；
  3. 错误上报的用户分布显示：每天有 1.5 万用户触发该错误（错误率 3%），对应约 3000 用户流失（按 2% 流失率）。

- 业务效果：

  开发修复后，错误率降至 0.5% 以下，每天减少 3000 用户流失，按客单价 100 元计算，每月挽回约 90 万营收。

#### 案例 2：首屏加载时间从 6s 优化至 2.5s，转化率提升 15%

- **背景**：某金融产品的注册页，用户反馈 “加载慢”，注册转化率只有 8%，低于行业平均的 12%。

- SDK 的作用：

  1. 性能监控显示：首屏 LCP（最大内容绘制）为 6s（远超谷歌推荐的 2.5s），主要瓶颈是 “首屏 banner 图（2.5MB）加载耗时 3s” 和 “注册接口响应耗时 1.8s”；
  2. 资源监控发现：banner 图未做压缩（原图 2.5MB，压缩后可降至 300KB），且未开启 CDN 加速；
  3. 接口监控显示：注册接口的 TTFB（首字节时间）1.2s，主要是数据库查询未加索引。

- 业务效果：

  优化后（图片压缩 + CDN + 接口加索引），首屏 LCP 降至 2.5s，注册转化率提升至 13.2%，每月新增注册用户约 5000 人，对应新增营收约 25 万元。

### 12. 未来你会如何优化这个 SDK？有哪些规划？

**回答模板**：

基于当前 SDK 的落地效果，未来会从 “**监控维度扩展**”“**智能化能力**”“**跨端适配**” 三个方向优化，具体规划：

1. **监控维度扩展：覆盖更多前端场景**
   - 新增 “用户体验监控”：如页面卡顿（监听`longtask`，超过 50ms 的任务判定为卡顿）、手势操作异常（如移动端双击、滑动无响应）；
   - 新增 “前端安全监控”：如 XSS 攻击（监控`document.write`、`eval`等危险 API 调用）、CSRF 攻击（监控异常的表单提交和接口请求）；
   - 新增 “资源性能监控”：如图片懒加载失效、CSS 阻塞渲染、JS 执行时间过长（帮助定位资源优化点）。
2. **智能化能力：从 “监控” 到 “诊断”**
   - 错误智能分类：基于 AI 模型自动将错误分类（如 “语法错误”“接口错误”“框架错误”），并给出修复建议（如 “未定义变量，建议在使用前判空”）；
   - 性能根因分析：自动关联 “性能指标 - 资源加载 - 接口耗时”，定位性能瓶颈根因（如 “LCP 高是因为 banner 图未压缩，且 CDN 节点延迟高”）；
   - 异常预测：基于历史数据，预测可能出现的问题（如 “某接口近 1 小时响应时间从 500ms 升至 1.5s，可能即将超时，建议排查”）。
3. **跨端适配：覆盖全前端场景**
   - 小程序监控：适配微信 / 支付宝 / 抖音小程序，监控 “小程序启动耗时”“页面切换耗时”“API 调用错误”；
   - Electron / 桌面端监控：监控 “应用启动时间”“渲染进程崩溃”“主进程错误”；
   - 跨端统一上报：提供跨端 SDK（Web / 小程序 / Electron），统一上报格式和监控平台，方便业务方一站式查看全端数据。
4. **性能与体验优化**
   - 更小体积：通过 “按需编译”（业务方只编译需要的模块）和 “代码混淆”，将 SDK 体积从当前的 15KB 降至 8KB 以下；
   - 更快加载：支持 “预加载”（`<link rel="preload" href="monitor-sdk.js">`）和 “CDN 加速”，减少 SDK 加载时间；
   - 更友好的调试：提供 Chrome 插件，可视化查看 SDK 的监控数据（如错误日志、性能指标），无需登录监控平台。

## 五、面试回答技巧总结

1. **结合项目细节**：每个问题的回答都要加入 “我们项目中…”“我当时做的是…”，避免纯理论，体现实战经验；
2. **逻辑清晰**：用 “1. 2. 3.” 或 “背景 - 方案 - 效果” 的结构，让面试官快速抓住重点；
3. **突出解决问题的能力**：难点问题要说明 “痛点是什么→我怎么解决的→解决后效果如何”，而非只说 “我用了 XX 技术”；
4. **展现思考高度**：不仅说 “怎么做”，还要说 “为什么这么做”“有没有更好的方案”“未来如何优化”，体现主动性和深度。