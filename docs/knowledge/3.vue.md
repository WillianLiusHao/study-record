## Vue

### hot（从高到低）

- **一、Vue 基础**
  
  - [x] 1. Vue 权限管理
  - [ ] 2. 双向绑定的使用和原理
  - [ ] 3. nextTick
  - [ ] 4. 组件通讯的方式
  - [ ] 5. v-for 和 v-if 的优先级
  - [ ] 6. computed 和 watch 区别
  - [ ] 7. vue 中如何拓展一个插件
  - [ ] 8. keep-alive 的理解，如何实现，缓存的是什么？
  - [ ] 9. vue 性能优化
  - [ ] 10. 单页应用的理解
  
- **二、生命周期**
  - [ ] 1. 说一下Vue 生命周期
  - [ ] 2. created 和 mounted 的区别
  - [ ] 3. 哪个生命周期发请求
  - [ ] 4. keep-alive 与 生命周期
  - [x] 5. 父子声明周期顺序

- **三、vue-router**
  - [ ] 1. 路由懒加载
  - [ ] 2. history 和 hash 模式的区别
  - [ ] 3. 前端路由的理解
  - [ ] 4. 路由守卫

- **四、vuex**
  - [ ] 1. action 和 mutation 的区别
  - [ ] 2. 五大模块
  - [ ] 3. 刷新后 vuex 状态丢失怎么办？
  - [ ] 4. 如何监听 vuex 的状态变化
  - [ ] 5. 你觉得 vuex 有什么缺点

- **五、vue3.0**
  - [ ] 1. vue3 优化
  - [ ] 2. vue3 为什么用 proxy 代替 Object.defineProperty？
  - [ ] 3. ref 和 reactive 的区别
  
- **六、原理题**
  - [ ] 1. 响应式原理
  - [ ] 2. 模板渲染原理
  - [ ] 3. vdom 理解
  - [ ] 4. diff 过程
  - [ ] 5. key 的作用


### Answer
#### 1. Computed 和 Watch 区别

| 区别 | watch | computed |
| :--: | :--:   | :--: |
| 用法上 | 根据响应式数据作出相应的变化 | 依赖响应式数据的变化而变化，生成了一个新的响应式数据 |
| 特点上 | 无缓存 | `有缓存`，无副作用 |
| 场景上 | 可`异步`，消耗较大 | 用于频繁变动的数据 |
| 原理上 | 相当于属性 `setter` 的回调函数 | 相当于设置了属性的 `getter` |


#### 2. 为什么要使用虚拟DOM？
  - 保证性能的下限

#### 3. 路由的模式？区别？实现原理？

- mode：hash | history

- 区别
  - `hash` 模式带 '#'号
  - `hash` 模式url变化会刷新页面，`history` 模式不会
  - `hash` 模式下,#后面的内容不会发到服务器，服务器配置无需修改；`history` 模式需要修改服务器配置(nginx `try_files`)，否则就`404`

- 实现
  - hash
    - hashChange
  - history
    - pushState: 在历史栈中增加一条新数据
    - replaceState：替换一条数据
    - window.onpopstate: 可监听到浏览器的前进后退，history.go / back / forword 三个方法

#### 4. 从0实现一个vue-router

[mini-vueRouter](../project/mini-router4.md)

[github](https://github.com/WillianLiusHao/single-routers)


#### 5. 组件通讯
  - 父子
    - `porps + emit`
    - $parent/$children、ref/$refs
    
  - 多层
    - `provide + inject`
    - $attrs/$listeners
    - Vue3 `defineExpose + ref`
  
  - 全局
    - `EventBus`
    - Vuex


#### 6. 对 SPA 的理解？优劣？

SPA 即单页应用，仅在页面初始化的时候才会加载 html,css,js；加载完成后不再进行页面的跳转，而是通过路由机制替换当前页面内容。

优点
- 用户体验好，内容改变无需刷新整个页面，页面切换快。
- 对服务器压力小
- 前后端分离，架构清晰

缺点
- SEO 不友好（顺带一提自己做过官网vue项目的seo，一个plugin，可分包，打包成多页）
- 首屏渲染较慢（因为要加载一些非本页面的js和css）

#### 7. vue项目权限设计？

分类：页面权限和按钮权限



#### 8.生命周期

- 8.1 Vue2生命周期？
  - beforeCreated
  - created
  - beforemounted
  - mounted
  - beforeUpdate
  - updated
  - beforeDestory
  - destoryed

- 8.2 Vue3生命周期？
  - create 相关的换成 setup
  - destory 相关的变成 unmount

- 8.3 父子组件生命周期？
  > 记住一句话： `父子子父`
  - 挂载，更新，销毁三个类型都是按照`父子子父`执行

- 8.4 created 和 mounted 的区别？哪个声明周期请求异步数据较好？
  - created
  - 此时数据已经加载完毕，可以更快获取服务端数据，减少页面渲染时间，提升用户体验
  - SSR项目没有mount 相关的生命周期，提高统一性

- 8.5 keep-alive 组件的声明周期？
  - deactivated
  - activated


#### 9.Vue 的性能优化
#### 10. vue 双向绑定的理解

- what：双绑指的是 `v-model` 这个指令，用于绑定一个动态值到视图中，实质上是一个语法糖，相当于 `:value` 和 `@input/@change`
- why：可读性好，提高开发效率
- where：常用于表单中

#### 11. diff 算法

- diff算法是干什么的
- 它的必要性
- 它何时执行
- 具体执行方式
- 拔高：说一下vue3中的优化

- **Vue2 Diff**

双端Diff

- **Vue3 Diff**

快速Diff

1. while1：对比新旧节点头部相同指针的节点，相同则进行diff并`后移指针`，不同则跳出该循环
  
相同时：由于此时两个指针的VNode相同，那么可以复用则直接进行`patch()`更新

```js
// 1. sync from start
// 1. 从开始位置同步
// (a b) c
// (a b) d e
while (i <= e1 && i <= e2) {
  const n1 = c1[i]
  const n2 = c2[i]

  // 节点没有发生变更时，进行patch
  if (isSameVNodeType(n1, n2)) {
    patch(n1, n2)
    // 不同节点时，立刻结束
  } else {
    break
  }
  i++
}
```

2. while2：对比尾部等位指针节点，相同则进行 diff 并 `前移指针`，不同则跳出该循环

```js
// 2. sync from end
// a (b c)
// d e (b c)
while (i <= e1 && i <= e2) {
  const n1 = c1[e1];
  const n2 = (c2[e2] = optimized
    ? cloneIfMounted(c2[e2])
    : normalizeVNode(c2[e2]));
  if (isSameVNodeType(n1, n2)) {
    patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
  }
  else {
    break;
  }
  e1--;
  e2--;
}
```

当前后对比完后，只剩下如下三种情况(增、删、乱序)

3. while3: 仅有新增的节点(此时一定 `e1 < i` 且 `e2 >= i`)

  - 尾部新增
  - 头部新增

```js
// (a b)
// (a b) c
// i = 2, e1 = 1, e2 = 2
// (a b)
// c (a b)
// i = 0, e1 = -1, e2 = 0
if (i > e1) {
  if (i <= e2) {
    const nextPos = e2 + 1;
    // 以 e2+1 为锚点 从i开始往区间里新增
    const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
    while (i <= e2) {
      patch(null, (c2[i] = optimized
        ? cloneIfMounted(c2[i])
        : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      i++;
    }
  }
}
```

4. while4：仅进行了节点删除(此时一定i > e2)

5. while5：乱序的，一定有移动的节点，其中可能包含新增或有删除的节点(此时一定有i <= e2且i <= e1)




#### 12. vue3 对比vue2 优化

- 源码优化
  - monorepo 包管理方式
  - ts 支持
  - 体积优化
    - 移除冷门api(filter,sync,$set,$get等)
    - tree-shaking
- 性能优化
  - proxy
  - diff优化，静态节点
- 语法API
  - composition API


#### 13. Vue 响应式原理

- 依赖收集
- 派发更新



#### 15. Vue 和 react 的区别？各自的优缺点？

#### 16. 你了解哪些Vue性能优化方法？

- 路由懒加载
- 虚拟列表
- 图片懒加载(`v-lazy` 顺便考察自定义指令)
- SSR

- 组件库的按需引入
