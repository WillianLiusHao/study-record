(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{302:function(v,_,e){"use strict";e.r(_);var t=e(6),i=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("Vue 作为前端主流框架，面试 / 笔试中的高频考点集中在"),_("strong",[v._v("核心原理、组件化、响应式、生命周期、性能优化、Vue2/Vue3 差异")]),v._v("等方向，以下按「基础必问」「原理深挖」「实战应用」「Vue3 新特性」四大维度梳理高频考点，附核心答案和考察思路：")]),v._v(" "),_("h3",{attrs:{id:"一、基础必问考点-入门级-必考"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、基础必问考点-入门级-必考"}},[v._v("#")]),v._v(" 一、基础必问考点（入门级，必考）")]),v._v(" "),_("h4",{attrs:{id:"_1-vue-核心特性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue-核心特性"}},[v._v("#")]),v._v(" 1. Vue 核心特性")]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("考察问题")]),v._v("：Vue 的核心特性有哪些？")])]),v._v(" "),_("li",[_("p",[v._v("核心答案：")]),v._v(" "),_("ul",[_("li",[v._v("数据驱动（MVVM 思想，数据变化自动更新视图）；")]),v._v(" "),_("li",[v._v("组件化（独立可复用的 UI 单元，单文件组件 SFC）；")]),v._v(" "),_("li",[v._v("双向绑定（v-model 语法糖，Vue2 "),_("code",[v._v("Object.defineProperty")]),v._v("/Vue3 "),_("code",[v._v("Proxy")]),v._v("）；")]),v._v(" "),_("li",[v._v("指令系统（v-if/v-for/v-bind/v-on 等，简化 DOM 操作）；")]),v._v(" "),_("li",[v._v("生命周期（组件从创建到销毁的完整流程）；")]),v._v(" "),_("li",[v._v("混入（Mixin）/ 插件（Plugin）（逻辑复用）。")])])])]),v._v(" "),_("h4",{attrs:{id:"_2-生命周期-vue2-vue3-对比"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-生命周期-vue2-vue3-对比"}},[v._v("#")]),v._v(" 2. 生命周期（Vue2/Vue3 对比）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("考察问题：")]),v._v(" "),_("ul",[_("li",[v._v("Vue2 生命周期钩子有哪些？执行顺序？")]),v._v(" "),_("li",[v._v("created 和 mounted 的区别？")]),v._v(" "),_("li",[v._v("Vue3 组合式 API 中生命周期如何变化？")])])])]),v._v(" "),_("h4",{attrs:{id:"_3-v-if-vs-v-show"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-v-if-vs-v-show"}},[v._v("#")]),v._v(" 3. v-if vs v-show")]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("考察问题")]),v._v("：v-if 和 v-show 的区别？使用场景？")])]),v._v(" "),_("li",[_("p",[v._v("核心答案")]),v._v(" "),_("ul",[_("li",[v._v("底层逻辑：v-if 是"),_("strong",[v._v("条件渲染")]),v._v("（满足条件才创建 DOM，不满足则销毁）；v-show 是"),_("strong",[v._v("样式切换")]),v._v("（始终创建 DOM，通过 "),_("code",[v._v("display: none")]),v._v(" 控制显示 / 隐藏）。")]),v._v(" "),_("li",[v._v("性能消耗：v-if 切换有"),_("strong",[v._v("编译 / 挂载 / 销毁开销")]),v._v("，初始渲染开销低；v-show 初始渲染开销高，切换开销低。")]),v._v(" "),_("li",[v._v("使用场景：v-if 适用于"),_("strong",[v._v("低频切换")]),v._v("（如权限控制）；v-show 适用于"),_("strong",[v._v("高频切换")]),v._v("（如 Tab 切换）。")]),v._v(" "),_("li",[v._v("额外：v-if 可以和 v-else/v-else-if 配合，v-show 不支持；v-if 优先级高于 v-for（Vue2 中不建议同用，Vue3 修复了优先级问题）。")])])])]),v._v(" "),_("h4",{attrs:{id:"_4-v-for-关键问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-v-for-关键问题"}},[v._v("#")]),v._v(" 4. v-for 关键问题")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("考察问题")]),v._v(" "),_("ul",[_("li",[v._v("v-for 为什么要加 key？key 的作用？")]),v._v(" "),_("li",[v._v("v-for 和 v-if 同用的问题？")])])]),v._v(" "),_("li",[_("p",[v._v("核心答案")]),v._v(" "),_("ul",[_("li",[v._v("key 的作用：作为 DOM 节点的唯一标识，Vue 基于 key 做"),_("strong",[v._v("diff 算法优化")]),v._v("，避免错误的 DOM 复用（如列表乱序、数据更新异常）；key 推荐用唯一 id，而非 index（index 会随列表变化，失去唯一标识意义）。")])])]),v._v(" "),_("li",[_("p",[v._v("v-for 与 v-if 同用（Vue2）：v-for 优先级更高，会先遍历所有元素再判断 v-if，导致"),_("strong",[v._v("性能浪费")]),v._v("；解决方案：外层套 template 用 v-if，或用 computed 过滤列表。")])])]),v._v(" "),_("h4",{attrs:{id:"_5-双向绑定原理-vue2-vue3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-双向绑定原理-vue2-vue3"}},[v._v("#")]),v._v(" 5. 双向绑定原理（Vue2/Vue3）")]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("考察问题")]),v._v("：Vue 的双向绑定原理？Vue2 和 Vue3 的区别？")])]),v._v(" "),_("li",[_("p",[v._v("核心答案")]),v._v(" "),_("ul",[_("li",[v._v("核心思想："),_("strong",[v._v("数据劫持 + 发布 - 订阅模式")]),v._v("。")]),v._v(" "),_("li",[v._v("Vue2 实现：\n"),_("ol",[_("li",[v._v("用 "),_("code",[v._v("Object.defineProperty")]),v._v(" 劫持 data 中所有属性的 getter/setter；")]),v._v(" "),_("li",[v._v("模板编译时，解析指令 / 插值表达式，为每个依赖创建 Watcher；")]),v._v(" "),_("li",[v._v("getter 中收集依赖（Watcher 加入 Dep），setter 中触发 Dep 通知所有 Watcher 更新视图。")])])]),v._v(" "),_("li",[v._v("Vue3 实现：\n"),_("ol",[_("li",[v._v("用 "),_("code",[v._v("Proxy")]),v._v(" 代理整个响应式对象（而非单个属性），支持数组 / 新增属性的劫持；")]),v._v(" "),_("li",[v._v("结合 "),_("code",[v._v("Reflect")]),v._v(" 实现属性操作的拦截，解决 "),_("code",[v._v("Object.defineProperty")]),v._v(" 的局限性；")]),v._v(" "),_("li",[v._v("引入 Reactive Effect 替代 Watcher，基于副作用函数实现依赖收集。")])])]),v._v(" "),_("li",[v._v("局限性对比：Vue2 无法监听数组下标修改 / 对象新增属性（需用 Vue.set）；Vue3 Proxy 天然支持。")])])])]),v._v(" "),_("h3",{attrs:{id:"二、原理深挖考点-中高级-区分度高"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、原理深挖考点-中高级-区分度高"}},[v._v("#")]),v._v(" 二、原理深挖考点（中高级，区分度高）")]),v._v(" "),_("h4",{attrs:{id:"_1-vue-响应式原理深度拆解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue-响应式原理深度拆解"}},[v._v("#")]),v._v(" 1. Vue 响应式原理深度拆解")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("考察问题")]),v._v(" "),_("ul",[_("li",[v._v("为什么 Vue2 无法监听数组的 push/pop 等方法？如何解决？")]),v._v(" "),_("li",[v._v("Dep 和 Watcher 的关系？")]),v._v(" "),_("li",[v._v("Vue3 的响应式系统（Reactive/Ref/Effect）原理？")])])]),v._v(" "),_("li",[_("p",[v._v("核心答案")]),v._v(" "),_("ul",[_("li",[v._v("Vue2 数组问题："),_("code",[v._v("Object.defineProperty")]),v._v(" 只能劫持对象属性，无法劫持数组下标；Vue2 对数组的 7 个变异方法（push/pop/shift/unshift/splice/sort/reverse）做了重写，触发视图更新；但直接修改下标（如 arr [0] = 1）仍无法监听，需用 "),_("code",[v._v("Vue.set(arr, 0, 1)")]),v._v("。")]),v._v(" "),_("li",[v._v("Dep & Watcher：Dep（依赖管理器）对应单个响应式属性，Watcher 对应单个视图依赖；一个 Dep 可包含多个 Watcher（一对多），一个 Watcher 可依赖多个 Dep（多对一）；数据更新时，Dep 遍历所有 Watcher 执行 update。")]),v._v(" "),_("li",[v._v("Vue3 响应式：\n"),_("ul",[_("li",[v._v("Reactive：针对对象，返回 Proxy 代理对象；")]),v._v(" "),_("li",[v._v("Ref：针对基本类型，包装为 {value: xxx} 的对象，通过 getter/setter 劫持；")]),v._v(" "),_("li",[v._v("Effect：副作用函数，执行时收集依赖（track），依赖变化时重新执行（trigger）。")])])])])])]),v._v(" "),_("h4",{attrs:{id:"_2-vue-虚拟-dom-diff-算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-vue-虚拟-dom-diff-算法"}},[v._v("#")]),v._v(" 2. Vue 虚拟 DOM & Diff 算法")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("考察问题")]),v._v(" "),_("ul",[_("li",[v._v("为什么需要虚拟 DOM？")]),v._v(" "),_("li",[v._v("Vue 的 Diff 算法核心逻辑？")]),v._v(" "),_("li",[v._v("Key 在 Diff 中的作用？")])])]),v._v(" "),_("li",[_("p",[v._v("核心答案")]),v._v(" "),_("ul",[_("li",[v._v("虚拟 DOM 意义：用 JS 对象描述 DOM 结构，避免直接操作真实 DOM（开销大）；跨平台（可渲染到小程序 / Canvas 等）；批量更新，减少 DOM 操作次数。")]),v._v(" "),_("li",[v._v("Vue Diff 核心（同级比较，非跨层级）：\n"),_("ol",[_("li",[v._v("先判断节点类型，类型不同直接销毁旧节点创建新节点；")]),v._v(" "),_("li",[v._v("类型相同则对比属性（props/class/style），更新差异；")]),v._v(" "),_("li",[v._v("列表对比（v-for）：用 key 建立新旧节点的映射，采用"),_("strong",[v._v("双指针法")]),v._v("（头头 / 尾尾 / 头尾 / 尾头）快速匹配，减少移动 / 删除操作；")]),v._v(" "),_("li",[v._v("无法匹配时，用 key 生成的映射表查找，找不到则创建新节点，最后处理剩余节点。")])])]),v._v(" "),_("li",[v._v("Key 的作用：让 Diff 算法快速定位相同节点，避免不必要的 DOM 移动 / 重建，提升列表更新性能。")])])])]),v._v(" "),_("h4",{attrs:{id:"_3-组件通信方式-全场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-组件通信方式-全场景"}},[v._v("#")]),v._v(" 3. 组件通信方式（全场景）")]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("考察问题")]),v._v("：Vue 有哪些组件通信方式？适用场景？")])]),v._v(" "),_("li",[_("p",[v._v("核心答案")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("通信方式")]),v._v(" "),_("th",[v._v("适用场景")]),v._v(" "),_("th",[v._v("核心用法")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("props/$emit")]),v._v(" "),_("td",[v._v("父子组件")]),v._v(" "),_("td",[v._v("父传子用 props，子传父用 $emit")])]),v._v(" "),_("tr",[_("td",[_("em",[v._v("p"),_("strong",[v._v("a")]),v._v("re"),_("strong",[v._v("n")]),v._v("t")]),v._v("/children")]),v._v(" "),_("td",[v._v("父子组件（直接访问）")]),v._v(" "),_("td",[v._v("子组件 this.$parent 访问父实例")])]),v._v(" "),_("tr",[_("td",[v._v("$refs")]),v._v(" "),_("td",[v._v("父访问子组件（DOM / 实例）")]),v._v(" "),_("td",[v._v('父组件 ref="xxx" → this.$refs.xxx')])]),v._v(" "),_("tr",[_("td",[v._v("provide/inject")]),v._v(" "),_("td",[v._v("跨层级组件（祖孙）")]),v._v(" "),_("td",[v._v("父 provide 提供数据，子 inject 注入")])]),v._v(" "),_("tr",[_("td",[v._v("Vuex/Pinia")]),v._v(" "),_("td",[v._v("全局状态管理（任意组件）")]),v._v(" "),_("td",[v._v("集中式存储，响应式共享")])]),v._v(" "),_("tr",[_("td",[v._v("EventBus")]),v._v(" "),_("td",[v._v("任意组件（小型项目）")]),v._v(" "),_("td",[v._v("新建 Vue 实例作为事件中心")])]),v._v(" "),_("tr",[_("td",[_("em",[v._v("a"),_("strong",[v._v("tt")]),v._v("rs")]),v._v("/listeners")]),v._v(" "),_("td",[v._v("跨层级透传（祖孙）")]),v._v(" "),_("td",[v._v("父传子未声明的 props 存入 $attrs")])])])]),v._v(" "),_("ul",[_("li",[v._v("补充：Vue3 中 $attrs 包含 class/style，Vue2 不包含；Pinia 替代 Vuex 成为官方推荐，更轻量、支持 TypeScript。")])])])]),v._v(" "),_("h4",{attrs:{id:"_4-mixin-原理-优缺点-延伸到-composition-api"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-mixin-原理-优缺点-延伸到-composition-api"}},[v._v("#")]),v._v(" 4. Mixin 原理 & 优缺点（延伸到 Composition API）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("考察问题")]),v._v(" "),_("ul",[_("li",[v._v("Mixin 的合并规则？")]),v._v(" "),_("li",[v._v("Mixin 的缺点？为什么 Vue3 推荐 Composition API？")])])]),v._v(" "),_("li",[_("p",[v._v("核心答案")]),v._v(" "),_("p",[v._v("（结合前文原理）：")]),v._v(" "),_("ul",[_("li",[v._v("合并规则：生命周期钩子数组合并（混入先执行），data / 方法同名覆盖（组件 > 混入），watch 数组合并（混入先执行）；")]),v._v(" "),_("li",[v._v("Mixin 缺点：命名冲突、逻辑来源模糊、不支持参数；")]),v._v(" "),_("li",[v._v("Composition API 优势：函数式组合，逻辑来源清晰；支持参数传递；无命名冲突；更好的 TypeScript 支持。")])])])]),v._v(" "),_("h4",{attrs:{id:"_5-异步更新队列-nexttick-原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-异步更新队列-nexttick-原理"}},[v._v("#")]),v._v(" 5. 异步更新队列（$nextTick 原理）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("考察问题")]),v._v(" "),_("ul",[_("li",[v._v("Vue 的异步更新原理？为什么需要 $nextTick？")]),v._v(" "),_("li",[v._v("$nextTick 的实现方式？")])])]),v._v(" "),_("li",[_("p",[v._v("核心答案")]),v._v(" "),_("ul",[_("li",[v._v("异步更新原因：Vue 为提升性能，将数据更新的视图更新操作"),_("strong",[v._v("批量延迟执行")]),v._v("，而非同步更新；数据变化时，Watcher 标记为脏，放入异步队列，等待下一个事件循环执行更新。")]),v._v(" "),_("li",[v._v("$nextTick 作用：等待异步更新队列执行完成后执行回调，保证获取到更新后的 DOM。")]),v._v(" "),_("li",[v._v("实现方式：优先使用微任务（Promise.then > MutationObserver），降级到宏任务（setTimeout）；Vue3 中统一使用 Promise。")])])])]),v._v(" "),_("h3",{attrs:{id:"三、实战应用考点-工程化-性能-问题排查"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、实战应用考点-工程化-性能-问题排查"}},[v._v("#")]),v._v(" 三、实战应用考点（工程化 / 性能 / 问题排查）")]),v._v(" "),_("h4",{attrs:{id:"_1-vue-性能优化手段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue-性能优化手段"}},[v._v("#")]),v._v(" 1. Vue 性能优化手段")]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("考察问题")]),v._v("：Vue 项目有哪些性能优化方式？")])]),v._v(" "),_("li",[_("p",[v._v("核心答案")]),v._v(" "),_("ul",[_("li",[v._v("代码层面：\n"),_("ol",[_("li",[v._v("合理使用 v-if/v-show，避免 v-for 与 v-if 同用；")]),v._v(" "),_("li",[v._v("列表优化：key 用唯一 id，大数据列表用虚拟列表（vue-virtual-scroller）；")]),v._v(" "),_("li",[v._v("响应式优化：非响应式数据不放入 data（用 Object.freeze 冻结）；")]),v._v(" "),_("li",[v._v("计算属性缓存：用 computed 替代方法（避免重复执行）；")]),v._v(" "),_("li",[v._v("异步组件：路由 / 组件按需加载（const Comp = () => import ('./Comp.vue')）。")])])]),v._v(" "),_("li",[v._v("工程化层面：\n"),_("ol",[_("li",[v._v("打包优化：Tree-Shaking、CDN 引入第三方库、压缩代码；")]),v._v(" "),_("li",[v._v("懒加载：路由懒加载、图片懒加载（v-lazy）；")]),v._v(" "),_("li",[v._v("缓存优化：keep-alive 缓存组件（避免重复渲染）；")]),v._v(" "),_("li",[v._v("服务端优化：SSR（Nuxt.js）提升首屏加载速度。")])])]),v._v(" "),_("li",[v._v("进阶优化：\n"),_("ol",[_("li",[v._v("自定义指令封装高频 DOM 操作；")]),v._v(" "),_("li",[v._v("避免过度响应式：Vue3 中用 shallowReactive/shallowRef；")]),v._v(" "),_("li",[v._v("事件解绑：组件销毁前解绑自定义事件，避免内存泄漏。")])])])])])]),v._v(" "),_("h4",{attrs:{id:"_2-keep-alive-原理-应用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-keep-alive-原理-应用"}},[v._v("#")]),v._v(" 2. keep-alive 原理 & 应用")]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("考察问题")]),v._v("：keep-alive 的作用？原理？激活 / 失活钩子？")])]),v._v(" "),_("li",[_("p",[v._v("核心答案")]),v._v(" "),_("ul",[_("li",[v._v("作用：缓存组件实例，避免重复创建 / 销毁，提升切换性能（如 Tab 切换）。")]),v._v(" "),_("li",[v._v("原理：\n"),_("ol",[_("li",[v._v("keep-alive 是抽象组件（不渲染真实 DOM），内部维护一个缓存对象（cache），存储组件实例；")]),v._v(" "),_("li",[v._v("组件首次渲染时存入 cache，再次渲染时直接从 cache 取出，不执行 created/mounted 钩子；")]),v._v(" "),_("li",[v._v("可通过 include/exclude 属性指定缓存 / 排除的组件，max 属性限制缓存数量（LRU 策略）。")])])]),v._v(" "),_("li",[v._v("钩子：缓存组件激活时触发 "),_("code",[v._v("activated")]),v._v("，失活时触发 "),_("code",[v._v("deactivated")]),v._v("（Vue3 中对应 onActivated/onDeactivated）。")])])])]),v._v(" "),_("h4",{attrs:{id:"_3-路由相关-vue-router"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-路由相关-vue-router"}},[v._v("#")]),v._v(" 3. 路由相关（Vue Router）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("考察问题")]),v._v(" "),_("ul",[_("li",[v._v("路由守卫有哪些？执行顺序？")]),v._v(" "),_("li",[v._v("路由懒加载如何实现？")]),v._v(" "),_("li",[v._v("hash 模式 vs history 模式的区别？")])])]),v._v(" "),_("li",[_("p",[v._v("核心答案")]),v._v(" "),_("ul",[_("li",[v._v("路由守卫分类：\n"),_("ol",[_("li",[v._v("全局守卫：beforeEach（前置）、beforeResolve（解析前）、afterEach（后置）；")]),v._v(" "),_("li",[v._v("路由独享守卫：beforeEnter；")]),v._v(" "),_("li",[v._v("组件内守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave；")])])]),v._v(" "),_("li",[v._v("执行顺序：全局 beforeEach → 路由 beforeEnter → 组件 beforeRouteEnter → 全局 beforeResolve → 全局 afterEach。")]),v._v(" "),_("li",[v._v("路由懒加载：结合 import () 动态导入，如 "),_("code",[v._v("{ path: '/home', component: () => import('./Home.vue') }")]),v._v("，打包时拆分 chunk，减小首屏体积。")]),v._v(" "),_("li",[v._v("模式区别：\n"),_("ul",[_("li",[v._v("hash 模式：基于 URL hash（#），兼容性好，无需后端配置；")]),v._v(" "),_("li",[v._v("history 模式：基于 HTML5 History API，URL 无 #，需后端配置（nginx 重定向到 index.html），避免刷新 404。")])])])])])]),v._v(" "),_("h4",{attrs:{id:"_4-常见问题排查"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-常见问题排查"}},[v._v("#")]),v._v(" 4. 常见问题排查")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("考察问题")]),v._v(" "),_("ul",[_("li",[v._v("为什么 data 必须是函数？")]),v._v(" "),_("li",[v._v("组件中修改 props 会报错？如何解决？")]),v._v(" "),_("li",[v._v("子组件无法更新父组件数据？")])])]),v._v(" "),_("li",[_("p",[v._v("核心答案")]),v._v(" "),_("ul",[_("li",[v._v("data 是函数：组件复用时，函数返回新的对象，避免多个实例共享同一数据（如果是对象，所有实例会修改同一个对象）；")]),v._v(" "),_("li",[v._v("修改 props 报错：props 是单向数据流（父传子），子组件不能直接修改；解决方案：子组件通过 $emit 通知父组件修改，或在子组件中定义 data 接收 props 作为初始值；")]),v._v(" "),_("li",[v._v("子组件更新父组件数据：通过 $emit 触发父组件方法，由父组件修改数据（单向数据流原则）。")])])])]),v._v(" "),_("h3",{attrs:{id:"四、vue3-核心新特性-高频新增考点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四、vue3-核心新特性-高频新增考点"}},[v._v("#")]),v._v(" 四、Vue3 核心新特性（高频新增考点）")]),v._v(" "),_("h4",{attrs:{id:"_1-composition-api-核心"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-composition-api-核心"}},[v._v("#")]),v._v(" 1. Composition API 核心")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("考察问题")]),v._v(" "),_("ul",[_("li",[v._v("setup 函数的作用？执行时机？")]),v._v(" "),_("li",[v._v("Reactive vs Ref 的区别？使用场景？")]),v._v(" "),_("li",[v._v("Computed & Watch 的用法变化？")])])]),v._v(" "),_("li",[_("p",[v._v("核心答案")]),v._v(" "),_("ul",[_("li",[v._v("setup：组件的入口，替代选项式 API（data/methods 等）；执行时机在 beforeCreate 之前，this 为 undefined；返回对象 / 函数（渲染函数）。")]),v._v(" "),_("li",[v._v("Reactive vs Ref：\n"),_("ul",[_("li",[v._v("Reactive：代理对象，仅支持对象 / 数组，不能代理基本类型；")]),v._v(" "),_("li",[v._v("Ref：包装基本类型为 {value: xxx}，对象类型内部会调用 reactive；模板中访问 ref 无需 .value（自动解包），js 中需 .value。")])])]),v._v(" "),_("li",[v._v("Computed/Watch：\n"),_("ul",[_("li",[v._v("Computed：支持传入 getter/setter，返回 ref 对象；")]),v._v(" "),_("li",[v._v("Watch：支持监听多个源，支持深度监听（deep）、立即执行（immediate），返回停止监听的函数。")])])])])])]),v._v(" "),_("h4",{attrs:{id:"_2-vue3-架构变化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-vue3-架构变化"}},[v._v("#")]),v._v(" 2. Vue3 架构变化")]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("考察问题")]),v._v("：Vue3 为什么用 TS 重构？架构上的优化？")])]),v._v(" "),_("li",[_("p",[v._v("核心答案")]),v._v(" "),_("ul",[_("li",[v._v("TS 重构：提升类型安全，支持更好的 TypeScript 集成，降低维护成本；")]),v._v(" "),_("li",[v._v("架构优化：\n"),_("ol",[_("li",[v._v("模块化拆分（如 reactivity 模块可独立使用）；")]),v._v(" "),_("li",[v._v("编译优化（PatchFlags 标记动态节点，减少 Diff 范围）；")]),v._v(" "),_("li",[v._v("体积优化（Tree-Shaking 支持，按需引入功能）。")])])])])])]),v._v(" "),_("h4",{attrs:{id:"_3-teleport-瞬移组件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-teleport-瞬移组件"}},[v._v("#")]),v._v(" 3. Teleport（瞬移组件）")]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("考察问题")]),v._v("：Teleport 的作用？使用场景？")])]),v._v(" "),_("li",[_("p",[v._v("核心答案")]),v._v(" "),_("ul",[_("li",[v._v("作用：将组件的 DOM 结构渲染到指定的 DOM 节点下（如 body），但组件的逻辑仍属于当前组件；")])])]),v._v(" "),_("li",[_("p",[v._v("场景：弹窗 / 模态框（避免父组件样式溢出 / 层级问题）。")])])]),v._v(" "),_("h4",{attrs:{id:"_4-suspense-组件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-suspense-组件"}},[v._v("#")]),v._v(" 4. Suspense 组件")]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("考察问题")]),v._v("：Suspense 的作用？如何使用？")])]),v._v(" "),_("li",[_("p",[v._v("核心答案")]),v._v(" "),_("ul",[_("li",[v._v("作用：等待异步组件加载完成前显示 fallback 内容（如加载中），提升用户体验；")])])]),v._v(" "),_("li",[_("p",[v._v("使用：包裹异步组件，通过 default 插槽放异步组件，fallback 插槽放加载提示。")])])]),v._v(" "),_("h3",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),_("p",[v._v("Vue 高频考点可归纳为：")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("基础概念")]),v._v("：生命周期、指令、双向绑定；")]),v._v(" "),_("li",[_("strong",[v._v("核心原理")]),v._v("：响应式、虚拟 DOM/Diff、异步更新、Mixin；")]),v._v(" "),_("li",[_("strong",[v._v("实战应用")]),v._v("：组件通信、性能优化、路由、工程化；")]),v._v(" "),_("li",[_("strong",[v._v("Vue3 升级")]),v._v("：Composition API、架构优化、新组件（Teleport/Suspense）。")])]),v._v(" "),_("p",[v._v("备考时需结合「原理理解 + 代码实践」，不仅要记结论，还要理解底层逻辑（如 Diff 算法、响应式劫持），并能结合实际项目场景分析问题（如性能优化、通信方式选型）。")])])}),[],!1,null,null,null);_.default=i.exports}}]);