(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{242:function(v,_,t){"use strict";t.r(_);var l=t(6),s=Object(l.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"v8垃圾回收机制-gc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#v8垃圾回收机制-gc"}},[v._v("#")]),v._v(" V8垃圾回收机制(GC)")]),v._v(" "),_("blockquote",[_("p",[_("a",{attrs:{href:"https://juejin.cn/post/6981588276356317214",target:"_blank",rel:"noopener noreferrer"}},[v._v("「硬核JS」你真的了解垃圾回收机制吗"),_("OutboundLink")],1)])]),v._v(" "),_("h2",{attrs:{id:"相关问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#相关问题"}},[v._v("#")]),v._v(" 相关问题")]),v._v(" "),_("p",[_("strong",[v._v("1. 什么是垃圾回收机制？")])]),v._v(" "),_("p",[_("code",[v._v("垃圾")]),v._v("：程序工作过程中，不用或者用过了，之后不会再用的内存空间\n"),_("code",[v._v("垃圾回收")]),v._v("：浏览器内部引擎自动执行，处理垃圾并回收内存空间的过程")]),v._v(" "),_("p",[_("strong",[v._v("2. 为什么要进行垃圾回收？")])]),v._v(" "),_("p",[_("strong",[v._v("3. 垃圾是怎么产生的？")])]),v._v(" "),_("p",[_("strong",[v._v("4. 垃圾回收是怎么进行的？")])]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("标记清除算法")]),v._v(" (JS引擎最常用)")]),v._v(" "),_("ul",[_("li",[_("p",[_("code",[v._v("优")]),v._v("：实现简单")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("缺")]),v._v("：")]),v._v(" "),_("ul",[_("li",[v._v("内存碎片化：清除后，空间内存变得不连续")]),v._v(" "),_("li",[v._v("分配速度慢：内存不连续，直接导致每次分配新内存时，需要对碎片内存遍历以寻找合适的内存空间")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://images.vrm.cn/ox/2023/02/06/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png",alt:""}})])]),v._v(" "),_("li",[_("p",[_("code",[v._v("优化")])]),v._v(" "),_("ul",[_("li",[v._v("标记整理：在标记结束后，会将所有活着的对象向内存一端移动，再进行清理")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://images.vrm.cn/ox/2023/02/06/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png",alt:""}})])])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("引用计数算法")]),v._v("\n- "),_("code",[v._v("缺点")]),v._v("：循环引用导致内存无法释放")])])]),v._v(" "),_("p",[_("strong",[v._v("5. V8做了哪些优化？")])]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("分代式垃圾回收")])]),v._v(" "),_("ul",[_("li",[_("p",[_("code",[v._v("新生代")]),v._v("：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("Scavenge => Cheney算法")])]),v._v(" "),_("li",[_("p",[v._v("分为"),_("code",[v._v("使用区")]),v._v(" 和 "),_("code",[v._v("空闲区")]),v._v("： 新加入的对象会进入使用区，当使用区快写满时，执行一次垃圾清理")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("垃圾清理过程")]),v._v(":")]),v._v(" "),_("ul",[_("li",[v._v("step1：对使用区(From空间)垃圾进行标记")]),v._v(" "),_("li",[v._v("step2：将使用区的活动对象(不用清理的)复制进空闲区(To空间)并排序(整理)")]),v._v(" "),_("li",[v._v("step3：清空使用区的所有内存")]),v._v(" "),_("li",[v._v("step4：交换使用区和空闲区(交换完后空闲区是空的)")])])]),v._v(" "),_("li",[_("p",[v._v("晋升条件：")]),v._v(" "),_("ul",[_("li",[v._v("当复制一个对象进入空闲区的时候，如果该对象已经经历过一次Scavenge回收，会直接移动到老生代空间")]),v._v(" "),_("li",[v._v("当复制一个对象进入空闲区的时候，如果空闲区的占用超过了"),_("strong",[v._v("25%")]),v._v("，该对象会直接进入老生代")])])])])]),v._v(" "),_("li",[_("p",[_("code",[v._v("老生代")]),v._v("：")]),v._v(" "),_("ul",[_("li",[v._v("使用标记清除法（V8则使用标记整理法进行优化）")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://images.vrm.cn/ox/2023/02/06/%E5%88%86%E4%BB%A3%E5%BC%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png",alt:""}}),v._v("\n​")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("分代的优点")]),v._v("：")]),v._v(" "),_("ul",[_("li",[v._v("分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，可以说此机制的出现很大程度"),_("code",[v._v("提高了垃圾回收机制的效率")])])])])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("并行回收")]),v._v("（对新生代的优化）")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("增量标记与惰性清理")]),v._v("（对老生代的优化）")]),v._v(" "),_("ul",[_("li",[v._v("优化空间：分代回收提高了回收效率，但还是一种"),_("code",[v._v("全停顿")]),v._v("(执行垃圾回收的时候，会阻塞js主线程)的方式")]),v._v(" "),_("li",[v._v("概念：将一次"),_("code",[v._v("GC")]),v._v("标记过程，分成多个小步，每执行完一小步就让应用逻辑执行一会儿，交替多次")]),v._v(" "),_("li",[v._v("关键：怎么暂停垃圾回收？ 怎么继续回收？")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://images.vrm.cn/ox/2023/02/06/%E5%A2%9E%E9%87%8F%E6%A0%87%E8%AE%B0.png",alt:""}})]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("三色标记法(暂停与恢复)")])]),v._v(" "),_("ul",[_("li",[v._v("利用灰色标记下一次要开始执行标记的位置，从而实现了暂停与恢复")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("写屏障")])]),v._v(" "),_("ul",[_("li",[v._v("解决了在js脚本执行过程中新加入的对象无法被标记的问题")])])])])])])])}),[],!1,null,null,null);_.default=s.exports}}]);